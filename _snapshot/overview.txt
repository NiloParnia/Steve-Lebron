----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\client\StarterGui\ScreenGui\LocalScript.client.lua -----
-- ScreenGui/LocalScript  — CLEAN VERSION (no unlock stuff)

---------------- Services ----------------
local Players       = game:GetService("Players")
local Replicated    = game:GetService("ReplicatedStorage")
local TweenService  = game:GetService("TweenService")
local RunService    = game:GetService("RunService")
local StarterGui    = game:GetService("StarterGui")
local UIS           = game:GetService("UserInputService")
local TS            = game:GetService("TweenService")

local player = Players.LocalPlayer
local gui    = script.Parent  -- your existing ScreenGui instance
if gui:IsA("ScreenGui") then
	gui.IgnoreGuiInset = true -- normalize across Studio/live, center math stays true
end

---------------- Menu Pieces (placement only; toggle is at bottom) ----------------
local SmallIcon  = gui:WaitForChild("SmallIcon")
local MenuFrame  = gui:WaitForChild("MenuFrame")

-- small icon: always bottom-right
SmallIcon.AnchorPoint = Vector2.new(1,1)
SmallIcon.Position    = UDim2.new(1, -16, 1, -16) -- margin tweakable

-- menu: centered when open, dumped below screen when closed
MenuFrame.AnchorPoint = Vector2.new(0.5, 0.5)
local OPEN_POS   = UDim2.fromScale(0.5, 0.5)   -- camera/screen center
local CLOSED_POS = UDim2.new(0.5, 0, 1.2, 0)   -- dump below screen
MenuFrame.Position = CLOSED_POS
MenuFrame.Visible  = false

-- global-ish menu state for other blocks
local isMenuOpen = false

----------------------------------------------------------------
--                      HUD: COOLDOWNS (robust clocks + visible)
----------------------------------------------------------------
local RemoteEvents   = Replicated:WaitForChild("RemoteEvents")
local CooldownNotice = RemoteEvents:WaitForChild("CooldownNotice")

-- Toggle this to bypass unlockables filtering for testing
local ONLY_UNLOCKABLES = true

-- Live allow-list from ReplicatedStorage/Unlockables
local UNLOCKABLES_SET = {}
local function refreshUnlockablesClient()
	table.clear(UNLOCKABLES_SET)
	local f = Replicated:FindFirstChild("Unlockables")
	if f then
		for _, sv in ipairs(f:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				UNLOCKABLES_SET[sv.Value] = true
			end
		end
	end
end
refreshUnlockablesClient()
local uf = Replicated:FindFirstChild("Unlockables")
if uf then
	uf.ChildAdded:Connect(refreshUnlockablesClient)
	uf.ChildRemoved:Connect(refreshUnlockablesClient)
end

-- Container (top-right)
local cdContainer = Instance.new("Frame")
cdContainer.Name = "CooldownStack"
cdContainer.AnchorPoint = Vector2.new(1,0)
cdContainer.Position = UDim2.new(1, -12, 0, 12)
cdContainer.Size = UDim2.new(0, 260, 1, -24)
cdContainer.BackgroundTransparency = 1
cdContainer.Visible = false
cdContainer.Parent = gui

local cdList = Instance.new("UIListLayout")
cdList.FillDirection = Enum.FillDirection.Vertical
cdList.HorizontalAlignment = Enum.HorizontalAlignment.Right
cdList.VerticalAlignment = Enum.VerticalAlignment.Top
cdList.SortOrder = Enum.SortOrder.LayoutOrder
cdList.Padding = UDim.new(0, 6)
cdList.Parent = cdContainer

local cdItems = {} -- [name] = {frame,label,bar,endsAtClock,duration}

local function setCdContainerVisible()
	for _ in pairs(cdItems) do
		cdContainer.Visible = true
		return
	end
	cdContainer.Visible = false
end

local function createCdItem(name: string)
	local f = Instance.new("Frame")
	f.Name = name
	f.Size = UDim2.new(0, 260, 0, 34)
	f.BackgroundColor3 = Color3.fromRGB(25,25,25)
	f.BackgroundTransparency = 0.15
	f.BorderSizePixel = 0
	f.Parent = cdContainer

	local title = Instance.new("TextLabel")
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -10, 1, -14)
	title.Position = UDim2.new(0, 10, 0, 2)
	title.Font = Enum.Font.GothamSemibold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextColor3 = Color3.new(1,1,1)
	title.TextScaled = true
	title.Text = name .. ": 0.0s"
	title.Parent = f

	local barBg = Instance.new("Frame")
	barBg.BorderSizePixel = 0
	barBg.BackgroundColor3 = Color3.fromRGB(50,50,50)
	barBg.Size = UDim2.new(1, -12, 0, 4)
	barBg.Position = UDim2.new(0, 6, 1, -6)
	barBg.Parent = f

	local bar = Instance.new("Frame")

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\client\StarterPlayerScripts\CustomShiftlock.client.lua -----
-- CustomShiftlock.client.lua (two-attachment AO; camera-facing yaw or no lock)
-- Make sure StarterPlayer.EnableMouseLockOption = false (disables Roblox default shiftlock).

local Players    = game:GetService("Players")
local UIS        = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace  = game:GetService("Workspace")

local player = Players.LocalPlayer
local cam    = Workspace.CurrentCamera

-- ========= CONFIG =========
local LOCK_MOUSE   = true      -- center mouse while locked
local SHOW_CURSOR  = false
local LOCK_BODY    = true      -- << set to false to NOT rotate body; still toggles mouse lock

-- ========= STATE =========
local isLocked = false
local char, hum, hrp
local att0        -- Attachment on HRP
local ao          -- AlignOrientation on HRP
local aimPart     -- invisible anchored part we rotate to camera yaw
local aimAtt      -- Attachment on aimPart

-- ========= UTILS =========
local function flat(v: Vector3)
	local f = Vector3.new(v.X, 0, v.Z)
	return (f.Magnitude > 1e-4) and f.Unit or Vector3.new(0,0,-1)
end

local function setMouseLock(on: boolean)
	if not UIS.MouseEnabled then return end
	UIS.MouseBehavior    = (on and LOCK_MOUSE) and Enum.MouseBehavior.LockCenter or Enum.MouseBehavior.Default
	UIS.MouseIconEnabled = (not on) or SHOW_CURSOR
end

-- Build/remove constraint (TWO-ATTACHMENT mode ensures world-yaw matches camera)
local function ensureConstraint()
	if not (LOCK_BODY and hrp) then return end

	if not aimPart then
		aimPart = Instance.new("Part")
		aimPart.Name = "_ShiftlockAim"
		aimPart.Size = Vector3.new(0.2, 0.2, 0.2)
		aimPart.Anchored = true
		aimPart.CanCollide = false
		aimPart.Transparency = 1
		aimPart.CFrame = hrp.CFrame
		aimPart.Parent = Workspace
	end
	if not aimAtt then
		aimAtt = Instance.new("Attachment")
		aimAtt.Name = "_ShiftlockA1"
		aimAtt.Parent = aimPart
	end
	if not att0 then
		att0 = Instance.new("Attachment")
		att0.Name = "_ShiftlockA0"
		att0.Parent = hrp
	end
	if not ao then
		ao = Instance.new("AlignOrientation")
		ao.Name = "_ShiftlockAO"
		ao.Attachment0 = att0
		ao.Attachment1 = aimAtt
		ao.RigidityEnabled = true      -- crisp lock
		ao.Responsiveness  = 200       -- snappy
		ao.ReactionTorqueEnabled = false
		-- Be generous with torque if your character is heavy:
		pcall(function() ao.MaxTorque = math.huge end)
		ao.Parent = hrp
	end
end

local function destroyConstraint()
	if ao then ao:Destroy(); ao = nil end
	if att0 then att0:Destroy(); att0 = nil end
	if aimAtt then aimAtt:Destroy(); aimAtt = nil end
	if aimPart then aimPart:Destroy(); aimPart = nil end
end

-- ========= ALIGN LOOP =========
local BIND = "CustomShiftlockAlign_TwoAttach"

local function alignStep()
	if not isLocked then return end
	if LOCK_BODY and not (hum and hrp and ao and aimPart) then return end
	if not cam then return end

	-- Skip physics-hostile states
	local st = hum and hum:GetState()
	if st == Enum.HumanoidStateType.Seated
		or st == Enum.HumanoidStateType.Dead
		or st == Enum.HumanoidStateType.Ragdoll then
		return
	end

	-- Update the (invisible) aimPart’s orientation to camera yaw.
	-- Using hrp.Position keeps the yaw intuitive; position doesn't matter for AO.
	local f = flat(cam.CFrame.LookVector)
	if LOCK_BODY and aimPart then
		local pos = hrp and hrp.Position or aimPart.Position
		aimPart.CFrame = CFrame.lookAt(pos, pos + f, Vector3.yAxis)
	end
end

local function bindLoop()
	RunService:BindToRenderStep(BIND, Enum.RenderPriority.Last.Value, alignStep)
end

local function unbindLoop()
	pcall(function() RunService:UnbindFromRenderStep(BIND) end)
end

-- ========= TOGGLE =========
local function setLocked(on: boolean)
	isLocked = on
	if hum then hum.AutoRotate = not (on and LOCK_BODY) end
	if char then char:SetAttribute("CustomShiftlock", on and LOCK_BODY) end


----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\client\StarterPlayerScripts\HorseMountClient.client.lua -----
-- StarterPlayerScripts/HorseMountClient.client.lua
-- While mounted:
--   W          = throttle
--   Space      = jump
--   Q          = GALLOP (spends a DodgeCharge)  ← overrides your normal Q-dodge
--   R          = dismount
-- On dismount, we unbind and your regular Q-dodge works again.

local Players       = game:GetService("Players")
local RS            = game:GetService("ReplicatedStorage")
local RunService    = game:GetService("RunService")
local CAS           = game:GetService("ContextActionService")

local player        = Players.LocalPlayer

-- === Remotes ===
local RE            = RS:WaitForChild("RemoteEvents")
local RE_Face       = RE:WaitForChild("Horse_Face")
local RE_Move       = RE:WaitForChild("Horse_Move")
local RE_Jump       = RE:WaitForChild("Horse_Jump")
local RE_Dismount   = RE:WaitForChild("Horse_RequestDismount")
local RE_Gallop     = RE:WaitForChild("Horse_Gallop")

-- === Config ===
local SEAT_NAME     = "SaddleSeat"
local GALLOP_KEY    = Enum.KeyCode.Q    -- ← replace your dodge key here if different
local PRIORITY      = (Enum.ContextActionPriority.High.Value or 2000) + 1
local DEBUG         = false
local function dprint(...) if DEBUG then print("[HorseClient]", ...) end end

-- === State ===
local mountedHorse: Model? = nil
local forwardDown          = false
local faceConn             = nil

-- === Helpers ===
local function isHorseSeat(seat: Instance?): boolean
	if not (seat and seat:IsA("Seat") and seat.Name == SEAT_NAME) then return false end
	local model = seat:FindFirstAncestorOfClass("Model")
	return model and model:GetAttribute("IsHorse") == true or false
end

local function flat(vec: Vector3): Vector3
	local f = Vector3.new(vec.X, 0, vec.Z)
	return (f.Magnitude > 1e-3) and f.Unit or Vector3.new(0,0,-1)
end

local function sensorCF(): CFrame
	local char = player.Character
	if not (char and char.Parent) then return CFrame.new() end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return CFrame.new() end
	local cam = workspace.CurrentCamera
	local look = cam and cam.CFrame.LookVector or hrp.CFrame.LookVector
	local pos  = hrp.Position
	return CFrame.lookAt(pos, pos + flat(look), Vector3.yAxis)
end

-- === Controls ===
local function bindControls()
	dprint("Bind controls (W/Space/Q/R)")

	CAS:BindAction("Horse_Forward", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Sink end
		if state == Enum.UserInputState.Begin then
			if not forwardDown then
				forwardDown = true
				RE_Move:FireServer(mountedHorse, true)
			end
		elseif state == Enum.UserInputState.End then
			if forwardDown then
				forwardDown = false
				RE_Move:FireServer(mountedHorse, false)
			end
		end
		return Enum.ContextActionResult.Sink
	end, false, Enum.KeyCode.W)

	CAS:BindAction("Horse_Jump", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Sink end
		if state == Enum.UserInputState.Begin then
			RE_Jump:FireServer()
		end
		return Enum.ContextActionResult.Sink
	end, false, Enum.KeyCode.Space)

	-- IMPORTANT: Use BindActionAtPriority so we PREEMPT your normal Q-dodge while mounted.
	CAS:BindActionAtPriority("Horse_Gallop_Q", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Pass end
		if state == Enum.UserInputState.Begin then
			RE_Gallop:FireServer()
		end
		return Enum.ContextActionResult.Sink -- swallow so your dodge handler never sees Q while mounted
	end, false, PRIORITY, GALLOP_KEY)

	CAS:BindAction("Horse_Dismount", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Sink end
		if state == Enum.UserInputState.Begin then
			RE_Dismount:FireServer()
		end
		return Enum.ContextActionResult.Sink
	end, false, Enum.KeyCode.R)
end

local function unbindControls()
	dprint("Unbind controls")
	CAS:UnbindAction("Horse_Forward")
	CAS:UnbindAction("Horse_Jump")
	CAS:UnbindAction("Horse_Gallop_Q")
	CAS:UnbindAction("Horse_Dismount")
	forwardDown = false
end

-- Stream facing every frame while mounted
local function startFaceStream()
	if faceConn then return end
	faceConn = RunService.RenderStepped:Connect(function()
		if mountedHorse then
			RE_Face:FireServer(mountedHorse, sensorCF())
		end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\client\StarterPlayerScripts\InputHandler.client.lua -----
-- InputHandler (LocalScript) — mount-aware, ROOT-FIX version
-- Teardown actions (e.g., BlockEnd) always pass, even if mounted/stunned/locked.

local Players            = game:GetService("Players")
local UserInputService   = game:GetService("UserInputService")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

local localPlayer        = Players.LocalPlayer
local RemoteFolder       = ReplicatedStorage:WaitForChild("RemoteEvents")

-- === Remotes ===
local ActivateNode       = RemoteFolder:WaitForChild("ActivateNode")
local ConfirmSuccess     = RemoteFolder:WaitForChild("ConfirmSuccess")
local StunToggle         = RemoteFolder:WaitForChild("StunToggle")
local LockMoves          = RemoteFolder:WaitForChild("LockMoves") -- bool

-- === Game state ===
local CombatState        = require(ReplicatedStorage:WaitForChild("CombatState"))

-- === Debug ===
local DEBUG              = false
local function DebugLog(...) if DEBUG then print("[InputHandler]", ...) end end

-- === State ===
local isStunned          = false
local MOVES_LOCKED       = false
local holdingBlock       = false

-- === Teardown that must always pass ===
local ALWAYS_ALLOW_TEARDOWN = {
	BlockEnd = true,
}

-- === Flags from server ===
StunToggle.OnClientEvent:Connect(function(flag)
	isStunned = flag and true or false
	DebugLog("Stun ->", isStunned)
end)

LockMoves.OnClientEvent:Connect(function(locked)
	MOVES_LOCKED = locked and true or false
	DebugLog("LockMoves ->", MOVES_LOCKED)
	-- Do NOT clear holdingBlock here; we will always send BlockEnd on key-up.
end)

-- === Cooldowns ===
local cooldowns = {}
local pendingCooldowns = {}

local function offCooldown(action)
	return (cooldowns[action] or 0) < tick()
end

ConfirmSuccess.OnClientEvent:Connect(function(actionName)
	local pending = pendingCooldowns[actionName]
	if pending then
		cooldowns[actionName] = tick() + pending.time
		pendingCooldowns[actionName] = nil
	end
end)

-- === Gate (teardown bypass) ===
local function canAct(actionName)
	if actionName and ALWAYS_ALLOW_TEARDOWN[actionName] then
		return true, "teardown"
	end
	if MOVES_LOCKED then return false, "mounted" end
	if isStunned   then return false, "stunned" end
	if CombatState.IsLocked(localPlayer) then return false, "combat-locked" end
	return true
end

-- === Fire helper ===
local function triggerAction(actionName, cooldownTime, extraData, bypassCooldown)
	local ok, why = canAct(actionName)
	if not ok then
		DebugLog(("BLOCKED %s (reason: %s)"):format(actionName, why))
		return
	end
	if bypassCooldown or offCooldown(actionName) then
		DebugLog("📤 Fire:", actionName, "extra:", extraData)
		ActivateNode:FireServer(actionName, extraData)
		if cooldownTime and cooldownTime > 0 then
			pendingCooldowns[actionName] = { time = cooldownTime, issuedAt = tick() }
		end
	else
		DebugLog(("On cooldown: %s (%.2fs left)"):format(
			actionName, math.max(0, (cooldowns[actionName] or 0) - tick())
			))
	end
end

-- === INPUTS ===
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	-- Normal actions respect gates
	local ok = canAct()
	if not ok then
		DebugLog("InputBegan swallowed due to state gate")
		return
	end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		triggerAction("Punch", 0.5)

	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		triggerAction("Heavy", 2.0)

	elseif input.KeyCode == Enum.KeyCode.F then
		-- Try to start block; if state-gated, no harm—server will ignore.
		if not holdingBlock and offCooldown("Block") then
			holdingBlock = true
			triggerAction("BlockStart")
		end

	elseif input.KeyCode == Enum.KeyCode.Q then
		triggerAction("Dodge", 1.0)
	end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\client\StarterPlayerScripts\LocalScript.client.lua -----
-- StarterPlayerScripts/SummonHorseKey.client.lua
-- Press H to toggle SummonHorse (always available; server enforces unlock/cooldown).

local UIS = game:GetService("UserInputService")
local RS  = game:GetService("ReplicatedStorage")

local Remotes      = RS:WaitForChild("RemoteEvents")
local ActivateNode = Remotes:WaitForChild("ActivateNode")

local SUMMON_KEY = Enum.KeyCode.H

UIS.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == SUMMON_KEY then
		local cam = workspace.CurrentCamera
		local dir = cam and cam.CFrame.LookVector or Vector3.new(0,0,-1)
		ActivateNode:FireServer("SummonHorse", dir)
	end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\00_MounterFirewall.server.lua -----
-- 00_MountedFirewall.server.lua
-- Global, future-proof block for actions while mounted.
-- Patches NodeFactory.Create and DamageService.DealDamage at runtime.
-- Hardened to accept attacker as Player/Model/Humanoid/BasePart or table context.

local RS      = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- ===== CONFIG =====
local DEBUG = false
local function dprint(...) if DEBUG then print("[MountedFirewall]", ...) end end

-- Nodes allowed while mounted (e.g., emotes)
local ALLOW_WHILE_MOUNTED: {[string]: boolean} = {
	-- ["WaveEmote"] = true,
}

-- ---------- Helpers ----------
local function characterFromInstance(inst: Instance?)
	if not inst then return nil end
	if inst:IsA("Model") then return inst end
	if inst:IsA("Humanoid") then return inst.Parent end
	if inst:IsA("BasePart") then return inst:FindFirstAncestorOfClass("Model") end
	return nil
end

local function playerFromAnything(x): Player?
	if typeof(x) == "Instance" then
		if x:IsA("Player") then return x end
		local char = characterFromInstance(x)
		if char then return Players:GetPlayerFromCharacter(char) end
	elseif typeof(x) == "table" then
		-- Common table fields we might see from services
		local pCands = { x.player, x.Player, x.AttackerPlayer, x.Owner, x.SourcePlayer, x.Source }
		for _, p in ipairs(pCands) do
			if typeof(p) == "Instance" and p:IsA("Player") then return p end
		end
		local cCands = { x.Character, x.char, x.AttackerChar, x.AttackerCharacter, x.SourceCharacter, x.SourceChar, x.CharacterModel, x.Model, x.RootPart }
		for _, c in ipairs(cCands) do
			if typeof(c) == "Instance" then
				if c:IsA("Player") then return c end
				local char = characterFromInstance(c) or (c:IsA("Model") and c or nil)
				if char then
					local plr = Players:GetPlayerFromCharacter(char)
					if plr then return plr end
				end
			end
		end
	end
	return nil
end

local function characterFromAnything(x): Model?
	if typeof(x) == "Instance" then
		return characterFromInstance(x)
	elseif typeof(x) == "table" then
		local cCands = { x.Character, x.char, x.AttackerChar, x.AttackerCharacter, x.SourceCharacter, x.SourceChar, x.CharacterModel, x.Model, x.RootPart }
		for _, c in ipairs(cCands) do
			if typeof(c) == "Instance" then
				local ch = characterFromInstance(c) or (c:IsA("Model") and c or nil)
				if ch then return ch end
			end
		end
	end
	return nil
end

local function isMountedPlayer(plr: Player?): boolean
	if not plr then return false end
	local hum = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

local function isMountedAnything(x): boolean
	local plr = playerFromAnything(x)
	if plr then return isMountedPlayer(plr) end
	local char = characterFromAnything(x)
	if not char then return false end
	local hum = char:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

-- ---------- Patch NodeFactory.Create (guards every node function) ----------
local NodeFactory = require(RS:WaitForChild("NodeFactory"))

do
	local __wrappedCache = setmetatable({}, { __mode = "k" })
	local __fnCache      = setmetatable({}, { __mode = "k" })

	local function guardFunc(nodeTbl, key, fn)
		local nodeFns = __fnCache[nodeTbl]; if not nodeFns then nodeFns = {}; __fnCache[nodeTbl] = nodeFns end
		if nodeFns[key] then return nodeFns[key] end

		local wrapped = function(...)
			-- Resolve caller from either form:
			--   node.OnStart(player, dir) OR node.Execute(player, dir)
			--   node:Execute(rootPart, extra)
			local a1, a2 = ...
			local plr = playerFromAnything(a1) or playerFromAnything(a2)
			local name = tostring(nodeTbl.Name or key or "?")
			local allowed = ALLOW_WHILE_MOUNTED[name] or nodeTbl.AllowWhileMounted

			if plr and (not allowed) and isMountedPlayer(plr) then
				dprint(("BLOCK node=%s fn=%s while mounted"):format(name, key))
				return
			end
			return fn(...)
		end
		nodeFns[key] = wrapped
		return wrapped
	end

	local function wrapNode(nodeTbl)
		if type(nodeTbl) ~= "table" then return nodeTbl end
		if __wrappedCache[nodeTbl] then return __wrappedCache[nodeTbl] end

		local proxy = setmetatable({}, {
			__index = function(_, k)
				local v = nodeTbl[k]
				if type(v) == "function" then

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\ActivateNodeRouter.server.lua -----
-- ActivateNodeRouter.server.lua
-- Forwards ActivateNode to node module; passes camera dir + camera right
local RS = game:GetService("ReplicatedStorage")
local Remotes = RS:WaitForChild("RemoteEvents")
local ActivateNode = Remotes:WaitForChild("ActivateNode")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local okNM, NodeManager = pcall(function() return require(RS:WaitForChild("NodeManager")) end)

local function sanitizeDir(v)
	if typeof(v) ~= "Vector3" or v.Magnitude <= 0 then return nil end
	return v.Unit
end

local function orthoRight(dir, rightGuess)
	-- try provided right; make it orthogonal to dir
	if typeof(rightGuess) == "Vector3" and rightGuess.Magnitude > 0 then
		local r = (rightGuess - dir * rightGuess:Dot(dir))
		if r.Magnitude > 1e-4 then return r.Unit end
	end
	-- fallback from dir and world up
	local up = Vector3.yAxis
	local r = up:Cross(dir) -- screen-style right given look and up
	if r.Magnitude < 1e-4 then
		r = dir:Cross(up)
	end
	return r.Magnitude > 0 and r.Unit or Vector3.xAxis
end

ActivateNode.OnServerEvent:Connect(function(player, nodeName, dirVec, camRight)
	if type(nodeName) ~= "string" or nodeName == "" or #nodeName > 40 then return end
	if not PlayerDataService.HasUnlock(player, nodeName) then return end

	local dir = sanitizeDir(dirVec)
	local right = dir and orthoRight(dir, camRight) or nil

	-- Prefer NodeManager if it exposes Activate(player, nodeName, dir, right)
	if okNM and NodeManager and typeof(NodeManager.Activate) == "function" then
		local ok, err = pcall(function() NodeManager.Activate(player, nodeName, dir, right) end)
		if not ok then warn("[ActivateNodeRouter] NodeManager.Activate error:", err) end
		return
	end

	-- Fallback: require module and call OnStart(player, dir, right)
	local folder = RS:FindFirstChild("NodeModules")
	local mod = folder and folder:FindFirstChild(nodeName)
	if not (mod and mod:IsA("ModuleScript")) then return end

	local ok, nodeMod = pcall(require, mod)
	if not ok then warn("[ActivateNodeRouter] require failed:", nodeMod) return end
	if type(nodeMod) == "table" and type(nodeMod.OnStart) == "function" then
		local ok2, err2 = pcall(nodeMod.OnStart, player, dir, right)
		if not ok2 then warn("[ActivateNodeRouter] OnStart error:", err2) end
	end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\CollisionGroups.server.lua -----
-- ServerScriptService/CollisionGroups.server.lua
-- Disable collisions between player characters and enemy NPC rigs
-- using the modern CollisionGroups API.

local Players        = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService")

local GROUP_PLAYER = "Players"
local GROUP_ENEMY  = "Enemies"

-- Create/register groups (idempotent)
pcall(function() PhysicsService:RegisterCollisionGroup(GROUP_PLAYER) end)
pcall(function() PhysicsService:RegisterCollisionGroup(GROUP_ENEMY)  end)

-- Players <-> Enemies: do NOT collide
PhysicsService:CollisionGroupSetCollidable(GROUP_PLAYER, GROUP_ENEMY, false)

-- Helper: apply a collision group to all BaseParts in a model and keep it updated
local function watchModelCollisionGroup(model: Model, groupName: string)
	-- initial pass
	for _, inst in ipairs(model:GetDescendants()) do
		if inst:IsA("BasePart") then
			inst.CollisionGroup = groupName
		end
	end
	-- keep future parts in sync (accessories, cloned tools, etc.)
	model.DescendantAdded:Connect(function(inst)
		if inst:IsA("BasePart") then
			inst.CollisionGroup = groupName
		end
	end)
end

-- Treat any Model with IsEnemy=true as an enemy
local function isEnemyModel(m: Instance)
	return m:IsA("Model") and m:GetAttribute("IsEnemy") == true
end

-- Players -> GROUP_PLAYER
local function hookPlayer(plr: Player)
	local function onChar(char: Model)
		watchModelCollisionGroup(char, GROUP_PLAYER)
	end
	if plr.Character then onChar(plr.Character) end
	plr.CharacterAdded:Connect(onChar)
end

Players.PlayerAdded:Connect(hookPlayer)
for _, plr in ipairs(Players:GetPlayers()) do
	hookPlayer(plr)
end

-- Enemies -> GROUP_ENEMY
-- Apply immediately for existing enemies
for _, inst in ipairs(workspace:GetDescendants()) do
	if isEnemyModel(inst) then
		watchModelCollisionGroup(inst, GROUP_ENEMY)
	end
end

-- Watch for new enemy models or models that flip IsEnemy later
workspace.DescendantAdded:Connect(function(inst)
	if inst:IsA("Model") then
		-- If attribute appears/changes later
		inst:GetAttributeChangedSignal("IsEnemy"):Connect(function()
			if inst:GetAttribute("IsEnemy") == true then
				watchModelCollisionGroup(inst, GROUP_ENEMY)
			end
		end)
		-- If already tagged
		if isEnemyModel(inst) then
			watchModelCollisionGroup(inst, GROUP_ENEMY)
		end
	end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\EnemyBootstrap.server.lua -----
-- ServerScriptService/EnemyBootstrap.server.lua
local RS       = game:GetService("ReplicatedStorage")
local Looks    = require(RS:WaitForChild("EnemyLooks"))
local Specs    = require(RS:WaitForChild("EnemySpecs"))
local RigKit   = require(RS:WaitForChild("RigMadLibs"))

local ENEMY_ROOT = workspace:FindFirstChild("Enemies") or workspace

-- ===== AI module resolve (EnemyController preferred; fallback Controller) ===
local function resolveAIModule()
	local aiFolder = RS:WaitForChild("AI")
	local mod = aiFolder:FindFirstChild("EnemyController") or aiFolder:FindFirstChild("Controller")
	if not mod then
		warn("[EnemyBootstrap] No AI module found under ReplicatedStorage/AI (expected 'EnemyController' or 'Controller').")
		return nil
	end
	local ok, ctrl = pcall(require, mod)
	if not ok then
		warn("[EnemyBootstrap] Failed to require AI module:", ctrl)
		return nil
	end
	if type(ctrl) ~= "table" or type(ctrl.Start) ~= "function" then
		warn("[EnemyBootstrap] AI module does not return a table with Start(self, spec).")
		return nil
	end
	return ctrl
end

local Controller = resolveAIModule()

-- ===== Looks helpers ========================================================
local function firstLook(key)
	local t = Looks[key]
	return (t and #t > 0) and t[1] or nil
end

local function applyLook(model: Model, spec: table, overrideSkinKey: string?)
	if model:GetAttribute("Skinned") then return end

	local entry
	if overrideSkinKey and overrideSkinKey ~= "" then
		entry = firstLook(overrideSkinKey)
	elseif spec and spec.skinKey then
		entry = firstLook(spec.skinKey)
	elseif spec and spec.skin then
		entry = spec.skin -- inline recipe: { userId=.. | outfitId=.. | assets={..} }
	end
	if not entry then return end

	if entry.userId then
		RigKit.applyUserLook(model, entry.userId)
	elseif entry.outfitId then
		RigKit.applyOutfit(model, entry.outfitId)
	elseif entry.assets then
		RigKit.applyAssets(model, entry.assets)
	end

	model:SetAttribute("Skinned", true)
end

-- ===== Binder ===============================================================
local function bind(model: Model)
	if model:GetAttribute("Bound") then return end
	if not model:GetAttribute("IsEnemy") then return end

	local hum = model:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	local enemyId = model:GetAttribute("enemyId")
	if not enemyId or enemyId == "" then enemyId = model.Name end

	local spec = Specs[enemyId]
	if not spec then
		warn(("[EnemyBootstrap] Unknown enemyId '%s' on '%s'"):format(enemyId, model:GetFullName()))
		return
	end

	-- Appearance
	applyLook(model, spec, model:GetAttribute("SkinKey"))

	-- Defaults / labels
	model:SetAttribute("enemyType", spec.enemyType or "Unknown")
	model:SetAttribute("AIProfile", spec.aiProfile or "")
	if spec.leashRadius and model:GetAttribute("LeashRadius") == nil then
		model:SetAttribute("LeashRadius", spec.leashRadius)
	end
	if spec.DEF ~= nil then model:SetAttribute("DEF", spec.DEF) end
	if spec.OFF ~= nil then model:SetAttribute("OFF", spec.OFF) end

	-- Stats
	if spec.stats then
		if spec.stats.WalkSpeed then hum.WalkSpeed = spec.stats.WalkSpeed end
		if spec.stats.JumpPower then hum.JumpPower = spec.stats.JumpPower end
	end

	-- Start controller (only if we actually resolved it)
	if Controller then
		local ok, err = pcall(function()
			Controller.Start(model, spec)
		end)
		if not ok then
			warn("[EnemyBootstrap] Controller.Start failed:", err)
		end
	else
		warn("[EnemyBootstrap] No Controller available; enemy will not act.")
	end

	model:SetAttribute("Bound", true)
end

-- ===== Initial sweep + live binding ========================================
for _, m in ipairs(ENEMY_ROOT:GetDescendants()) do
	if m:IsA("Model") then bind(m) end
end

ENEMY_ROOT.DescendantAdded:Connect(function(inst)
	if inst:IsA("Model") then bind(inst) end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\EnemySpawner.server.lua -----
-- ServerScriptService/EnemySpawner.server.lua  ✅ clean, self-contained
local ServerStorage = game:GetService("ServerStorage")

local ENEMY_PREFABS = ServerStorage:WaitForChild("Enemies")
local LEASHES       = workspace:FindFirstChild("EnemyLeashes")  -- folder of pads

local function ensureEnemiesFolder()
	local f = workspace:FindFirstChild("Enemies")
	if not f then
		f = Instance.new("Folder")
		f.Name = "Enemies"
		f.Parent = workspace
	end
	return f
end

local ENEMY_ROOT = ensureEnemiesFolder()

local function topCenterCF(p: BasePart)
	return p.CFrame * CFrame.new(0, p.Size.Y/2 + 3, 0)
end

local function spawnFromFolder(folder: Instance, prefabName: string): Model?
	local src = folder:FindFirstChild(prefabName)
	return (src and src:Clone()) or nil
end

local function pivotAndFace(rig: Model, cf: CFrame)
	if not rig.PrimaryPart then
		local hrp = rig:FindFirstChild("HumanoidRootPart")
		if hrp then rig.PrimaryPart = hrp end
	end
	rig:PivotTo(cf)
end

local function spawnEnemyAt(leash: BasePart, offset: CFrame?)
	local prefabName = leash:GetAttribute("Prefab")
	if not prefabName or prefabName == "" then
		warn("[EnemySpawner] Leash missing Prefab:", leash:GetFullName())
		return nil
	end

	local rig = spawnFromFolder(ENEMY_PREFABS, prefabName)
	if not rig then
		warn("[EnemySpawner] Enemy prefab not found:", prefabName)
		return nil
	end

	rig.Name   = prefabName
	rig.Parent = ENEMY_ROOT
	pivotAndFace(rig, topCenterCF(leash) * (offset or CFrame.new()))

	-- Identity & behavior (enemyId is your “enemy storyId”)
	local enemyId = leash:GetAttribute("EnemyId") or prefabName
	rig:SetAttribute("IsEnemy", true)
	rig:SetAttribute("enemyId", enemyId)

	-- Optional overrides
	local skinKey = leash:GetAttribute("SkinKey")
	if skinKey and skinKey ~= "" then rig:SetAttribute("SkinKey", skinKey) end

	rig:SetAttribute("LeashRadius", leash:GetAttribute("LeashRadius") or 30)
	rig:SetAttribute("ArenaId",     leash:GetAttribute("ArenaId") or "")

	-- Pointer back to the leash
	local leashRef = Instance.new("ObjectValue")
	leashRef.Name  = "LeashPoint"
	leashRef.Value = leash
	leashRef.Parent = rig

	-- Respawn (default true)
	local respawn = leash:GetAttribute("Respawn")
	if respawn == nil then respawn = true end
	if respawn then
		local hum = rig:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Died:Connect(function()
				local t = leash:GetAttribute("RespawnTime") or 10
				task.delay(t, function()
					if leash.Parent then spawnEnemyAt(leash) end
				end)
			end)
		end
	end

	print(("[EnemySpawner] ✅ Spawned %s at %s (enemyId=%s)")
		:format(prefabName, leash.Name, enemyId))
	return rig
end

-- ===== Boot =====
if not LEASHES then
	warn("[EnemySpawner] No 'EnemyLeashes' folder found in Workspace. Create one and add pads with attributes.")
	return
end

for _, leash in ipairs(LEASHES:GetChildren()) do
	if leash:IsA("BasePart") then
		local count = tonumber(leash:GetAttribute("Count")) or 1
		for i = 1, count do
			local angle = (i-1) * (math.pi * 2 / math.max(1, count))
			local off = CFrame.new(math.cos(angle) * 2, 0, math.sin(angle) * 2)
			spawnEnemyAt(leash, off)
		end
	end
end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\GameInit.server.lua -----
-- GameInit.lua (ServerScriptService)
-- Creates remotes and wires load/unload hooks

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local NodeManager       = require(game:GetService("ReplicatedStorage"):WaitForChild("NodeManager"))

-- Remote bootstrap -----------------------------------------------------------
local function ensureRemote(folder, name)
	local ev = folder:FindFirstChild(name)
	if not ev then ev = Instance.new("RemoteEvent"); ev.Name = name; ev.Parent = folder end
	return ev
end

local remotes = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
remotes.Name = "RemoteEvents"
remotes.Parent = ReplicatedStorage

ensureRemote(remotes, "ActivateNode")   -- client -> server (fire a node)
ensureRemote(remotes, "UnlockNode")     -- client -> server (unlock a node)
ensureRemote(remotes, "NodeActions")    -- client -> server (menus, etc.)
ensureRemote(remotes, "ConfirmSuccess") -- server -> client (toast)
ensureRemote(remotes, "CooldownNotice") -- server -> client (cooldown UI)
ensureRemote(remotes, "DodgeCharges")   -- server -> client (dodge UI)
-- Dialogue/Story remotes
ensureRemote(remotes, "UnlockStory")
ensureRemote(remotes, "BeginDialogue")
ensureRemote(remotes, "ChooseOption")
ensureRemote(remotes, "DialogueUpdate")

-- RemoteFunction helper
local function ensureRemoteFunction(folder, name)
	local rf = folder:FindFirstChild(name)
	if not rf then rf = Instance.new("RemoteFunction"); rf.Name = name; rf.Parent = folder end
	return rf
end
ensureRemoteFunction(remotes, "GetStoryUnlocks")

-- Ensure folders exist
local storyAllow = ReplicatedStorage:FindFirstChild("StoryUnlockables") or Instance.new("Folder")
storyAllow.Name = "StoryUnlockables"; storyAllow.Parent = ReplicatedStorage
local stories = ReplicatedStorage:FindFirstChild("Stories") or Instance.new("Folder")
stories.Name = "Stories"; stories.Parent = ReplicatedStorage


-- Player lifecycle -----------------------------------------------------------
Players.PlayerAdded:Connect(function(player)
	local profile = PlayerDataService.WaitForProfile(player, 10)
	if not profile then
		warn("[GameInit] Profile failed to load for", player.Name)
		return
	end
	NodeManager.LoadUnlocked(player, profile)
end)

Players.PlayerRemoving:Connect(function(player)
	NodeManager.Unload(player)
end)

-- Boot story systems
require(script.Parent:WaitForChild("StoryDataService"))
require(script.Parent:WaitForChild("StoryUnlockHandler"))
require(script.Parent:WaitForChild("StoryDialogueHandler"))
require(script.Parent:WaitForChild("StoryUnlockables")) -- or StoryList if you switch to auto-discovery


-- ServerScriptService/DiagProbe.server.lua  (TEMP)
local RS = game:GetService("ReplicatedStorage")
local RE = RS:WaitForChild("RemoteEvents")
local Begin = RE:WaitForChild("BeginDialogue")
local Update = RE:WaitForChild("DialogueUpdate")


-- after ensureRemote(...) lines
local s = script.Parent
require(s:WaitForChild("StoryDataService"))
require(s:WaitForChild("StoryUnlockHandler"))
require(s:WaitForChild("StoryDialogueHandler"))  -- must exist, ModuleScript, returns a value

-- Keybind remotes
ensureRemote(remotes, "ActivateNode") -- you already have this
local function ensureRemoteFunction(folder, name)
	local rf = folder:FindFirstChild(name)
	if not rf then rf = Instance.new("RemoteFunction"); rf.Name = name; rf.Parent = folder end
	return rf
end
ensureRemoteFunction(remotes, "GetKeybinds")      -- client <-> server
ensureRemoteFunction(remotes, "SetKeybind")       -- client <-> server
ensureRemoteFunction(remotes, "GetUnlockedNodes") -- client <-> server
require(script.Parent:WaitForChild("KeybindHandler"))



----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\GuardBreakEnforcer.server.lua -----
-- ServerScriptService/GuardBreakEnforcer.server.lua
-- Robust guard-break enforcement + anti-hold-F reblock during rearm.

local Players           = game:GetService("Players")
local RS                = game:GetService("ReplicatedStorage")

local NodeSense         = require(RS:WaitForChild("NodeSense"))
local CombatState       = require(RS:WaitForChild("CombatState"))
local DamageService     = require(RS:WaitForChild("DamageService"))
local StunService       = require(RS:WaitForChild("StunService"))
local CooldownService   = require(RS:WaitForChild("CooldownService"))
local SpeedController   = require(RS:WaitForChild("SpeedController"))
local GuardService      = require(RS:WaitForChild("GuardService"))

local GUARD_BREAK_STUN  = 0.45   -- hard-stun on break
local GUARD_BREAK_REARM = 1.10   -- cannot re-block during this window
local BASE_WALK         = 16     -- fallback for NPC models

local function asModel(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model") then return ent end
	return nil
end

local function asPlayer(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent end
	return Players:GetPlayerFromCharacter(ent)
end

local function humOf(ent)
	local m = asModel(ent)
	return m and m:FindFirstChildOfClass("Humanoid") or nil
end

-- Resolve the defender for a GuardBroken outcome, regardless of nodeName
local function resolveDefender(payload)
	-- Case A: guard events emitted from "Block" use the defender as actor
	if tostring(payload.nodeName) == "Block" then
		return payload.actorPlayer or payload.actorModel
	end

	-- Case B: emitted from the attacker node, target is in context.targetId
	local ctx = payload.context or {}
	if ctx.targetId then
		local plr = Players:GetPlayerByUserId(ctx.targetId)
		if plr then return plr end
	end

	-- Fallback: nearest blocking humanoid to the attacker (best-effort)
	local attackerModel = payload.actorModel
	local attackerHRP   = attackerModel and attackerModel:FindFirstChild("HumanoidRootPart")
	if not attackerHRP then return nil end

	local nearest, nd = nil, 10
	for _, plr in ipairs(Players:GetPlayers()) do
		local ch = plr.Character
		local hum = ch and ch:FindFirstChildOfClass("Humanoid")
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hum and hrp and hum.Health > 0 then
			local d = (hrp.Position - attackerHRP.Position).Magnitude
			if d < nd and GuardService.IsBlocking(plr) then
				nearest, nd = plr, d
			end
		end
	end
	return nearest
end

local function forceUnblock(target)
	-- 1) End block + unlock + stop hold anim/track
	pcall(DamageService.EndBlock, target)
	pcall(CombatState.StopCurrentTrack, target)
	pcall(CombatState.Unlock, target, "GuardBroken")

	-- 2) Clear any block slow / restore speed
	local plr = asPlayer(target)
	if plr then
		pcall(SpeedController.Reset, plr)
	else
		local hum = humOf(target)
		if hum then hum.WalkSpeed = BASE_WALK end
	end

	-- 3) Brief hard-stun to sell the break
	pcall(StunService.Apply, target, GUARD_BREAK_STUN, { hard = true })

	-- 4) Re-arm cooldown so holding F can’t instantly re-block
	pcall(CooldownService.Apply, target, "BlockRearm", GUARD_BREAK_REARM)
end

-- If the player tries to BlockStart while BlockRearm is active, cancel it immediately.
local function cancelIllegalBlockStart(actor)
	if not actor then return end
	-- If they cannot use BlockRearm yet, they are still in rearm window.
	if not CooldownService.CanUse(actor, "BlockRearm") then
		-- Immediately force them out of block (prevents “hold F” exploit)
		forceUnblock(actor)
	end
end

-- Subscribe to NodeSense
if NodeSense.ServerEvent then
	NodeSense.ServerEvent.Event:Connect(function(payload)
		if not payload or not payload.context then return end
		local outcome = payload.context.outcome

		-- Enforce on GuardBroken from ANY node
		if outcome == "GuardBroken" then
			local defender = resolveDefender(payload)
			if defender then
				forceUnblock(defender)
			else
				warn("[GuardBreakEnforcer] GuardBroken without resolvable defender for node=", payload.nodeName)
			end
			return
		end

		-- Stop illegal re-block attempts during rearm

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\HorseMountServer.server.lua -----
-- ServerScriptService/HorseMountServer.lua
-- W = throttle, Space = jump, Q (client) = gallop (spends DodgeCharge), R = dismount.

-- ========= Animation IDs =========
local WALK_ANIM_ID   = "rbxassetid://81146949344342"
local JUMP_ANIM_ID   = "rbxassetid://98771585060096"
local GALLOP_ANIM_ID = "rbxassetid://83469750908764" -- loop during gallop

-- ========= Services / Deps =========
local Players     = game:GetService("Players")
local RS          = game:GetService("ReplicatedStorage")
local Workspace   = game:GetService("Workspace")
local RunService  = game:GetService("RunService")

local CombatState       = require(RS:WaitForChild("CombatState"))
local DodgeCharges      = require(RS:WaitForChild("DodgeChargeService"))
local PlayerDataService = require(game:GetService("ServerScriptService"):WaitForChild("PlayerDataService"))

-- ========= Remotes (auto-created) =========
local Remotes = RS:FindFirstChild("RemoteEvents") or Instance.new("Folder", RS)
Remotes.Name = "RemoteEvents"

local function ensureRemote(name)
	local r = Remotes:FindFirstChild(name)
	if not r then r = Instance.new("RemoteEvent"); r.Name = name; r.Parent = Remotes end
	return r
end

local RE_Face      = ensureRemote("Horse_Face")
local RE_Move      = ensureRemote("Horse_Move")
local RE_Jump      = ensureRemote("Horse_Jump")
local RE_Dismount  = ensureRemote("Horse_RequestDismount")
local RE_LockMoves = ensureRemote("LockMoves")
local RE_Gallop    = ensureRemote("Horse_Gallop")
local ConfirmSuccess = ensureRemote("ConfirmSuccess") -- ensure it's present for toasts

-- ========= Defaults (per-horse Attributes can override) =========
local SEAT_NAME               = "SaddleSeat"
local DEFAULT_SPEED           = 32
local DEFAULT_JUMP_POWER      = 30
local DEFAULT_JUMP_IMPULSE    = 60
local DEFAULT_JUMP_COOLDOWN   = 1.0

local REQUIRE_GROUND_TO_JUMP  = true
local DEFAULT_SURFACE_YAW_DEG = -90
local DEFAULT_FORWARD_BASIS   = "Left"
local DEFAULT_GROUND_RAY      = 12

local DEFAULT_FRICTION_K      = 2.5
local FRICTION_BOOST_VALUE    = 1.25

-- Gallop
local DEFAULT_GALLOP_MULT     = 2.0   -- BaseSpeed * mult
local DEFAULT_GALLOP_DURATION = 1.5   -- seconds per charge

-- Display
local PLAYER_HORSE_NAME       = "Get That Call"

-- mounts[player] = {...}
local mounts = {}

-- ========= Logging =========
local DEBUG = true
local function slog(st, ...) if (st and st.debug) or DEBUG then print("[HORSE]", ...) end end
local function swarn(st, ...) if (st and st.debug) or DEBUG then warn("[HORSE]", ...) end end

-- ========= Helpers =========
local function findHorseFromSeat(seat: Instance)
	if not (seat and seat:IsA("Seat") and seat.Name == SEAT_NAME) then return nil end
	local m = seat:FindFirstAncestorOfClass("Model")
	if m and m:GetAttribute("IsHorse") then return m end
	return nil
end

local function ensureHumanoid(horse: Model)
	local hum = horse:FindFirstChildOfClass("Humanoid")
	if not hum then hum = Instance.new("Humanoid", horse) end
	hum.AutoRotate   = false
	hum.UseJumpPower = true
	hum.WalkSpeed    = horse:GetAttribute("BaseSpeed") or DEFAULT_SPEED
	hum.JumpPower    = horse:GetAttribute("HorseJumpPower") or DEFAULT_JUMP_POWER
	return hum
end

local function buildFacingConstraint(horse: Model)
	local root = horse.PrimaryPart or horse:FindFirstChild("HumanoidRootPart")
	if not (root and root:IsA("BasePart")) then return end

	local att0 = root:FindFirstChild("_HorseA0")
	if not att0 then
		att0 = Instance.new("Attachment")
		att0.Name = "_HorseA0"
		att0.CFrame = CFrame.new()
		att0.Parent = root
	end

	local sensorPart = Instance.new("Part")
	sensorPart.Name = "_HorseSensor"
	sensorPart.Size = Vector3.new(0.2, 0.2, 0.2)
	sensorPart.Transparency = 1
	sensorPart.CanCollide = false
	sensorPart.Anchored = true
	sensorPart.CFrame = root.CFrame
	sensorPart.Parent = Workspace

	local sensorAtt = Instance.new("Attachment")
	sensorAtt.Name = "_HorseA1"
	sensorAtt.Parent = sensorPart

	local ao = Instance.new("AlignOrientation")
	ao.Name = "_HorseFace"
	ao.Attachment0 = att0
	ao.Attachment1 = sensorAtt
	ao.RigidityEnabled = true
	ao.Responsiveness = 200
	pcall(function() ao.MaxTorque = math.huge end)
	ao.Parent = root

	return ao, att0, sensorPart, sensorAtt
end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\HorseMoveBlockServer.server.lua -----

-- Blocks combat/move remotes and tools while the player is mounted

local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")

-- 🔁 CHANGE THESE to match your game’s remotes (add more if you have them):
local REMOTE_NAMES = {
	"ActivateNode",      -- e.g., your combat/ability trigger
	"UseAbility",        -- example
	"CastSkill",         -- example
}

-- === Reject "move" remotes while mounted ===
for _, name in ipairs(REMOTE_NAMES) do
	local re = RS:FindFirstChild("RemoteEvents") and RS.RemoteEvents:FindFirstChild(name)
	if re and re:IsA("RemoteEvent") then
		re.OnServerEvent:Connect(function(player, ...)
			local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
			if hum and hum:GetAttribute("Mounted") then
				-- hard reject
				return
			end
			-- else: let your existing handler run (this script is a guard, not the main logic)
		end)
	end
end

-- === Optional: block Tools while mounted (unequip instantly) ===
local function hookCharacter(player: Player, char: Model)
	local hum = char:WaitForChild("Humanoid")

	-- if player equips a Tool while mounted, instantly unequip it
	hum.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			if hum:GetAttribute("Mounted") then
				hum:UnequipTools()
			end
			-- also guard the Tool’s own Activated
			child.Activated:Connect(function()
				if hum:GetAttribute("Mounted") then
					hum:UnequipTools()
				end
			end)
		end
	end)

	-- also watch Backpack → move to character
	local backpack = player:FindFirstChildOfClass("Backpack")
	if backpack then
		backpack.ChildAdded:Connect(function(tool)
			if tool:IsA("Tool") then
				tool.Activated:Connect(function()
					if hum:GetAttribute("Mounted") then
						hum:UnequipTools()
					end
				end)
			end
		end)
	end
end

Players.PlayerAdded:Connect(function(p)
	p.CharacterAdded:Connect(function(c) hookCharacter(p, c) end)
	if p.Character then hookCharacter(p, p.Character) end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\HorseService.lua -----
-- ServerScriptService/HorseService.lua
-- Robust horse spawner/manager. Finds RS.Horses.Default, parents into Workspace.Horses,
-- tags with attributes, auto-mounts, and logs loudly if anything goes wrong.

local Players   = game:GetService("Players")
local RS        = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local HorseService = {}
local ACTIVE = {} -- [Player] = Model

local DEBUG = true
local HORSES_FOLDER_NAME = "Horses" -- live horses go under Workspace/Horses

local function log(...) if DEBUG then print("[HorseService]", ...) end end

-- Workspace/Horses container (many firewalls whitelist folders)
local function getOrCreateHorsesFolder()
	local f = Workspace:FindFirstChild(HORSES_FOLDER_NAME)
	if not f then
		f = Instance.new("Folder")
		f.Name = HORSES_FOLDER_NAME
		f.Parent = Workspace
		log("Created Workspace." .. HORSES_FOLDER_NAME)
	end
	return f
end

-- Preferred template locations:
-- 1) ReplicatedStorage/Horses/Default
-- 2) ReplicatedStorage/Default
-- 3) ReplicatedStorage/HorseTemplate
-- 4) Any descendant with IsHorseTemplate=true
-- 5) Any descendant named "Default"
local function findTemplate()
	local horses = RS:FindFirstChild("Horses")
	if horses and horses:IsA("Folder") then
		local d = horses:FindFirstChild("Default")
		if d and d:IsA("Model") then log("Using template:", d:GetFullName()); return d end
	end

	do
		local d = RS:FindFirstChild("Default")
		if d and d:IsA("Model") then log("Using template:", d:GetFullName()); return d end
	end

	do
		local t = RS:FindFirstChild("HorseTemplate")
		if t and t:IsA("Model") then log("Using template:", t:GetFullName()); return t end
	end

	for _, m in ipairs(RS:GetDescendants()) do
		if m:IsA("Model") and m:GetAttribute("IsHorseTemplate") == true then
			log("Using attributed template:", m:GetFullName())
			return m
		end
	end

	for _, m in ipairs(RS:GetDescendants()) do
		if m:IsA("Model") and m.Name == "Default" then
			log("Using fallback 'Default':", m:GetFullName())
			return m
		end
	end

	warn("[HorseService] No horse template found. Put a Model at ReplicatedStorage/Horses/Default.")
	return nil
end

local function ensureSeat(m)
	-- Prefer a seat already named SaddleSeat; else rename first Seat found
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("Seat") and d.Name == "SaddleSeat" then return d end
	end
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("Seat") then d.Name = "SaddleSeat"; return d end
	end
	warn("[HorseService] No Seat found; mounting will fail.")
	return nil
end

local function ensureHumanoid(m)
	local hum = m:FindFirstChildOfClass("Humanoid")
	if not hum then hum = Instance.new("Humanoid", m) end
	hum.AutoRotate = false
	hum.UseJumpPower = true
	return hum
end

local function setPrimaryPartIfPossible(m)
	if m.PrimaryPart and m.PrimaryPart:IsA("BasePart") then return m.PrimaryPart end
	local hrp = m:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then m.PrimaryPart = hrp; return hrp end
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("BasePart") then m.PrimaryPart = d; return d end
	end
	return nil
end

function HorseService.GetActive(p)
	local m = ACTIVE[p]
	if m and m.Parent then return m end
	return nil
end

function HorseService.GetHorseName(p)
	local m = HorseService.GetActive(p)
	return (m and (m:GetAttribute("HorseName") or m.Name)) or "Horse"
end

function HorseService.Despawn(p)
	local m = ACTIVE[p]
	ACTIVE[p] = nil
	if m and m.Parent then m:Destroy() end
end

function HorseService.SummonTo(p, cf, autoMount)
	-- Derive a CFrame if not provided
	if not cf then
		local char = p and p.Character

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\KeybindHandler.lua -----
-- KeybindHandler.lua
-- RemoteFunctions to get/set keybinds + list *bindable* (unlockable ∩ owned) nodes only.

local RS = game:GetService("ReplicatedStorage")
local Remotes = RS:WaitForChild("RemoteEvents")

local GetKeybindsRF      = Remotes:WaitForChild("GetKeybinds")
local SetKeybindRF       = Remotes:WaitForChild("SetKeybind")
local GetUnlockedNodesRF = Remotes:WaitForChild("GetUnlockedNodes")

local KeybindService     = require(script.Parent:WaitForChild("KeybindService"))
local PlayerDataService  = require(script.Parent:WaitForChild("PlayerDataService"))

-- live unlockables set
local UNLOCKABLES_SET = {}
local function refreshUnlockables()
	table.clear(UNLOCKABLES_SET)
	local f = RS:FindFirstChild("Unlockables")
	if f then
		for _, sv in ipairs(f:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				UNLOCKABLES_SET[sv.Value] = true
			end
		end
	end
end
refreshUnlockables()
local f = RS:FindFirstChild("Unlockables")
if f then
	f.ChildAdded:Connect(refreshUnlockables)
	f.ChildRemoved:Connect(refreshUnlockables)
end

GetKeybindsRF.OnServerInvoke = function(player)
	return KeybindService.GetAll(player)
end

SetKeybindRF.OnServerInvoke = function(player, payload)
	if typeof(payload) ~= "table" then return { ok=false, msg="Bad payload" } end
	local key  = tostring(payload.key or "")
	local node = payload.node and tostring(payload.node) or ""
	local ok, msg = KeybindService.Set(player, key, node)
	return { ok=ok, msg=msg, binds = KeybindService.GetAll(player) }
end

-- Return ONLY nodes that are unlockable AND the player owns
GetUnlockedNodesRF.OnServerInvoke = function(player)
	local data = PlayerDataService.GetData(player)
	local out = {}
	for _, n in ipairs((data and data.Unlocks) or {}) do
		if UNLOCKABLES_SET[n] then table.insert(out, n) end
	end
	table.sort(out)
	return out
end

return true

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\KeybindService.lua -----
-- KeybindService.lua
-- Persists per-player keybinds (max 5). Keys: 1-0, Z-M.
-- Enforces that only *unlockable* nodes (mirrored in RS/Unlockables) can be bound.

local RS = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))

local ALLOWED_KEYS = {
	One=true, Two=true, Three=true, Four=true, Five=true,
	Six=true, Seven=true, Eight=true, Nine=true, Zero=true,
	Z=true, X=true, C=true, V=true, B=true, N=true, M=true,
}

-- Live cache of unlockable node names (from RS/Unlockables)
local UNLOCKABLES_SET -- [name]=true

local function refreshUnlockables()
	local set = {}
	local folder = RS:FindFirstChild("Unlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				set[sv.Value] = true
			end
		end
	end
	UNLOCKABLES_SET = set
end
refreshUnlockables()
local uFolder = RS:FindFirstChild("Unlockables")
if uFolder then
	uFolder.ChildAdded:Connect(refreshUnlockables)
	uFolder.ChildRemoved:Connect(refreshUnlockables)
end
local function isUnlockable(name) return UNLOCKABLES_SET and UNLOCKABLES_SET[name] or false end

local Busy = setmetatable({}, { __mode = "k" })

local KeybindService = {}

local function ensure(profile)
	local d = profile.Data
	d.Keybinds = d.Keybinds or {} -- map: keyName -> nodeName
end

local function countBinds(map)
	local n = 0
	for _k, v in pairs(map) do if v and v ~= "" then n += 1 end end
	return n
end

function KeybindService.GetAll(player)
	local p = PlayerDataService.GetProfile(player)
	if not p then return {} end
	ensure(p)
	local out = {}
	for k, v in pairs(p.Data.Keybinds) do out[k] = v end
	return out
end

-- set or clear (nodeName == nil/"" to clear)
function KeybindService.Set(player, keyName, nodeName)
	if type(keyName) ~= "string" or keyName == "" or not ALLOWED_KEYS[keyName] then
		return false, "Key not allowed."
	end
	local prof = PlayerDataService.GetProfile(player)
	if not prof then return false, "Profile not ready." end
	ensure(prof)

	-- Clear always allowed
	if not nodeName or nodeName == "" then
		prof.Data.Keybinds[keyName] = nil
		if prof.Save then pcall(function() prof:Save() end) end
		return true, "Unbound."
	end

	-- Only unlockables may be bound (e.g., Revolver), AND you must own it
	if not isUnlockable(nodeName) then
		return false, "Only unlockable moves can be bound."
	end
	if not PlayerDataService.HasUnlock(player, nodeName) then
		return false, "You don't have that unlock yet."
	end

	if Busy[player] then return false, "Busy." end
	Busy[player] = true

	local ok, msg = pcall(function()
		local binds = prof.Data.Keybinds
		local hadBefore = binds[keyName] ~= nil and binds[keyName] ~= ""
		if not hadBefore and countBinds(binds) >= 5 then
			error("You can only have 5 active keybinds.")
		end
		binds[keyName] = nodeName
		if prof.Save then pcall(function() prof:Save() end) end
	end)

	Busy[player] = nil
	if not ok then return false, msg end
	return true, "Saved."
end

return KeybindService

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\NPCBinder.server.lua -----
local RS        = game:GetService("ReplicatedStorage")
local RigKit    = require(RS:WaitForChild("RigMadLibs"))   -- from earlier
local Looks     = require(RS:WaitForChild("EnemyLooks"))

local ROOT = workspace:FindFirstChild("NPCs") or workspace

local function applyLook(model: Model)
	if not model:FindFirstChildOfClass("Humanoid") then return end
	if not model:GetAttribute("IsNPC") then return end
	if model:GetAttribute("Skinned") then return end  -- idempotent

	-- Priority: LookKey > storyId > Name
	local key = model:GetAttribute("LookKey") or model:GetAttribute("storyId") or model.Name
	local options = Looks[key]
	if not options or #options == 0 then return end

	local entry = options[1]  -- or pick by index/random if you want
	if entry.userId   then RigKit.applyUserLook(model, entry.userId)
	elseif entry.outfitId then RigKit.applyOutfit(model, entry.outfitId)
	elseif entry.assets   then RigKit.applyAssets(model, entry.assets) end

	model:SetAttribute("Skinned", true)
end

-- Initial pass + handle NPCs added later
for _, m in ipairs(ROOT:GetDescendants()) do
	if m:IsA("Model") then applyLook(m) end
end

ROOT.DescendantAdded:Connect(function(inst)
	if inst:IsA("Model") then applyLook(inst) end
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\PlayerDataService.lua -----
-- PlayerDataService.lua (ServerScriptService)
-- Single source of truth for player data (ProfileService-backed)
-- Public API: GetProfile, GetData, WaitForProfile, HasUnlock, AddUnlock, RemoveUnlock, Save

local Players             = game:GetService("Players")
local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage   = game:GetService("ReplicatedStorage")

local ProfileService      = require(ServerScriptService:WaitForChild("ProfileService"))

-- Bump only if you intentionally migrate to a new store
local PROFILE_STORE = "PlayerData_v1"

-- ---------- DEFAULTS (IMMUTABLE) ----------	
local DEFAULTS = {
	SchemaVersion = 1,
	Unlocks = { "Punch", "Heavy", "Dodge", "BlockStart", "BlockEnd" },
	-- Future fields: Cash = 0, etc.
}
table.freeze(DEFAULTS)

-- ---------- ALLOWLIST (cached from RS/Unlockables + defaults) ----------
local ALLOWED -- lazy-populated set
local function refreshAllowed()
	local t = {}
	local folder = ReplicatedStorage:FindFirstChild("Unlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and type(sv.Value) == "string" and sv.Value ~= "" then
				t[sv.Value] = true
			end
		end
	end
	for _, def in ipairs(DEFAULTS.Unlocks) do t[def] = true end
	ALLOWED = t
end
local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end
-- live refresh if the folder changes at runtime
local unlockFolder = ReplicatedStorage:FindFirstChild("Unlockables")
if unlockFolder then
	unlockFolder.ChildAdded:Connect(refreshAllowed)
	unlockFolder.ChildRemoved:Connect(refreshAllowed)
end

-- ---------- INTERNALS ----------
local store    = ProfileService.GetProfileStore(PROFILE_STORE, DEFAULTS)
local Profiles = {} -- [player] = live profile object

local function cloneArray(a)
	local out = {}
	for i, v in ipairs(a) do out[i] = v end
	return out
end

local function sanitizeUnlocks(profile)
	local data = profile.Data
	data.Unlocks = data.Unlocks or {}
	local allowed = getAllowed()
	local cleaned, seen, changed = {}, {}, false
	for _, name in ipairs(data.Unlocks) do
		if allowed[name] and not seen[name] then
			seen[name] = true
			table.insert(cleaned, name)
		else
			changed = true -- drop junk/dupe/disallowed
		end
	end
	-- Ensure not empty (prevent soft-lock)
	if #cleaned == 0 then
		cleaned = cloneArray(DEFAULTS.Unlocks)
		changed = true
	end
	if changed then
		data.Unlocks = cleaned
		pcall(function() profile:Save() end)
	end
end

local function onRelease(player)
	Profiles[player] = nil
	if player and player.Parent then
		player:Kick("Your data session was released elsewhere. Please rejoin.")
	end
end

-- ---------- PUBLIC API ----------
local PlayerDataService = {}

function PlayerDataService.GetProfile(player)
	return Profiles[player]
end

function PlayerDataService.GetData(player)
	local p = Profiles[player]
	if not p then return nil end
	-- Return a shallow clone so callers can't mutate the live table
	return table.clone(p.Data)
end

function PlayerDataService.WaitForProfile(player, timeout)
	local t0, to = os.clock(), (timeout or 10)
	while os.clock() - t0 < to do
		local p = Profiles[player]
		if p then return p end
		task.wait()
	end
	return nil
end

function PlayerDataService.HasUnlock(player, nodeName)
	local p = Profiles[player]
	if not p or type(nodeName) ~= "string" or nodeName == "" then return false end
	for _, n in ipairs(p.Data.Unlocks or {}) do
		if n == nodeName then return true end
	end
	return false
end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\ProfileService.lua -----
-- local Madwork = _G.Madwork
--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--	function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])
			
		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()
		
	Members [Profile]:
	
		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\ResetCleaner.server.lua -----
-- ResetCleaner (ServerScriptService)

local Players            = game:GetService("Players")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

local CombatState        = require(ReplicatedStorage:WaitForChild("CombatState"))
local CooldownService    = require(ReplicatedStorage:WaitForChild("CooldownService"))
local SpeedController    = require(ReplicatedStorage:WaitForChild("SpeedController"))
local DamageService      = require(ReplicatedStorage:WaitForChild("DamageService"))
local GuardService       = require(ReplicatedStorage:WaitForChild("GuardService"))
local DodgeChargeService = require(ReplicatedStorage:WaitForChild("DodgeChargeService"))
local AttackStateService = require(ReplicatedStorage:WaitForChild("AttackStateService"))
local IFrameStore        = require(ReplicatedStorage:WaitForChild("IFrameStore"))

Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function()
		-- give Roblox a heartbeat to create Humanoid etc.
		task.wait(0.1)

		-- core combat state
		CombatState.Cleanup(player)
		CooldownService.Clear(player)
		SpeedController.Reset(player)

		-- defense / block systems
		DamageService.EndBlock(player)
		GuardService.EndBlock(player)      -- clears guard flags & regen loop

		-- attack / stamina trackers
		AttackStateService.Clear(player)
		DodgeChargeService.Reset(player)

		-- purge residual i-frames
		IFrameStore.Grant(player, 0)
	end)
end)
local Players     = game:GetService("Players")
local RS          = game:GetService("ReplicatedStorage")
local CombatState = require(RS:WaitForChild("CombatState"))

local function clearLocksFor(p: Player, why: string)
	pcall(function() CombatState.ForceUnlock(p, why) end)
	local hum = p.Character and p.Character:FindFirstChildOfClass("Humanoid")
	if hum then hum:SetAttribute("Mounted", false) end
end

Players.PlayerAdded:Connect(function(p)
	p.CharacterAdded:Connect(function(char)
		-- defer to ensure Humanoid exists
		task.defer(function()
			clearLocksFor(p, "spawn")
		end)
		local hum = char:WaitForChild("Humanoid", 5)
		if hum then
			hum.Died:Connect(function()
				clearLocksFor(p, "death")
			end)
		end
	end)
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\RounderDiagnostics.server.lua -----
-- ServerScriptService/RounderDiagnostics.server.lua
-- Watches a Rounder NPC even if it spawns later. No GetAttribute calls.

local RS          = game:GetService("ReplicatedStorage")
local RunService  = game:GetService("RunService")

local StunService     = require(RS:WaitForChild("StunService"))
local SpeedController = require(RS:WaitForChild("SpeedController"))

-- ───────────────────────────────── helpers
local THIS_SOURCE
do local ok,s=pcall(function() return debug.info(1,"s") end); THIS_SOURCE = ok and s or "" end

local function who()
	for i=3,12 do
		local ok, src = pcall(function() return debug.info(i, "s") end)
		if ok and src and not tostring(src):find("RounderDiagnostics") then
			local ok2, what = pcall(function() return (debug.info(i, "n") or "") end)
			return string.format("%s:%s", tostring(src), tostring(what))
		end
	end
	return "?"
end


local function isHumanoidModel(x)
	return typeof(x) == "Instance" and x:IsA("Model") and x:FindFirstChildOfClass("Humanoid") ~= nil
end

local function looksLikeRounder(m)
	if not isHumanoidModel(m) then return false end
	-- Name checks only (no GetAttribute):
	local n = m.Name:lower()
	if n:find("rounder") then return true end
	-- common child stringValue fallback: enemyId/Id/etc.
	for _, c in ipairs(m:GetChildren()) do
		if c:IsA("StringValue") then
			local v = (c.Value or ""):lower()
			if v:find("rounder") then return true end
		end
	end
	return false
end

local CURRENT    = nil   -- the model we're watching
local HUM        = nil
local baseSpeed  = nil
local conns      = {}
local snapThread = nil
local lastSoftAt, lastHardAt, lastClearAt = 0,0,0

local function disconnectAll()
	for _, cn in ipairs(conns) do pcall(function() cn:Disconnect() end) end
	conns = {}
	if snapThread then
		task.cancel(snapThread)
		snapThread = nil
	end
end

local function attach(model)
	if CURRENT == model then return end
	disconnectAll()

	CURRENT = model
	HUM     = model and model:FindFirstChildOfClass("Humanoid") or nil
	if not (CURRENT and HUM) then
		warn("[RounderDiag] attach failed (no humanoid)")
		CURRENT, HUM = nil, nil
		return
	end

	baseSpeed = HUM.WalkSpeed
	print(("[RounderDiag] Attached to %s  base WS=%.2f")
		:format(CURRENT:GetFullName(), baseSpeed))

	-- Live property logs
	table.insert(conns, HUM:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		print(("[RounderDiag] WalkSpeed → %.2f"):format(HUM.WalkSpeed))
	end))

	table.insert(conns, CURRENT:GetPropertyChangedSignal("Parent"):Connect(function()
		if CURRENT.Parent == nil then
			print("[RounderDiag] Rounder removed; detaching.")
			disconnectAll()
			CURRENT, HUM, baseSpeed = nil, nil, nil
		end
	end))

	-- 1 Hz snapshots + perma-slow heuristic
	snapThread = task.spawn(function()
		while CURRENT and CURRENT.Parent do
			local ws = HUM.WalkSpeed
			local ps = HUM.PlatformStand
			local jr = HUM.JumpPower
			local ar = HUM.AutoRotate
			local hard = false
			pcall(function() hard = StunService.IsStunned(CURRENT) == true end)

		

			local t = os.clock()
			task.wait(1)
		end
	end)
end

-- Pick an existing Rounder if one is already in the world
local function attachExisting()
	-- Prefer workspace.Enemies children named/looking like Rounder
	local enemies = workspace:FindFirstChild("Enemies")
	if enemies then
		for _, m in ipairs(enemies:GetChildren()) do
			if looksLikeRounder(m) then attach(m); return true end
		end
	end
	-- Fallback: search whole workspace for any model that looks like Rounder
	for _, inst in ipairs(workspace:GetDescendants()) do
		if looksLikeRounder(inst) then attach(inst); return true end
	end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\Script.server.lua -----
local CollectionService = game:GetService("CollectionService")
local RS = game:GetService("ReplicatedStorage")
local Remotes = RS:WaitForChild("RemoteEvents")
local BeginDlg = Remotes:WaitForChild("BeginDialogue")

local function wire(model)
	local prompt = model:FindFirstChildOfClass("ProximityPrompt")
	print("[NPC] wire?", model:GetFullName(), "prompt=", prompt)
	if not prompt then
		warn("[NPC] No ProximityPrompt on", model:GetFullName())
		return
	end
	local storyId = model:GetAttribute("storyId")
	local startNode = model:GetAttribute("startNode")
	print("[NPC] attrs storyId=", storyId, "startNode=", startNode)

	if type(storyId) ~= "string" or storyId == "" then
		warn("[NPC] Missing storyId on", model:GetFullName()); return
	end

	prompt.Enabled = true
	prompt.RequiresLineOfSight = false
	prompt.MaxActivationDistance = 16
	prompt.HoldDuration = 0

	prompt.Triggered:Connect(function(player)
		print("[NPC] Triggered by", player.Name, "→ FireClient BeginDialogue")
		BeginDlg:FireClient(player, storyId, startNode)
	end)
end

for _, m in ipairs(CollectionService:GetTagged("DialogueNPC")) do wire(m) end
CollectionService:GetInstanceAddedSignal("DialogueNPC"):Connect(wire)
print("[NPC] Trigger script ready; tagged count:", #CollectionService:GetTagged("DialogueNPC"))
print()

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\SpawnManager.server.lua -----
local ServerStorage = game:GetService("ServerStorage")
local RS            = game:GetService("ReplicatedStorage")
local Debris        = game:GetService("Debris")

-- Optional: skinning helper from earlier. If you didn't make it yet, comment these 2 lines.
local RigMadLibs    = RS:FindFirstChild("RigMadLibs") and require(RS.RigMadLibs)
local Looks         = RS:FindFirstChild("EnemyLooks") and require(RS.EnemyLooks)

local NPC_PREFABS     = ServerStorage:WaitForChild("NPCs")
local ENEMY_PREFABS   = ServerStorage:WaitForChild("Enemies")

local NPC_ANCHORS     = workspace:FindFirstChild("NPCAnchors")
local ENEMY_LEASHES   = workspace:FindFirstChild("EnemyLeashes")

local function topCenterCF(p: BasePart)
	return p.CFrame * CFrame.new(0, p.Size.Y/2 + 0.1, 0)
end

local function pickLook(prefabName: string)
	if not Looks then return nil end
	local list = Looks[prefabName]
	if not (list and #list > 0) then return nil end
	return list[math.random(1, #list)]
end

local function pivotAndFace(rig: Model, cf: CFrame)
	-- Use PivotTo so HRP + full model follows
	if rig and rig.PrimaryPart then
		rig:PivotTo(cf)
	else
		-- fallback: try to set PrimaryPart
		local hrp = rig:FindFirstChild("HumanoidRootPart")
		if hrp then rig.PrimaryPart = hrp end
		rig:PivotTo(cf)
	end
end

local function spawnFromFolder(folder: Instance, prefabName: string)
	return folder:FindFirstChild(prefabName) and folder[prefabName]:Clone() or nil
end

-- === NPCs (stationary) ===
local function spawnNPCAt(anchor: BasePart)
	local prefabName = anchor:GetAttribute("Prefab")
	if not prefabName then warn("NPC anchor missing Prefab:", anchor:GetFullName()) return end

	local rig = spawnFromFolder(NPC_PREFABS, prefabName)
	if not rig then warn("NPC prefab not found:", prefabName) return end

	rig.Name = prefabName
	rig.Parent = workspace
	pivotAndFace(rig, topCenterCF(anchor))

	-- Optional skin
	pcall(function()
		if RigMadLibs then RigMadLibs.applyUserLook(rig, 1) end -- demo; replace with your choice or use EnemyLooks
	end)

	-- Keep where we spawned it
	rig:SetAttribute("IsNPC", true)
	rig:SetAttribute("AnchorName", anchor.Name)

	-- Respawn behavior (usually false for NPCs)
	if anchor:GetAttribute("Respawn") then
		local hum = rig:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Died:Connect(function()
				local t = anchor:GetAttribute("RespawnTime") or 8
				task.delay(t, function()
					if anchor.Parent then spawnNPCAt(anchor) end
				end)
			end)
		end
	end

	return rig
end

-- === Enemies (leashed) ===
local function spawnEnemyAt(leash: BasePart)
	local prefabName = leash:GetAttribute("Prefab")
	if not prefabName then warn("Leash missing Prefab:", leash:GetFullName()) return end

	local rig = spawnFromFolder(ENEMY_PREFABS, prefabName)
	if not rig then warn("Enemy prefab not found:", prefabName) return end

	rig.Name = prefabName
	rig.Parent = workspace:FindFirstChild("Enemies") or workspace
	pivotAndFace(rig, topCenterCF(leash))

	-- Stamp leash attributes for the AI to use later
	rig:SetAttribute("LeashCenterX", leash.Position.X)
	rig:SetAttribute("LeashCenterY", leash.Position.Y)
	rig:SetAttribute("LeashCenterZ", leash.Position.Z)
	rig:SetAttribute("LeashRadius", leash:GetAttribute("LeashRadius") or 30)
	rig:SetAttribute("ArenaId", leash:GetAttribute("ArenaId") or "")

	-- Optional look randomizer
	pcall(function()
		if RigMadLibs then
			local look = pickLook(prefabName)
			if look then RigMadLibs.spawn(prefabName, rig.Parent, rig.PrimaryPart and rig.PrimaryPart.CFrame or rig:GetPivot(), look) end
			-- If you use the line above, delete `rig` first or modify RigMadLibs to apply look to an existing rig.
		end
	end)

	-- Respawn on death (typical for enemies)
	local shouldRespawn = leash:GetAttribute("Respawn")
	if shouldRespawn == nil then shouldRespawn = true end
	if shouldRespawn then
		local hum = rig:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Died:Connect(function()
				local t = leash:GetAttribute("RespawnTime") or 10
				task.delay(t, function()
					if leash.Parent then spawnEnemyAt(leash) end
				end)
			end)
		end
	end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\StoryDataService.lua -----
-- StoryDataService.lua
-- Wrapper over PlayerDataService for StoryUnlocks + lightweight flags

local RS = game:GetService("ReplicatedStorage")
local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))

-- -------- Allow-list (RS/StoryUnlockables) --------
local ALLOWED
local function refreshAllowed()
	ALLOWED = {}
	local folder = RS:FindFirstChild("StoryUnlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and type(sv.Value) == "string" and sv.Value ~= "" then
				ALLOWED[sv.Value] = true
			end
		end
	end
end
local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end
local storyFolder = RS:FindFirstChild("StoryUnlockables")
if storyFolder then
	storyFolder.ChildAdded:Connect(refreshAllowed)
	storyFolder.ChildRemoved:Connect(refreshAllowed)
end

-- -------- Internals --------
local Busy = setmetatable({}, { __mode = "k" })

local StoryDataService = {}

local function ensureFields(profile)
	local data = profile.Data
	data.StoryUnlocks = data.StoryUnlocks or {}   -- map: [id]=true
	data.StoryFlags   = data.StoryFlags   or {}   -- map: [key]=primitive
end

function StoryDataService.HasStory(player, storyId)
	local profile = PlayerDataService.GetProfile(player)
	if not profile or type(storyId) ~= "string" or storyId == "" then return false end
	ensureFields(profile)
	return profile.Data.StoryUnlocks[storyId] == true
end

function StoryDataService.AddStory(player, storyId, saveNow)
	if type(storyId) ~= "string" or storyId == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	local allowed = getAllowed()
	if not allowed[storyId] then
		warn("[StoryDataService] AddStory rejected (not allowed):", storyId)
		return false
	end
	if Busy[player] then return false end
	Busy[player] = true
	local ok, res = pcall(function()
		if profile.Data.StoryUnlocks[storyId] then return false end
		profile.Data.StoryUnlocks[storyId] = true
		if saveNow and profile.Save then pcall(function() profile:Save() end) end
		return true
	end)
	Busy[player] = nil
	if not ok then warn("[StoryDataService] Error:", res) return false end
	return res
end

function StoryDataService.GetFlags(player)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return table.clone(profile.Data.StoryFlags)
end

function StoryDataService.GetFlag(player, key)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return profile.Data.StoryFlags[key]
end

function StoryDataService.SetFlag(player, key, value, saveNow)
	if type(key) ~= "string" or key == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	profile.Data.StoryFlags[key] = value
	if saveNow and profile.Save then pcall(function() profile:Save() end) end
	return true
end

return StoryDataService

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\StoryDialogueHandler.lua -----
-- StoryDataService.lua
-- Wrapper over PlayerDataService for StoryUnlocks + lightweight flags

local RS = game:GetService("ReplicatedStorage")
local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))

-- -------- Allow-list (RS/StoryUnlockables) --------
local ALLOWED
local function refreshAllowed()
	ALLOWED = {}
	local folder = RS:FindFirstChild("StoryUnlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and type(sv.Value) == "string" and sv.Value ~= "" then
				ALLOWED[sv.Value] = true
			end
		end
	end
end
local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end
local storyFolder = RS:FindFirstChild("StoryUnlockables")
if storyFolder then
	storyFolder.ChildAdded:Connect(refreshAllowed)
	storyFolder.ChildRemoved:Connect(refreshAllowed)
end

-- -------- Internals --------
local Busy = setmetatable({}, { __mode = "k" })

local StoryDataService = {}

local function ensureFields(profile)
	local data = profile.Data
	data.StoryUnlocks = data.StoryUnlocks or {}   -- map: [id]=true
	data.StoryFlags   = data.StoryFlags   or {}   -- map: [key]=primitive
end

function StoryDataService.HasStory(player, storyId)
	local profile = PlayerDataService.GetProfile(player)
	if not profile or type(storyId) ~= "string" or storyId == "" then return false end
	ensureFields(profile)
	return profile.Data.StoryUnlocks[storyId] == true
end

function StoryDataService.AddStory(player, storyId, saveNow)
	if type(storyId) ~= "string" or storyId == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	local allowed = getAllowed()
	if not allowed[storyId] then
		warn("[StoryDataService] AddStory rejected (not allowed):", storyId)
		return false
	end
	if Busy[player] then return false end
	Busy[player] = true
	local ok, res = pcall(function()
		if profile.Data.StoryUnlocks[storyId] then return false end
		profile.Data.StoryUnlocks[storyId] = true
		if saveNow and profile.Save then pcall(function() profile:Save() end) end
		return true
	end)
	Busy[player] = nil
	if not ok then warn("[StoryDataService] Error:", res) return false end
	return res
end

function StoryDataService.GetFlags(player)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return table.clone(profile.Data.StoryFlags)
end

function StoryDataService.GetFlag(player, key)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return profile.Data.StoryFlags[key]
end

function StoryDataService.SetFlag(player, key, value, saveNow)
	if type(key) ~= "string" or key == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	profile.Data.StoryFlags[key] = value
	if saveNow and profile.Save then pcall(function() profile:Save() end) end
	return true
end

return StoryDataService

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\StoryUnlockables.lua -----
-- StoryUnlockables.lua
-- Master allow-list for story IDs; mirrors to RS/StoryUnlockables as StringValues

local RS = game:GetService("ReplicatedStorage")

local StoryAllow = {
	"Hotpants_Start",
	"Horse_Keeper",
	"Johnny_Joestar_Start",
	-- add more storyIds here...
}

local folder = RS:FindFirstChild("StoryUnlockables")
if not folder then
	folder = Instance.new("Folder")
	folder.Name = "StoryUnlockables"
	folder.Parent = RS
end

for _, child in ipairs(folder:GetChildren()) do child:Destroy() end
for _, id in ipairs(StoryAllow) do
	local sv = Instance.new("StringValue")
	sv.Name = id
	sv.Value = id
	sv.Parent = folder
end

return StoryAllow

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\StoryUnlockHandler.lua -----
-- StoryUnlockHandler.lua
-- Mirrors UnlockHandler, but for story unlocks (persistence only)

local RS = game:GetService("ReplicatedStorage")
local Remotes        = RS:WaitForChild("RemoteEvents")
local UnlockStory    = Remotes:WaitForChild("UnlockStory")
local ConfirmSuccess = Remotes:FindFirstChild("ConfirmSuccess")

local StoryDataService = require(script.Parent:WaitForChild("StoryDataService"))

local function notify(player, ok, message)
	if ConfirmSuccess then
		ConfirmSuccess:FireClient(player, { ok = ok, msg = message })
	end
end

local busy = setmetatable({}, { __mode = "k" }) -- weak keys

UnlockStory.OnServerEvent:Connect(function(player, storyId)
	if busy[player] then return end
	busy[player] = true
	task.delay(0.25, function() busy[player] = nil end)

	if type(storyId) ~= "string" or storyId == "" or #storyId > 60 then
		notify(player, false, "Invalid story request.")
		return
	end

	if StoryDataService.HasStory(player, storyId) then
		notify(player, true, ("Story '%s' already unlocked."):format(storyId))
		return
	end

	local added = StoryDataService.AddStory(player, storyId, true)
	if not added then
		notify(player, false, "Story unlock failed or not allowed.")
		return
	end

	notify(player, true, ("Story unlocked: %s"):format(storyId))
end)
return true

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\UnlockHandler.server.lua -----
-- UnlockHandler.lua (ServerScriptService)
-- Handles client requests to unlock a node and hot-loads it

local RS = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local NodeManager       = require(game:GetService("ReplicatedStorage"):WaitForChild("NodeManager"))

local Remotes        = RS:WaitForChild("RemoteEvents")
local UnlockNode     = Remotes:WaitForChild("UnlockNode")
local ConfirmSuccess = Remotes:WaitForChild("ConfirmSuccess", 2) -- optional

local function notify(player, ok, message)
	if ConfirmSuccess then
		ConfirmSuccess:FireClient(player, { ok = ok, msg = message })
	end
end

local busy = setmetatable({}, { __mode = "k" }) -- weak keys

UnlockNode.OnServerEvent:Connect(function(player, nodeName)
	if busy[player] then return end
	busy[player] = true
	task.delay(0.25, function() busy[player] = nil end)

	if type(nodeName) ~= "string" or nodeName == "" or #nodeName > 40 then
		notify(player, false, "Invalid unlock request.")
		return
	end

	local profile = PlayerDataService.GetProfile(player)
	if not profile then
		notify(player, false, "Data not ready. Try again in a moment.")
		return
	end

	-- Already has it?
	for _, n in ipairs(profile.Data.Unlocks or {}) do
		if n == nodeName then
			notify(player, true, nodeName .. " already unlocked.")
			return
		end
	end

	local added = PlayerDataService.AddUnlock(player, nodeName, true)
	if not added then
		notify(player, false, "Unlock failed or not allowed.")
		return
	end

	NodeManager.AddUnlock(player, nodeName)
	print(player.Name, "unlocked", nodeName)
	notify(player, true, "Unlocked " .. nodeName .. "!")
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\WeaponHandler.server.lua -----

-- ServerScriptService/WeaponHandler.lua
-- Bridges client input -> node execution
-- Blocks most actions while Mounted, but whitelists system actions (SummonHorse, BlockEnd, Dismount).
-- Also lets certain nodes run even if not in the 5-slot loadout.

local RS      = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local NodeManager       = require(RS:WaitForChild("NodeManager"))

local Remotes       = RS:WaitForChild("RemoteEvents")
local ActivateNode  = Remotes:WaitForChild("ActivateNode")

-- If your node scripts live here:
local NodeModulesFolder = RS:FindFirstChild("NodeModules")

-- ==== MOUNT GUARD CONFIG =====================================================
local DEBUG_MOUNT = true

local ALLOW_WHEN_MOUNTED = {
	BlockEnd = true,                 -- allow releasing block while mounted
	SummonHorse = true,              -- allow summon/dismiss even if mounted
	Horse_RequestDismount = true,    -- if you route this through the same handler
}

-- Always-available "system actions" (not counted in 5-slot loadout)
local ALWAYS_AVAILABLE = {
	SummonHorse = true,
}
-- ============================================================================

local function isMounted(player)
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	return hum ~= nil and hum:GetAttribute("Mounted") == true
end

local function getDirVecOrFallback(player, dirVec)
	if typeof(dirVec) == "Vector3" and dirVec.Magnitude > 0 then
		return dirVec.Unit
	end
	local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if root then return root.CFrame.LookVector end
	return Vector3.new(0, 0, -1)
end

local function resolveNode(player, nodeName)
	-- Loadout-aware path first
	local node = NodeManager.GetNode(player, nodeName)
	if node then return node end

	-- System actions: allow direct require from RS/NodeModules/<name>
	if ALWAYS_AVAILABLE[nodeName] and NodeModulesFolder then
		local mod = NodeModulesFolder:FindFirstChild(nodeName)
		if mod and mod:IsA("ModuleScript") then
			local ok, res = pcall(require, mod)
			if ok then return res end
			warn(("[WeaponHandler] Failed to require NodeModules.%s: %s"):format(nodeName, tostring(res)))
		end
	end

	return nil
end

ActivateNode.OnServerEvent:Connect(function(player, nodeName, dirVec)
	-- 0) Hard gate while mounted (whitelist exceptions)
	if isMounted(player) and not ALLOW_WHEN_MOUNTED[nodeName] then
		if DEBUG_MOUNT then
			print(("[WeaponHandler] BLOCKED while mounted ▶ %s  node=%s"):format(player.Name, tostring(nodeName)))
		end
		return
	end

	print(('[WeaponHandler] ▶ %s  node=%s'):format(player.Name, tostring(nodeName)))

	-- 1) Validate
	if type(nodeName) ~= "string" or nodeName == "" then
		warn("[WeaponHandler] Invalid node name from", player.Name); return
	end

	-- 2) Ensure profile
	local profile = PlayerDataService.GetProfile(player)
	if not profile then
		warn("[WeaponHandler] No profile yet for", player.Name, "(ignoring)"); return
	end

	-- 3) Resolve node (loadout first; fallback system action module)
	local node = resolveNode(player, nodeName)
	if not node then
		warn(('[WeaponHandler] Node not found for %s: %s'):format(player.Name, nodeName))
		return
	end

	-- 4) Direction
	dirVec = getDirVecOrFallback(player, dirVec)

	-- 5) Execute via common call patterns
	local ok, err
	if type(node.OnStart) == "function" then
		ok, err = pcall(function() node.OnStart(player, dirVec) end)
		if ok then return else warn("[WeaponHandler] OnStart error:", err) end
	end

	if type(node.Execute) == "function" then
		ok, err = pcall(function() node.Execute(player, dirVec) end)
		if ok then return else warn("[WeaponHandler] Execute(player,dir) error:", err) end

		local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if root then
			ok, err = pcall(function() node:Execute(root, dirVec) end)
			if ok then return else warn("[WeaponHandler] Execute(root,dir) error:", err) end
		end
	end

	warn("[WeaponHandler] No valid call pattern for node:", nodeName)
end)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\NodeLibrary\FixedDashAndAnimation.lua -----
-- Assumes 'char' is the character model passed into the function
local function DashAndAnimate(char)
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hum or not hrp then return end

    -- Load Animation (use Animator for R15 and future compatibility)
    local animator = hum:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = hum
    end
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://110397380149359"
    local track = animator:LoadAnimation(anim)
    track:Play()

    -- Dash movement burst (use AssemblyLinearVelocity for physics consistency)
    local dodgeForce = 50
    local moveDir = hum.MoveDirection
    if moveDir.Magnitude > 0 then
        hrp.AssemblyLinearVelocity = moveDir.Unit * dodgeForce
    end
end

return {
    DashAndAnimate = DashAndAnimate
}


----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\server\NodeLibrary\NodeLibrary.lua -----
local NodeLibrary = {}

-- Services / Modules
local RS        = game:GetService("ReplicatedStorage")
local Players   = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local CombatState         = require(RS:WaitForChild("CombatState"))
local CooldownService     = require(RS:WaitForChild("CooldownService"))
local DamageService       = require(RS:WaitForChild("DamageService"))
local GuardService        = require(RS:WaitForChild("GuardService"))
local KnockbackService    = require(RS:WaitForChild("KnockbackService"))
local ComboService        = require(RS:WaitForChild("ComboService"))
local StunService         = require(RS:WaitForChild("StunService"))
local DodgeChargeService  = require(RS:WaitForChild("DodgeChargeService"))
local AttackStateService  = require(RS:WaitForChild("AttackStateService"))
local SpeedController     = require(RS:WaitForChild("SpeedController"))
local NodeSense = require(RS:WaitForChild("NodeSense"))
local RunService = game:GetService("RunService")


local ConfirmSuccess = RS:FindFirstChild("RemoteEvents")
	and RS.RemoteEvents:FindFirstChild("ConfirmSuccess")

-- Optional (used by your Revolver and we’ll piggyback for melee if present)
local HitboxService = RS:FindFirstChild("HitboxService") and require(RS.HitboxService)

-- =============== utils =================
local function isPlayer(x)  return typeof(x) == "Instance" and x:IsA("Player") end

local function resolveCharacter(entity)
	if typeof(entity) == "Instance" then
		if entity:IsA("Player") then return entity.Character end
		if entity:IsA("Model") and entity:FindFirstChildOfClass("Humanoid") then return entity end
	elseif typeof(entity) == "table" and typeof(entity.Character) == "Instance" then
		return entity.Character
	end
	return nil
end

local function partsOf(actor)
	local char = resolveCharacter(actor)
	if not char then return nil end
	local hum  = char:FindFirstChildOfClass("Humanoid")
	local hrp  = char:FindFirstChild("HumanoidRootPart")
	return char, hum, hrp
end

local function playAndUnlock(humanoid, animId, actor)
	local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
	local anim = Instance.new("Animation")
	anim.AnimationId = animId
	local track = animator:LoadAnimation(anim)
	track:Play()
	track.Stopped:Connect(function() CombatState.Unlock(actor) end)
end

-- Tiny model speed shim (players use SpeedController; models we emulate)
-- Tiny model speed shim (baseline-safe for Models; Players use SpeedController)
local _modelBaseline = setmetatable({}, {__mode="k"}) -- [Model] = base WalkSpeed
local _modelTimer    = setmetatable({}, {__mode="k"}) -- [Model] = thread

local function calcBaseline(hum)
	-- If current WS looks “bogus” (already slowed or extreme), fall back to 16
	local ws = hum.WalkSpeed
	if ws < 10 or ws > 30 then return 16 end
	return ws
end

local function baselineFor(model, hum)
	if not _modelBaseline[model] then
		_modelBaseline[model] = calcBaseline(hum)
	end
	return _modelBaseline[model]
end

local function applySpeed(actor, newSpeed, duration)
	if isPlayer(actor) then
		return SpeedController.Apply(actor, newSpeed, duration)
	end
	local char, hum = partsOf(actor)
	if not hum then return end

	-- Always restore to baseline, never to a potentially-slow snapshot
	local base = baselineFor(char, hum)

	-- cancel previous timed restore for this model
	if _modelTimer[char] then task.cancel(_modelTimer[char]) end

	hum.WalkSpeed = newSpeed
	_modelTimer[char] = task.delay(duration, function()
		if hum and hum.Parent then
			hum.WalkSpeed = base
		end
		_modelTimer[char] = nil
	end)
end


-- Faction helper: anything with IsEnemy=true is "enemy", else "player"
local function factionOf(model)
	return (model and model:GetAttribute("IsEnemy")) and "enemy" or "player"
end

-- Collect nearby valid targets (prefers HitboxService; falls back to scan), filtered by faction
local function collectTargetsAround(actor, radius)
	local char, _, root = partsOf(actor)
	if not (char and root) then return {} end

	local mine = factionOf(char)
	local raw, ok
	if HitboxService then
		if HitboxService.SphereFromPoint then
			ok, raw = pcall(HitboxService.SphereFromPoint, root.Position, radius, {humanoidsOnly = true, exclude = char})
		elseif HitboxService.Sphere then
			ok, raw = pcall(HitboxService.Sphere, root.Position, radius, {humanoidsOnly = true, exclude = char})
		elseif HitboxService.CollectHumanoids then
			ok, raw = pcall(HitboxService.CollectHumanoids, root.Position, radius, {exclude = char})
		end
	end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\AttackStateService.lua -----
-- AttackStateService  (ReplicatedStorage)
--
-- Tracks per-player attack phases so delayed hit logic can be cancelled
-- if the attacker is interrupted. Also supports:
--   • Hyper-Armor  – ignore interrupts (stun / hit-stagger).
--   • Move I-frames – grant temporary invulnerability at startup.
--
-- Emits NodeSense outcomes (server-side safe):
--   AttackStart            { duration? }
--   AttackEnd              { result = "Completed" | "Canceled" | "Interrupted" }
--   Interrupted            { reason = "Interrupt" }
--   HyperArmorStart/End    { reason? }
--
-- Usage inside a Node (e.g., Heavy):
--   AttackStateService.Start(player, {
--     duration   = 0.55,
--     hyperArmor = true,
--     iFrames    = 0.4,
--     nodeName   = "Heavy"    -- optional, for nicer telemetry labels
--   })
--   task.delay(0.55, function()
--     -- ✅ gate on IsActive so any cancel before impact stops the hit
--     if AttackStateService.IsActive and not AttackStateService.IsActive(player) then return end
--     -- deal damage here
--     AttackStateService.Clear(player)
--   end)
---------------------------------------------------------------------

local AttackStateService = {}

------------------------------ SERVICES
local Players           = game:GetService("Players")
local RS                = game:GetService("ReplicatedStorage")
local IFrameStore       = require(RS:WaitForChild("IFrameStore"))
local NodeSense         = require(RS:WaitForChild("NodeSense"))

------------------------------ STATE
-- [player] = {
--   interrupted = false,
--   hyperArmor  = false,
--   endTask     = task handle or nil,
--   nodeName    = "Attack",
--   startedAt   = os.clock(),
-- }
local attackState = {}

------------------------------ INTERNAL
local function emit(player, nodeName, outcome, ctx)
	-- Safe on client: NodeSense no-ops there; server will broadcast.
	pcall(function()
		NodeSense.EmitOutcome(player, nodeName or "Attack", outcome, ctx or {})
	end)
end

local function endAttackInternal(player, result, reason)
	local st = attackState[player]
	if not st then return end
	-- cancel timer
	if st.endTask then
		pcall(task.cancel, st.endTask)
	end

	-- Hyper armor ends when the attack ends
	if st.hyperArmor then
		emit(player, st.nodeName, "HyperArmorEnd", { reason = reason or result })
	end

	-- Finalize with AttackEnd
	emit(player, st.nodeName, "AttackEnd", { result = result or "Canceled" })

	attackState[player] = nil
end

------------------------------ PUBLIC API

-- params:
--   • duration    (number) – seconds until attack naturally ends
--   • hyperArmor  (bool)   – immune to interruption
--   • iFrames     (number) – grant i-frames at start
--   • nodeName    (string) – optional label for telemetry
function AttackStateService.Start(player, params)
	if not player then return end

	-- Clear any previous attack (treat as canceled)
	if attackState[player] then
		endAttackInternal(player, "Canceled", "Restart")
	end

	local cfg = params or {}
	local nodeName = tostring(cfg.nodeName or cfg.name or "Attack")

	attackState[player] = {
		interrupted = false,
		hyperArmor  = cfg.hyperArmor == true,
		endTask     = nil,
		nodeName    = nodeName,
		startedAt   = os.clock(),
	}

	-- Optional move-based i-frames (authoritative in IFrameStore)
	if cfg.iFrames and cfg.iFrames > 0 then
		IFrameStore.Grant(player, cfg.iFrames, "Move")
	end

	-- Hyper armor telemetry (if enabled)
	if attackState[player].hyperArmor then
		emit(player, nodeName, "HyperArmorStart", { reason = "Start" })
	end

	-- Attack lifecycle start
	emit(player, nodeName, "AttackStart", {
		duration = cfg.duration,
	})

	-- Auto-clear after duration, if provided
	if cfg.duration and cfg.duration > 0 then
		local t
		t = task.delay(cfg.duration, function()
			-- only complete if still active and timer matches
			if attackState[player] and attackState[player].endTask == t then

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\CardinalFacts.lua -----
-- Canonical telemetry facts for the cardinal moves.
-- Used by NodeFactory stubs (intent) and can also be used by NodeLibrary.
local Facts = {}

Facts.Punch = {
	Name         = "Punch",
	-- Balance: your current M1s
	Damage       = 3.3,
	GuardDamage  = 0,
	Chip         = 0,
	Stun         = 0.20,    -- micro stagger on clean hit (AI weight only)
	Blockable    = true,
	Parryable    = false,
	Melee        = true,
	M1           = true,
	Radius       = 5,
}

Facts.Heavy = {
	Name         = "Heavy",
	Damage       = 7.0,
	GuardDamage  = 30,
	Chip         = 2.0,
	Stun         = 0.40,    -- mild stagger on hit (AI weight only)
	Blockable    = false,
	Parryable    = true,
	Melee        = true,
	Heavy        = true,
	Radius       = 7,
	KnockbackForce = 90,
	KnockbackDur   = 0.35,
}

Facts.Block = { Name = "Block" }
Facts.Dodge = { Name = "Dodge" }

return Facts

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\CombatState.lua -----
-- CombatState (ref-counted, key-normalized)
-- Drop-in replacement to prevent permanent locks from mixed Player/Model usage.

local CombatState = {}

local Players = game:GetService("Players")

-- ========== internal state ==========
local lockCount     = setmetatable({}, { __mode = "k" }) -- [key] = int
local activeTracks  = setmetatable({}, { __mode = "k" }) -- [key] = AnimationTrack
local unlockBuffer  = setmetatable({}, { __mode = "k" }) -- [key] = tick()
local lastEvent     = setmetatable({}, { __mode = "k" }) -- [key] = { kind, reason, when, caller }

-- ---------- key normalization ----------
local function asModel(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model") then return ent end
	return ent:FindFirstAncestorOfClass("Model")
end

local function normKey(entity)
	if typeof(entity) ~= "Instance" then return entity end
	if entity:IsA("Player") then return entity end
	if entity:IsA("Model") then
		return Players:GetPlayerFromCharacter(entity) or entity
	end
	local mdl = asModel(entity)
	return (mdl and (Players:GetPlayerFromCharacter(mdl) or mdl)) or entity
end

local function mark(key, kind, reason)
	lastEvent[key] = {
		kind   = kind,                            -- "lock" | "unlock" | "unlock(force)"
		reason = reason or "unspecified",
		when   = os.clock(),
		caller = debug.info(3, "s") or "unknown",
		count  = lockCount[key] or 0,
	}
end

-- ========== public API ==========

function CombatState.Lock(entity, reason)
	local key = normKey(entity); if not key then return end
	lockCount[key] = (lockCount[key] or 0) + 1
	mark(key, "lock", reason)
end

function CombatState.Unlock(entity, reason)
	local key = normKey(entity); if not key then return end
	local n = (lockCount[key] or 0) - 1
	if n <= 0 then
		lockCount[key] = nil
	else
		lockCount[key] = n
	end
	mark(key, "unlock", reason)
end

function CombatState.ForceUnlock(entity, reason)
	local key = normKey(entity); if not key then return end
	lockCount[key] = nil
	mark(key, "unlock(force)", reason or "manual")
end

function CombatState.IsLocked(entity)
	local key = normKey(entity); if not key then return false end
	return (lockCount[key] or 0) > 0
end

-- Optional: short grace period after unlock (unchanged semantics)
function CombatState.SetUnlockBuffer(entity, duration)
	local key = normKey(entity); if not key then return end
	unlockBuffer[key] = tick() + (duration or 0)
end

function CombatState.RecentlyUnlocked(entity)
	local key = normKey(entity); if not key then return false end
	return (unlockBuffer[key] or 0) > tick()
end

-- Animation helpers (key-normalized)
function CombatState.RegisterTrack(entity, track)
	local key = normKey(entity); if not key then return end
	if activeTracks[key] then
		pcall(function() activeTracks[key]:Stop() end)
	end
	activeTracks[key] = track
end

function CombatState.StopCurrentTrack(entity)
	local key = normKey(entity); if not key then return end
	if activeTracks[key] then
		pcall(function() activeTracks[key]:Stop() end)
		activeTracks[key] = nil
	end
end

-- Cleanup for a given entity/key
function CombatState.Cleanup(entity)
	local key = normKey(entity); if not key then return end
	lockCount[key]    = nil
	activeTracks[key] = nil
	unlockBuffer[key] = nil
	lastEvent[key]    = nil
end

-- Debug helpers
function CombatState.GetLockInfo(entity)
	local key = normKey(entity); if not key then return nil end
	return {
		count  = lockCount[key] or 0,
		last   = lastEvent[key],
		hasTrack = activeTracks[key] ~= nil,
	}
end

function CombatState.DebugPrint(entity, label)
	local info = CombatState.GetLockInfo(entity)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\ComboService.lua -----
local ComboService = {}

---------------------------------------------------------------------
-- ComboService
-- Tracks consecutive light-attack hits and triggers a finisher.
-- Works for both Players and NPC Models.
---------------------------------------------------------------------

------------------------------ SERVICES
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DamageService     = require(ReplicatedStorage:WaitForChild("DamageService"))
local KnockbackService  = require(ReplicatedStorage:WaitForChild("KnockbackService"))
local StunService       = require(ReplicatedStorage:WaitForChild("StunService"))
local CooldownService   = require(ReplicatedStorage:WaitForChild("CooldownService"))

------------------------------ REMOTES (optional FX / UI hooks)
local RemoteEvents      = ReplicatedStorage:WaitForChild("RemoteEvents")
local ComboBurst        = RemoteEvents:FindFirstChild("ComboBurst") -- may be nil

------------------------------ TUNING
local COMBO_RESET        = 3.0   -- seconds before combo times out
local HIT_MAX            = 5     -- # of M1 hits before finisher
local FINISHER_RADIUS    = 7     -- damage radius
local KB_RADIUS          = 6     -- knockback/stagger radius

-- New: brief recovery after a finisher (locks common actions)
local FINISHER_RECOVERY_SEC = 1.0
local FINISHER_LOCK_MOVES   = { "Punch", "Heavy", "Dodge", "BlockStart" }

-- Legacy: specific punch cooldown (kept; harmless if duplicated with recovery)
local FINISHER_PUNCH_CD  = 3.0

local FINISHER_DMG       = { guard = 0, hp = 6.6, chip = 0, nodeName = "ComboFinisher" }
local KB_FORCE           = 90
local KB_DUR             = 0.25
local FINISHER_STUN      = 0.3   -- mild stagger after burst

------------------------------ STATE
local comboCount  = {}    -- [attacker(Player|Model)] = hits
local lastHitTime = {}    -- [attacker] = tick()

------------------------------ HELPERS
local function asModel(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model") then return ent end
	return nil
end

local function rootOf(ent)
	local mdl = asModel(ent)
	return mdl and mdl:FindFirstChild("HumanoidRootPart") or nil
end

local function isPlayer(ent)
	return typeof(ent) == "Instance" and ent:IsA("Player")
end

local function iterTargetsAround(origin, radius)
	local oModel = asModel(origin)
	local oRoot  = rootOf(origin)
	if not oModel or not oRoot then return {} end

	local found = {}
	local seen  = {}  -- dedupe by model instance

	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("Humanoid") then
			local mdl = inst.Parent
			if mdl and mdl:IsA("Model") and mdl ~= oModel then
				local hrp = mdl:FindFirstChild("HumanoidRootPart")
				if hrp and (hrp.Position - oRoot.Position).Magnitude <= radius then
					if not seen[mdl] then
						seen[mdl] = true
						local plr = Players:GetPlayerFromCharacter(mdl)
						table.insert(found, plr or mdl)
					end
				end
			end
		end
	end

	return found
end

------------------------------ API
function ComboService.RegisterHit(attacker)
	local now = tick()

	if (lastHitTime[attacker] or 0) + COMBO_RESET < now then
		comboCount[attacker] = 0
	end

	comboCount[attacker] = (comboCount[attacker] or 0) + 1
	lastHitTime[attacker] = now

	if comboCount[attacker] >= HIT_MAX then
		ComboService.Finish(attacker)
	end
end

function ComboService.Finish(attacker)
	comboCount[attacker]  = 0
	lastHitTime[attacker] = tick()

	local oModel = asModel(attacker)
	local oRoot  = rootOf(attacker)
	if not oModel or not oRoot then return end

	-- Brief recovery: lock common actions for 1s (players & NPCs)
	for _, key in ipairs(FINISHER_LOCK_MOVES) do
		pcall(CooldownService.Apply, attacker, key, FINISHER_RECOVERY_SEC)
	end

	-- Keep specific punch cooldown (no harm if redundant)
	if isPlayer(attacker) then
		CooldownService.Apply(attacker, "Punch", FINISHER_PUNCH_CD)
	end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\CooldownService.lua -----
local CooldownService = {}

local cooldowns = {}

-- Checks if the player can use a specific action
function CooldownService.CanUse(player, action)
	if not player then return false end
	local playerCooldowns = cooldowns[player]
	if not playerCooldowns then return true end

	local timestamp = playerCooldowns[action]
	return not timestamp or tick() >= timestamp
end

-- Sets a cooldown for a specific action
function CooldownService.Apply(player, action, duration)
	if not player then return end
	cooldowns[player] = cooldowns[player] or {}
	cooldowns[player][action] = tick() + duration
end

-- Optionally reset cooldowns for a player (e.g., on death or reset)
function CooldownService.Clear(player)
	cooldowns[player] = nil
end

-- Optional debug readout
function CooldownService.GetRemaining(player, action)
	local ts = cooldowns[player] and cooldowns[player][action]
	if ts then
		return math.max(0, ts - tick())
	end
	return 0
end

return CooldownService

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\DamageService.lua -----
-- DamageService.lua  (robust, block-aware, interrupt-aware, NodeSense telemetry)
-- Honors blocking for any blockable move (even when guard=0), parry,
-- I-frames, hyper-armor, and will INTERRUPT the defender's current attack
-- on successful HP damage (unless they have hyper-armor).
-- Optional: dmg.stun / dmg.hitstun / dmg.stagger (seconds) to apply StunService.

local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")

local CombatState        = require(RS:WaitForChild("CombatState"))
local GuardService       = require(RS:WaitForChild("GuardService"))
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local ParryService       = require(RS:WaitForChild("ParryService"))
local NodeSense          = require(RS:WaitForChild("NodeSense"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local StunService        = require(RS:WaitForChild("StunService"))

local DamageService = {}

---------------------------------------------------------------------
-- DEBUG
---------------------------------------------------------------------
local DEBUG = false
local function dprint(...) if DEBUG then print("[DamageService]", ...) end end
local function dwarn(...)  if DEBUG then warn("[DamageService]", ...) end end

---------------------------------------------------------------------
-- UTIL
---------------------------------------------------------------------
local function asCharacter(entity)
	if not entity then return nil end
	if typeof(entity) == "Instance" then
		if entity:IsA("Player") then return entity.Character end
		if entity:IsA("Model") and entity:FindFirstChildOfClass("Humanoid") then return entity end
	elseif typeof(entity) == "table" and typeof(entity.Character) == "Instance" then
		return entity.Character
	end
	return nil
end

local function getHumanoid(target)
	if not target then return nil end
	if target:IsA("Player") then
		return target.Character and target.Character:FindFirstChildOfClass("Humanoid")
	elseif target:IsA("Model") then
		return target:FindFirstChildOfClass("Humanoid")
	end
end

local function getRoot(target)
	if not target then return nil end
	if target:IsA("Player") then
		return target.Character and target.Character:FindFirstChild("HumanoidRootPart")
	elseif target:IsA("Model") then
		return target:FindFirstChild("HumanoidRootPart")
	end
end

local function getUserId(entity)
	if not entity or typeof(entity) ~= "Instance" then return nil end
	if entity:IsA("Player") then return entity.UserId end
	if entity:IsA("Model") then
		local plr = Players:GetPlayerFromCharacter(entity)
		return plr and plr.UserId or nil
	end
	return nil
end

-- Accept a number or any table shape and normalize keys.
local function coerceDamageTable(dmg)
	if dmg == nil then return nil end
	-- number → hp
	if typeof(dmg) == "number" then
		return { hp = dmg, guard = 0, chip = 0, parryable = true, blockable = true, nodeName = "Unknown" }
	end
	if typeof(dmg) ~= "table" then
		dwarn("Bad dmg type:", typeof(dmg))
		return nil
	end

	-- accept many synonyms
	local hp    = dmg.hp or dmg.HP or dmg.health or dmg.Health or dmg.damage or dmg.Damage
	local guard = dmg.guard or dmg.Guard or dmg.guardDamage or dmg.GuardDamage
	local chip  = dmg.chip or dmg.Chip or dmg.chipDamage or dmg.ChipDamage
	local stun  = dmg.stun or dmg.hitstun or dmg.stagger or dmg.Stun or dmg.Hitstun or dmg.Stagger

	-- defaults
	hp    = tonumber(hp)    or 0
	guard = tonumber(guard) or 0
	chip  = tonumber(chip)  or 0
	stun  = tonumber(stun)  or 0

	-- parryable defaults to true unless explicitly false anywhere
	local p1 = dmg.parryable; local p2 = dmg.Parryable; local p3 = dmg.isParryable
	local parryable = not (p1 == false or p2 == false or p3 == false)

	-- blockable defaults to true unless explicitly false or "unblockable" is set
	local blockable = true
	if dmg.blockable == false or dmg.Blockable == false or dmg.unblockable == true or dmg.Unblockable == true then
		blockable = false
	end

	-- optional node name for telemetry
	local nodeName = dmg.nodeName or dmg.NodeName or dmg.name or dmg.Name or "Unknown"

	return {
		hp = hp, guard = guard, chip = chip, stun = stun,
		parryable = parryable,
		blockable = blockable,
		nodeName  = tostring(nodeName),
	}
end

---------------------------------------------------------------------
-- CORE
---------------------------------------------------------------------
local function dealDamageCore(defender, dmg, attacker)
	if not defender or not dmg then return end

	local nodeName   = dmg.nodeName or "Unknown"

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\DodgeChargeService.lua -----
-- ReplicatedStorage/DodgeChargeService.lua
local DodgeChargeService = {}

local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")
local DodgeEvt= RS:WaitForChild("RemoteEvents"):WaitForChild("DodgeCharges")

local MAX_CHARGES       = 3
local RECHARGE_INTERVAL = 7.5

local charges   = {}
local regenTask = {}

local function push(player)
	-- send (current, max) to that player
	DodgeEvt:FireClient(player, charges[player] or 0, MAX_CHARGES)
end

local function stopTask(player)
	if regenTask[player] then
		pcall(task.cancel, regenTask[player])
		regenTask[player] = nil
	end
end

local function startRegenLoop(player)
	if regenTask[player] then return end
	regenTask[player] = task.spawn(function()
		while player.Parent do
			if (charges[player] or 0) >= MAX_CHARGES then
				stopTask(player)
				break
			end
			task.wait(RECHARGE_INTERVAL)
			if (charges[player] or 0) < MAX_CHARGES then
				charges[player] = charges[player] + 1
				push(player) -- 🔵 notify client on +1
			end
		end
	end)
end

function DodgeChargeService.Get(player)
	return charges[player] or MAX_CHARGES
end

function DodgeChargeService.CanDodge(player)
	return (charges[player] or 0) > 0
end

function DodgeChargeService.Consume(player)
	if DodgeChargeService.CanDodge(player) then
		charges[player] = charges[player] - 1
		push(player)          -- 🔵 notify client on spend
		startRegenLoop(player)
		return true
	end
	return false
end

function DodgeChargeService.Reset(player)
	stopTask(player)
	charges[player] = MAX_CHARGES
	push(player)              -- 🔵 notify client on reset / spawn
end

Players.PlayerAdded:Connect(function(plr)
	DodgeChargeService.Reset(plr)  -- fires initial push
	-- If you also want full on death, uncomment:
	-- plr.CharacterAdded:Connect(function() DodgeChargeService.Reset(plr) end)
end)

Players.PlayerRemoving:Connect(function(plr)
	stopTask(plr)
	charges[plr]   = nil
	regenTask[plr] = nil
end)

return DodgeChargeService

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\EnemyLooks.lua -----
-- ReplicatedStorage/EnemyLooks.lua
return {
	Hotpants_Start = {
		{
			assets = {
				shirt = 6075850504,
				pants = 6806968785,
				hair  = {13397220399},
				hats  = {85721183097737},
			}
		}
	},


	Horse_Keeper = {
		{
			assets = {
				shirt = 8168521914,
				pants = 17468619384,
				hats  = { 87049072653005 }, -- HatAccessory IDs go in a list
			}
		}
	},
	Johnny_Joestar_Start = {
		{
			assets = {
				shirt = 107753108912057,   -- Shirt ID
				pants = 5212296507,       -- Pants ID
				hats  = { 79620692802856 } -- HatAccessory IDs list
			}
		}
	},


}


----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\EnemySpecs.lua -----
-- ReplicatedStorage/EnemySpecs.lua
-- enemyId → spec: which brain, look, defaults, difficulty (DEF/OFF), etc.
return {
	-- Worst-tier tutorial enemy (dopey)
	Rounder_Tutorial = {
		enemyType   = "Rounder",
		
		leashRadius = 30,
		aiProfile   = "RounderV1",
		stats       = { WalkSpeed = 14, JumpPower = 40 },
		DEF         = 100,   -- near-worst defense/reactivity
		OFF         = 1,   -- near-worst aggression/pressure
	},

}

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\GuardService.lua -----
-- GuardService  (ReplicatedStorage)
-- Guard meter with block/regen/break + NodeSense outcome emits.
-- Compatible with DamageService.Apply/DealDamage and AttackStateService.
-- Extras: sets debug attributes "Blocking" (bool) and "Guard" (0..MAX)

-------------------------------------------------- CONFIG
local MAX_GUARD      = 50
local REGEN_PER_SEC  = 5
local BREAK_STUN     = 2.5

-------------------------------------------------- SERVICES
local Players        = game:GetService("Players")
local RS             = game:GetService("ReplicatedStorage")

local CombatState    = require(RS:WaitForChild("CombatState"))
local StunService    = require(RS:WaitForChild("StunService"))
local SpeedController= require(RS:WaitForChild("SpeedController"))
local NodeSense      = require(RS:WaitForChild("NodeSense"))

-------------------------------------------------- STATE
local GuardService   = {}
local guardHP        = {}   -- [entity(Player|Model)] = current guard
local isBlocking     = {}   -- [entity] = true while holding block

-------------------------------------------------- HELPERS
local function getHumanoid(entity)
	if typeof(entity) ~= "Instance" then return nil end
	if entity:IsA("Player") then
		local c = entity.Character
		return c and c:FindFirstChildOfClass("Humanoid")
	elseif entity:IsA("Model") then
		return entity:FindFirstChildOfClass("Humanoid")
	end
end

local function getPlayerFromEntity(entity)
	if typeof(entity) ~= "Instance" then return nil end
	if entity:IsA("Player") then return entity end
	if entity:IsA("Model") then
		return Players:GetPlayerFromCharacter(entity)
	end
	return nil
end

local function getUserId(entity)
	local plr = getPlayerFromEntity(entity)
	return plr and plr.UserId or nil
end

local function ensureInit(ent)
	if guardHP[ent] == nil then guardHP[ent] = MAX_GUARD end
end

local function setAttrs(ent)
	-- purely debug/UX; harmless if unused
	local hp = guardHP[ent]
	if typeof(ent) == "Instance" and ent.Parent then
		pcall(function()
			ent:SetAttribute("Blocking", isBlocking[ent] == true)
			if hp ~= nil then
				ent:SetAttribute("Guard", math.clamp(hp, 0, MAX_GUARD))
			end
		end)
	end
end

-------------------------------------------------- API
function GuardService.StartBlock(entity)
	if not entity then return end
	ensureInit(entity)
	isBlocking[entity] = true
	setAttrs(entity)

	-- Optional: broadcast block state for AI blackboards
	NodeSense.EmitOutcome(entity, "Block", "BlockStart", {
		targetId = getUserId(entity),
	})
end

function GuardService.EndBlock(entity)
	if not entity then return end
	isBlocking[entity] = nil
	setAttrs(entity)

	NodeSense.EmitOutcome(entity, "Block", "BlockEnd", {
		targetId = getUserId(entity),
	})
end

function GuardService.GetPercent(entity)
	return (guardHP[entity] or MAX_GUARD) / MAX_GUARD
end

-- Preferred signature:
--   ApplyGuardDamage(attacker, defender, rawDamage, nodeName)
-- Legacy signature (still supported):
--   ApplyGuardDamage(defender, rawDamage [, nodeName])
-- Returns: nil | "blocked" | "break"
function GuardService.ApplyGuardDamage(a, b, c, d)
	local attacker, defender, rawDamage, nodeName

	-- Detect signature based on argument types
	if typeof(a) == "Instance" and typeof(b) == "Instance" and type(c) == "number" then
		-- New signature
		attacker  = a
		defender  = b
		rawDamage = c
		nodeName  = (type(d) == "string") and d or nil
	else
		-- Legacy
		attacker  = nil
		defender  = a
		rawDamage = b
		nodeName  = (type(c) == "string") and c or nil
	end

	if not defender or type(rawDamage) ~= "number" then return nil end
	if not isBlocking[defender] then return nil end

	ensureInit(defender)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\GunProp.lua -----
this is a model, not a module

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\HitboxService.lua -----
--------------------------------------------------------------------
-- HitboxService (v1.7) — contact-only, outcome via DamageService
-- - Legacy path: you can still pass a `callback(mdl)` → unchanged
-- - New path: pass opts.damage / opts.attacker and it will call
--             DamageService.DealDamage(defender, opts.damage, opts.attacker)
-- - Optional: opts.intent=true → one-time NodeSense "intent" emit at spawn
--------------------------------------------------------------------
local HitboxService = {}

local Debris   = game:GetService("Debris")
local Players  = game:GetService("Players")
local RS       = game:GetService("ReplicatedStorage")

local DamageService = require(RS:WaitForChild("DamageService"))
local NodeSense     = require(RS:WaitForChild("NodeSense"))

-- Utility: return Model with living Humanoid
local function getLivingCharacter(inst)
	local mdl = inst:FindFirstAncestorOfClass("Model")
	if not mdl then return nil end
	local hum = mdl:FindFirstChildOfClass("Humanoid")
	if hum and hum.Health > 0 then
		return mdl
	end
end

-- Defender entity: prefer Player if one owns the model
local function toDefenderEntity(mdl)
	local plr = Players:GetPlayerFromCharacter(mdl)
	return plr or mdl
end

-- Spawn invisible anchored sphere
local function makeSphere(radius, cf)
	local p = Instance.new("Part")
	p.Shape        = Enum.PartType.Ball
	p.Size         = Vector3.new(1,1,1) * (radius*2)
	p.Transparency = 1
	p.CanCollide   = false
	p.Anchored     = true
	p.CFrame       = cf
	p.Name         = "HitboxSphere"
	p.Parent       = workspace
	return p
end

-- Internal create function
local function _create(getCF, radius, lifetime, ignoreList, oneShot, callback, opts)
	lifetime   = lifetime   or 0.2
	oneShot    = (oneShot    ~= false)
	ignoreList = ignoreList or {}
	opts       = opts       or {}

	-- ignore any descendants of these instances
	local function isIgnored(inst)
		for _,ign in ipairs(ignoreList) do
			if inst == ign or inst:IsDescendantOf(ign) then
				return true
			end
		end
		return false
	end

	local destroyOnHit = opts.destroyOnHit
	if destroyOnHit == nil then destroyOnHit = oneShot end

	local linkedParts  = opts.linkedParts or {}

	-- Optional: one-time "intent" telemetry on arm
	if opts.intent == true then
		local nodeName = opts.nodeName
			or (typeof(opts.damage)=="table" and (opts.damage.nodeName or opts.damage.NodeName))
			or "Hitbox"
		local tags = nil
		if typeof(NodeSense) == "table" and typeof(NodeSense.CollectTags) == "function" then
			local dmgTbl = (typeof(opts.damage)=="table") and opts.damage or {}
			tags = NodeSense.CollectTags(dmgTbl, opts.tagsOverride)
		end
		pcall(function()
			NodeSense.Emit(opts.attacker, nodeName, tags, { armed = true })
		end)
	end

	local sphere = makeSphere(radius, getCF())
	print("[HitboxService] 🔵 spawned at", sphere.CFrame.Position)

	-- Optional per-target throttle for moving hitboxes
	local perTargetCooldown = tonumber(opts.hitCooldown)
	local recentHits = {} -- [Model] = expireTick

	local running = true
	local conn
	conn = sphere.Touched:Connect(function(other)
		if not running then return end

		if isIgnored(other) then
			print("[HitboxService]   ⚪ ignored collision with", other:GetFullName())
			return
		end

		local mdl = getLivingCharacter(other)
		if not mdl then
			print("[HitboxService]   ⚪ non-target hit with", other:GetFullName())
			return
		end

		-- Per-target throttle (optional)
		if perTargetCooldown and perTargetCooldown > 0 then
			local now = tick()
			if (recentHits[mdl] or 0) > now then
				-- still cooling down for this target
				return
			end
			recentHits[mdl] = now + perTargetCooldown
		end

		print("[HitboxService]   🔴 hit target:", mdl.Name)

		-- Legacy path: explicit callback takes priority
		if typeof(callback) == "function" then

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\IFrameStore.lua -----
---------------------------------------------------------------------
-- IFrameStore • authoritative registry for active i-frames
-- Emits NodeSense outcomes:
--   DodgeStart   (when i-frames begin)
--   DodgeRefresh (when an active window is extended/refreshed)
--   DodgeEnd     (when i-frames end naturally or via Clear)
---------------------------------------------------------------------
local IFrameStore = {}

local RS        = game:GetService("ReplicatedStorage")
local NodeSense = require(RS:WaitForChild("NodeSense"))

-- [player] = expiry tick()
local registry = {}

-- Optional: last start tick, helps with debugging/telemetry
local lastStart = {}  -- [player] = tick()

-- Internal: emit helper
local function emit(player, outcome, ctx)
	-- Player = actor; nodeName = "Dodge"
	-- NodeSense dedup protects against bursty repeats
	pcall(function()
		NodeSense.EmitOutcome(player, "Dodge", outcome, ctx or {})
	end)
end

-- Give player i-frames for `duration` seconds
-- If already active, this refreshes/extends the window and emits DodgeRefresh
function IFrameStore.Grant(player, duration, reason)
	if not player or type(duration) ~= "number" or duration <= 0 then return end

	local now      = tick()
	local prevExp  = registry[player] or 0
	local wasActive= prevExp > now

	local newExp   = now + duration
	registry[player] = newExp
	if not wasActive then
		lastStart[player] = now
		emit(player, "DodgeStart", { duration = duration, expiresAt = newExp, reason = reason or "Dodge" })
	else
		-- Active window extended/refreshed
		emit(player, "DodgeRefresh", {
			added     = duration,
			expiresAt = newExp,
			remaining = newExp - now,
			reason    = reason or "Dodge"
		})
	end

	-- Only the latest grant should end the window
	local thisExp = newExp
	task.delay(duration, function()
		-- If no newer grant occurred and time has passed, end it
		if registry[player] == thisExp and thisExp <= tick() then
			registry[player] = nil
			lastStart[player] = nil
			emit(player, "DodgeEnd", { reason = reason or "Dodge" })
		end
	end)
end

-- Query: is the player currently invulnerable?
function IFrameStore.IsActive(player)
	return (registry[player] or 0) > tick()
end

-- Optional: remaining seconds (0 if none)
function IFrameStore.GetRemaining(player)
	local rem = (registry[player] or 0) - tick()
	return rem > 0 and rem or 0
end

-- Optional: force-clear i-frames early (emits DodgeEnd once)
function IFrameStore.Clear(player, reason)
	local wasActive = IFrameStore.IsActive(player)
	registry[player] = nil
	lastStart[player] = nil
	if wasActive then
		emit(player, "DodgeEnd", { reason = reason or "Clear" })
		return true
	end
	return false
end

return IFrameStore

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\KnockbackService.lua -----
-- KnockbackService  (ReplicatedStorage)
-- Applies physics impulses while respecting Guard, I-frames, and Hyper-Armor.

local KnockbackService = {}

------------------------------ DEPENDENCIES
local Players            = game:GetService("Players")
local RS                 = game:GetService("ReplicatedStorage")
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local GuardService       = require(RS:WaitForChild("GuardService"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))

------------------------------ TUNING
local POWER = 5          -- base multiplier (tune to taste)
local DEBUG = false
local function d(...) if DEBUG then print("[Knockback]", ...) end end

------------------------------ HELPERS
local function rootOf(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then
		local c = ent.Character
		return c and c:FindFirstChild("HumanoidRootPart")
	elseif ent:IsA("Model") then
		return ent:FindFirstChild("HumanoidRootPart")
	end
end

local function asEntity(x)
	if typeof(x) ~= "Instance" then return nil end
	if x:IsA("Player") or x:IsA("Model") then return x end
	return nil
end

------------------------------ CORE
-- @param target  Player | Model
-- @param dir     Vector3  — direction FROM attacker TO target
-- @param force   number   — base force (scaled by POWER & mass)
-- @param dur     number   — seconds before we zero linear velocity (default 0.3)
function KnockbackService.Apply(target, dir, force, dur)
	target = asEntity(target)
	if not target then return end
	if typeof(dir) ~= "Vector3" or dir.Magnitude == 0 then return end

	------------------------------------------------------------------
	--  Immunity Checks
	------------------------------------------------------------------
	-- Hard invincibility attribute (works for Players & Models)
	if target.GetAttribute and target:GetAttribute("Invincible") then
		return
	end

	-- Blocking negates knockback. (Guard-broken NO LONGER cancels knockback.)
	if GuardService and GuardService.IsBlocking and GuardService.IsBlocking(target) then
		d("IMMUNE: Blocking", target)
		return
	end

	-- I-frames (players only)
	if target:IsA("Player") and IFrameStore.IsActive(target) then
		return
	end

	-- Hyper-Armor (if your AttackStateService tracks it)
	if AttackStateService.HasHyperArmor and AttackStateService.HasHyperArmor(target) then
		d("IMMUNE: HyperArmor", target)
		return
	end

	------------------------------------------------------------------
	--  Physics Impulse
	------------------------------------------------------------------
	local root = rootOf(target)
	if not root then return end

	-- Ensure server controls physics for deterministic result
	local prevOwner = root:GetNetworkOwner()
	if prevOwner then root:SetNetworkOwner(nil) end
	if root.Anchored then root.Anchored = false end

	local impulse = dir.Unit * (force or 1) * POWER * root:GetMass()
	d("Impulse", impulse)
	root:ApplyImpulse(impulse)

	-- Optional slide stop + restore previous network owner
	local stopAfter = dur or 0.3
	if stopAfter > 0 then
		task.delay(stopAfter, function()
			if root and root.Parent then
				root.AssemblyLinearVelocity = Vector3.zero
				if prevOwner and prevOwner.Parent then
					pcall(function() root:SetNetworkOwner(prevOwner) end)
				end
			end
		end)
	end
end

return KnockbackService

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeFactory.lua -----
--------------------------------------------------------------------
-- NodeFactory • v8.3 (mount-safe)
-- + Execute(rootPart, extra) signature
-- + GetCFrame(extra) & LinkedParts(extra)
-- + Blocks node execution while player is Mounted (Humanoid attribute)
--   (per-node override: cfg.AllowWhileMounted = true)
--------------------------------------------------------------------
local RS       = game:GetService("ReplicatedStorage")
local Players  = game:GetService("Players")

-- dependencies
local HitboxService      = require(RS:WaitForChild("HitboxService"))
local CooldownService    = require(RS:WaitForChild("CooldownService"))
local SpeedController    = require(RS:WaitForChild("SpeedController"))
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local DamageService      = require(RS:WaitForChild("DamageService"))
local GuardService       = require(RS:WaitForChild("GuardService"))
local StunService        = require(RS:WaitForChild("StunService"))
local KnockbackService   = require(RS:WaitForChild("KnockbackService"))

local NodeFactory = {}

--------------------------------------------------------------------
-- Mount helpers (future-proof)
--------------------------------------------------------------------
local MOUNT_DEBUG = false

local function isMountedPlayer(player: Player?): boolean
	if not player then return false end
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

local function playerFromRoot(rootPart: BasePart?)
	if not rootPart then return nil, nil end
	local char = rootPart.Parent
	if not char then return nil, nil end
	return Players:GetPlayerFromCharacter(char), char
end

--------------------------------------------------------------------
-- Factory
--------------------------------------------------------------------
function NodeFactory.Create(cfg)
	assert(cfg and type(cfg) == "table", "NodeFactory: cfg table required")
	assert(cfg.Name, "NodeFactory: Name required")
	assert(cfg.Radius or cfg.UseMovingHitbox, "NodeFactory: Radius required")

	local node = {}
	for k, v in pairs(cfg) do node[k] = v end

	-- Optional per-node escape hatch:
	-- cfg.AllowWhileMounted = true  -- e.g., emotes you want to permit

	function node:Execute(rootPart, extra)
		if not rootPart or typeof(rootPart) ~= "Instance" then return end

		-- Resolve caller
		local player, char = playerFromRoot(rootPart)
		-- 🚧 Hard gate while mounted (unless explicitly allowed on this node)
		if player and (not self.AllowWhileMounted) and isMountedPlayer(player) then
			if MOUNT_DEBUG then
				print(("[NodeFactory] BLOCKED while mounted ▶ %s  node=%s")
					:format(player.Name, tostring(self.Name or "?")))
			end
			return
		end

		-- Cooldown (only if configured; Revolver handles its own)
		if player and self.Cooldown and self.Cooldown > 0 then
			if not CooldownService.CanUse(player, self.Name) then return end
			CooldownService.Apply(player, self.Name, self.Cooldown)
		end

		-- Self-effects / attack state
		if player and self.Speed then
			SpeedController.Apply(player, self.Speed, self.SpeedDuration or 0.5)
		end
		AttackStateService.Start(char, {
			duration   = self.Lifetime or 0.2,
			hyperArmor = self.HyperArmor,
			iFrames    = self.IFrames
		})

		-- Animation (only if set in cfg)
		if self.AnimationId then
			local hum = char and char:FindFirstChildOfClass("Humanoid")
			if hum then
				local anim = Instance.new("Animation")
				anim.AnimationId = self.AnimationId
				hum:LoadAnimation(anim):Play()
			end
		end

		-- Hitbox params
		local lifetime     = self.Lifetime or 0.2
		local oneShot      = (self.OneShot ~= false)
		local destroyOnHit = (self.DestroyOnHit or oneShot)

		local linkedParts = {}
		if type(self.LinkedParts) == "function" then
			linkedParts = self.LinkedParts(extra)
		elseif type(self.LinkedParts) == "table" then
			linkedParts = self.LinkedParts
		end

		local ignoreList = {}
		if char then table.insert(ignoreList, char) end
		if typeof(extra) == "Instance" then
			table.insert(ignoreList, extra) -- ignore the projectile itself
		end
		if self.IgnoreList then
			for _, inst in ipairs(self.IgnoreList) do table.insert(ignoreList, inst) end
		end

		-- On-hit, we re-check “mounted” (covers long-running hitboxes if rider mounts mid-flight)
		local function onHit(targetChar: Model)
			if player and (not node.AllowWhileMounted) and isMountedPlayer(player) then
				if MOUNT_DEBUG then

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeManager.lua -----
-- NodeManager.lua (ReplicatedStorage)
-- Maps player -> { nodeName -> nodeModule } and loads only allowed + unlocked nodes
-- Public API: LoadUnlocked, RefreshFromProfile, GetNode, GetAll, AddUnlock, RemoveUnlock, Unload
-- NOW: Mount-safe. Any function on a node is blocked while the caller is Mounted.

local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local Players             = game:GetService("Players")
local NodeModulesFolder   = ReplicatedStorage:WaitForChild("NodeModules")

local NodeManager = {}
local active = {} -- [player] = { [nodeName] = wrappedNodeTable }
NodeManager._playerNodes = active -- for debugging/inspection only

-- ========== Mounted gate wrappers (hard mode: wrap ANY function on the node) ==========
-- weak caches to avoid re-wrapping
local __wrapCache = setmetatable({}, { __mode = "k" })  -- original node tbl -> proxy
local __fnCache   = setmetatable({}, { __mode = "k" })  -- per node: key -> wrapped fn

local function resolvePlayerFromArgs(...)
	-- Supports both call shapes you use:
	--   node.OnStart(player, dir)
	--   node.Execute(player, dir)
	--   node:Execute(rootPart, dir)  -- method form; self in slot 1, BasePart in slot 2
	local a1, a2 = ...
	if typeof(a1) == "Instance" and a1:IsA("Player") then
		return a1
	end
	if typeof(a2) == "Instance" and a2:IsA("BasePart") then
		local char = a2:FindFirstAncestorOfClass("Model")
		if char then return Players:GetPlayerFromCharacter(char) end
	end
	return nil
end

local function isMountedPlayer(player)
	if not player then return false end
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

local function guardFunc(nodeTbl, key, fn)
	-- cache wrapper per (node, key)
	local nodeCache = __fnCache[nodeTbl]
	if not nodeCache then nodeCache = {}; __fnCache[nodeTbl] = nodeCache end
	local cached = nodeCache[key]
	if cached then return cached end

	local wrapped = function(...)
		local plr = resolvePlayerFromArgs(...)
		if isMountedPlayer(plr) then
			-- Uncomment if you want logs:
			-- warn(("[NodeManager] BLOCKED while mounted  node=%s fn=%s"):format(tostring(nodeTbl.Name or key or "?"), tostring(key)))
			return
		end
		return fn(...)
	end
	nodeCache[key] = wrapped
	return wrapped
end

-- Proxy that guards ANY callable; preserves table semantics
local function wrapNodeForMounted(nodeTbl)
	if type(nodeTbl) ~= "table" then return nodeTbl end
	local existing = __wrapCache[nodeTbl]
	if existing then return existing end

	local proxy = setmetatable({}, {
		__index = function(_, k)
			local v = nodeTbl[k]
			if type(v) == "function" then
				return guardFunc(nodeTbl, k, v)
			elseif type(v) == "table" then
				-- If subtable contains callables, they’ll be guarded on access too (via __index again)
				return v
			else
				return v
			end
		end,
		__newindex = function(_, k, v)
			nodeTbl[k] = v  -- allow nodes to mutate themselves
		end,
		__pairs  = function() return pairs(nodeTbl) end,
		__ipairs = function() return ipairs(nodeTbl) end,
	})

	__wrapCache[nodeTbl] = proxy
	return proxy
end
-- ===============================================================================

-- ---------- ALLOWLIST (cached from RS/Unlockables + defaults mirror) ----------
local DEFAULTS = { "Punch", "Heavy", "Dodge", "BlockStart", "BlockEnd" }
local ALLOWED

local function refreshAllowed()
	local t = {}
	local folder = ReplicatedStorage:FindFirstChild("Unlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				t[sv.Value] = true
			end
		end
	end
	for _, def in ipairs(DEFAULTS) do t[def] = true end
	ALLOWED = t
end

local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end

local unlockFolder = ReplicatedStorage:FindFirstChild("Unlockables")
if unlockFolder then
	unlockFolder.ChildAdded:Connect(refreshAllowed)
	unlockFolder.ChildRemoved:Connect(refreshAllowed)
end

-- ---------- utils ----------

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeSense.lua -----
-- NodeSense.lua
-- Central telemetry bus for node intent/outcomes.
-- Server fires a BindableEvent for AI; optional RemoteEvent for tester HUDs.
-- Tags are simple booleans (not CollectionService tags).

local RunService = game:GetService("RunService")
local Players    = game:GetService("Players")
local RS         = game:GetService("ReplicatedStorage")

local NodeSense = {}

---------------------------------------------------------------------
-- Debug toggles
---------------------------------------------------------------------
NodeSense._debug = true           -- 🔊 default ON per your request
NodeSense._debugDedup = true      -- also log when a message is skipped by dedupe

function NodeSense.SetDebug(on)
	NodeSense._debug = (on == nil) and true or (on and true or false)
end

function NodeSense.SetDebugDedup(on)
	NodeSense._debugDedup = (on == nil) and true or (on and true or false)
end

local function fmtTags(t)
	if typeof(t) ~= "table" then return "" end
	local list = {}
	for k, v in pairs(t) do if v then table.insert(list, tostring(k)) end end
	table.sort(list)
	return table.concat(list, ",")
end

local function pick(ctx, keys)
	if typeof(ctx) ~= "table" then return "" end
	local parts = {}
	for _, k in ipairs(keys) do
		local v = rawget(ctx, k)
		if v ~= nil then table.insert(parts, (k .. "=" .. tostring(v))) end
	end
	return table.concat(parts, " ")
end

---------------------------------------------------------------------
-- Internals
---------------------------------------------------------------------
local function shallowClone(t)
	local c = {}
	if typeof(t) == "table" then
		for k, v in pairs(t) do c[k] = v end
	end
	return c
end

local function tryFreeze(t)
	pcall(function() table.freeze(t) end)
	return t
end

-- Dedup to avoid spam (same actor+node+shot/outcome burst)
NodeSense._dedupeWindowSec   = 0.05
NodeSense._recentKeys        = {}   -- key -> expiry os.clock()
NodeSense._recentMaxEntries  = 256
NodeSense._nextPruneAt       = 0

-- Server-side handles
NodeSense._serverEvent   = nil      -- BindableEvent
NodeSense.ServerEvent    = nil      -- alias for consumers
NodeSense._remoteEvent   = nil      -- RemoteEvent (optional debug)
NodeSense._clientBroadcastEnabled = false
NodeSense._clientFilter  = nil      -- function(player, payload) -> bool

-- Ensure the global RemoteEvent exists (server only, created on demand)
local function ensureRemoteEvent()
	if not RunService:IsServer() then return nil end
	local folder = RS:FindFirstChild("RemoteEvents")
	if not folder then
		folder = Instance.new("Folder")
		folder.Name = "RemoteEvents"
		folder.Parent = RS
	end
	local re = folder:FindFirstChild("NodeSense")
	if not re then
		re = Instance.new("RemoteEvent")
		re.Name = "NodeSense"
		re.Parent = folder
	end
	return re
end

-- Normalize actor (Player or Character or any descendant)
local function normalizeActor(actor)
	local player, model

	if typeof(actor) == "Instance" then
		if actor:IsA("Player") then
			player = actor
			model = player.Character
		elseif actor:IsA("Model") then
			model = actor
			player = Players:GetPlayerFromCharacter(model)
		else
			model = actor:FindFirstAncestorOfClass("Model")
			if model then player = Players:GetPlayerFromCharacter(model) end
		end
	end

	return player, model
end

local function buildKey(actorUserId, actorName, nodeName, shotIndex, outcome)
	local who = actorUserId and ("U" .. tostring(actorUserId)) or ("N" .. tostring(actorName or "?"))
	return table.concat({
		who,
		tostring(nodeName or "?"),
		tostring(shotIndex or "-"),
		tostring(outcome or "start")
	}, "|")
end


----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\ParryService.lua -----
---------------------------------------------------------------------
-- ParryService  (ReplicatedStorage)
-- • Block input calls OpenWindow(player[, duration]) → opens a parry window.
-- • If the defender is struck during the window, Try(attacker, defender)
--   returns true, stuns attacker, ends defender’s block, and grants brief
--   invulnerability via IFrameStore.
--
-- NodeSense emits (telemetry only; no "Parried" here):
--   ParryWindowStart   { duration }
--   ParryWindowRefresh { added, remaining }
--   ParryWindowEnd     { reason = "Consumed" | "Timeout" | "Clear" }
---------------------------------------------------------------------
local ParryService = {}

------------------------------ SERVICES
local RS               = game:GetService("ReplicatedStorage")
local Players          = game:GetService("Players")

local StunService      = require(RS:WaitForChild("StunService"))
local GuardService     = require(RS:WaitForChild("GuardService"))
local IFrameStore      = require(RS:WaitForChild("IFrameStore"))
local NodeSense        = require(RS:WaitForChild("NodeSense"))

------------------------------ CONFIG
local DEFAULT_WINDOW = 0.3   -- parry timing window (sec)
local PARRY_STUN     = 2.5   -- stun applied to attacker (sec)
local IMMUNITY_TIME  = 1.0   -- defender i-frames after parry (sec)

------------------------------ STATE
-- [defender] = expiry tick()
local windowExpires = {}
-- [defender] = expiry tick()
local immunity      = {}

------------------------------ HELPERS
local function asInstance(ent)
	if typeof(ent) == "Instance" then
		return ent
	elseif typeof(ent) == "table" and typeof(ent.Character) == "Instance" then
		return ent.Character
	end
	return nil
end

local function emit(actor, outcome, ctx)
	pcall(function()
		NodeSense.EmitOutcome(actor, "Parry", outcome, ctx or {})
	end)
end

------------------------------ API
function ParryService.OpenWindow(defender, duration)
	if not defender then return end
	local now = tick()
	local dur = tonumber(duration) or DEFAULT_WINDOW
	local prev = windowExpires[defender] or 0
	local wasActive = prev > now

	local newExp = now + dur
	windowExpires[defender] = newExp

	if wasActive then
		emit(defender, "ParryWindowRefresh", {
			added     = dur,
			remaining = newExp - now,
		})
	else
		emit(defender, "ParryWindowStart", { duration = dur })
	end

	-- schedule end (only ends if expiry wasn't extended)
	local thisExp = newExp
	task.delay(dur, function()
		if windowExpires[defender] == thisExp and thisExp <= tick() then
			windowExpires[defender] = nil
			emit(defender, "ParryWindowEnd", { reason = "Timeout" })
		end
	end)
end

function ParryService.IsActive(defender)
	return (windowExpires[defender] or 0) > tick()
end

function ParryService.HasImmunity(ent)
	return (immunity[ent] or 0) > tick()
end

-- Optional manual clear (e.g., player released block early)
function ParryService.ClearWindow(defender)
	if not defender then return false end
	if not ParryService.IsActive(defender) then return false end
	windowExpires[defender] = nil
	emit(defender, "ParryWindowEnd", { reason = "Clear" })
	return true
end

-- Returns true on successful parry; false otherwise.
function ParryService.Try(attacker, defender)
	if not ParryService.IsActive(defender) then return false end

	-- consume window
	windowExpires[defender] = nil
	emit(defender, "ParryWindowEnd", { reason = "Consumed" })

	-----------------------------------------------------------------
	-- punish attacker
	-----------------------------------------------------------------
	local inst = asInstance(attacker)
	if inst then
		StunService.Apply(inst, PARRY_STUN)
	end

	-----------------------------------------------------------------
	-- defender: end block + grant brief i-frames (invulnerability)
	-----------------------------------------------------------------
	GuardService.EndBlock(defender)
	IFrameStore.Grant(defender, IMMUNITY_TIME, "Parry")
	immunity[defender] = tick() + IMMUNITY_TIME


----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\RigMadLibs.lua -----
-- ReplicatedStorage/RigMadLibs.lua
local Players       = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local Debris        = game:GetService("Debris")

local M = {}

local function getHumanoid(rig)
	return rig and rig:FindFirstChildOfClass("Humanoid")
end

local function ensureEnemiesFolder()
	local f = ServerStorage:FindFirstChild("Enemies")
	assert(f, "Put your enemy prefabs in ServerStorage/Enemies")
	return f
end

local function asCSV(list)
	if not list or #list == 0 then return "" end
	local out = {}
	for _, id in ipairs(list) do table.insert(out, tostring(id)) end
	return table.concat(out, ",")
end

-- === SKINNING HELPERS ===
function M.applyUserLook(rig: Model, userId: number)
	local hum = getHumanoid(rig); if not hum then return false end
	local ok, desc = pcall(Players.GetHumanoidDescriptionFromUserId, Players, userId)
	if ok and desc then hum:ApplyDescription(desc); return true end
	return false
end

function M.applyOutfit(rig: Model, outfitId: number)
	local hum = getHumanoid(rig); if not hum then return false end
	local ok, desc = pcall(Players.GetHumanoidDescriptionFromOutfitId, Players, outfitId)
	if ok and desc then hum:ApplyDescription(desc); return true end
	return false
end

-- assets = { shirt=, pants=, face=, hats={}, hair={}, back={}, faceAcc={}, neck={}, front={}, shoulder={}, waist={} }
function M.applyAssets(rig: Model, assets: table)
	local hum = getHumanoid(rig); if not hum then return false end
	local desc = Instance.new("HumanoidDescription")

	-- Classic clothing / face (optional)
	if assets.shirt then desc.Shirt = assets.shirt end
	if assets.pants then desc.Pants = assets.pants end
	if assets.face  then desc.Face  = assets.face end

	-- Accessories (comma-separated strings of asset IDs)
	if assets.hats     then desc.HatAccessory       = asCSV(assets.hats) end
	if assets.hair     then desc.HairAccessory      = asCSV(assets.hair) end
	if assets.back     then desc.BackAccessory      = asCSV(assets.back) end
	if assets.faceAcc  then desc.FaceAccessory      = asCSV(assets.faceAcc) end
	if assets.neck     then desc.NeckAccessory      = asCSV(assets.neck) end
	if assets.front    then desc.FrontAccessory     = asCSV(assets.front) end
	if assets.shoulder then desc.ShoulderAccessory  = asCSV(assets.shoulder) end
	if assets.waist    then desc.WaistAccessory     = asCSV(assets.waist) end

	hum:ApplyDescription(desc)
	return true
end

-- === SPAWN/PREVIEW ===
-- look = { userId = n } OR { outfitId = n } OR { assets = {...} } OR nil
function M.spawn(prefabName: string, parent: Instance?, cf: CFrame?, look: table?)
	local enemies = ensureEnemiesFolder()
	local template = enemies:FindFirstChild(prefabName)
	assert(template, ("Prefab not found: %s in ServerStorage/Enemies"):format(prefabName))

	local rig = template:Clone()
	if cf then rig:PivotTo(cf) end
	rig.Parent = parent or workspace

	if look then
		if look.userId then M.applyUserLook(rig, look.userId)
		elseif look.outfitId then M.applyOutfit(rig, look.outfitId)
		elseif look.assets then M.applyAssets(rig, look.assets)
		end
	end
	return rig
end

-- opts = { anchor=true, autoclean=seconds, nameSuffix="Preview" }
function M.preview(prefabName: string, cf: CFrame?, look: table?, opts: table?)
	opts = opts or {}
	local rig = M.spawn(prefabName, workspace, cf or CFrame.new(0,5,0), look)
	rig.Name = (opts.nameSuffix or "Preview") .. "_" .. prefabName

	local hrp = rig:FindFirstChild("HumanoidRootPart")
	if hrp and (opts.anchor ~= false) then hrp.Anchored = true end

	if tonumber(opts.autoclean) then Debris:AddItem(rig, opts.autoclean) end
	return rig
end

function M.clearPreviews(prefix: string?)
	prefix = prefix or "Preview_"
	for _, m in ipairs(workspace:GetChildren()) do
		if m:IsA("Model") and m.Name:sub(1, #prefix) == prefix then
			m:Destroy()
		end
	end
end

return M

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\SpeedController.lua -----
-- ReplicatedStorage/SpeedController.lua
local SpeedController = {}

-- Key by Humanoid (works for players & NPCs). Weak refs so old humanoids GC.
local activeTimers    = setmetatable({}, { __mode = "k" })
local originalSpeeds  = setmetatable({}, { __mode = "k" })

local function resolveHumanoid(actor)
	if not actor then return nil end
	if typeof(actor) == "Instance" then
		if actor:IsA("Player") then
			local char = actor.Character
			return char and char:FindFirstChildOfClass("Humanoid")
		elseif actor:IsA("Model") then
			return actor:FindFirstChildOfClass("Humanoid")
		elseif actor:IsA("Humanoid") then
			return actor
		end
	end
	return nil
end

function SpeedController.Apply(actor, newSpeed, duration)
	local hum = resolveHumanoid(actor)
	if not hum then return end

	-- store original once per humanoid
	if originalSpeeds[hum] == nil then
		originalSpeeds[hum] = hum.WalkSpeed
	end

	-- clear previous timer for this humanoid
	if activeTimers[hum] then
		task.cancel(activeTimers[hum])
		activeTimers[hum] = nil
	end

	-- apply new speed
	hum.WalkSpeed = newSpeed

	-- optional timed reset
	local dur = tonumber(duration) or 0
	if dur > 0 then
		activeTimers[hum] = task.delay(dur, function()
			if hum.Parent then
				hum.WalkSpeed = originalSpeeds[hum] or 16
			end
			activeTimers[hum]   = nil
			originalSpeeds[hum] = nil
		end)
	end
end

function SpeedController.Reset(actor)
	local hum = resolveHumanoid(actor)
	if not hum then return end

	if originalSpeeds[hum] ~= nil then
		hum.WalkSpeed = originalSpeeds[hum]
	end
	if activeTimers[hum] then
		task.cancel(activeTimers[hum])
		activeTimers[hum] = nil
	end
	originalSpeeds[hum] = nil
end

return SpeedController

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\StunService.lua -----
-- ReplicatedStorage/StunService
-- Hard stun = lock + physics freeze + attack interrupt.
-- Soft stun = slow only (no lock), guaranteed restore for NPC Models.
-- No use of Instance:GetAttribute; invincibility is:
--   • players: IFrameStore.IsActive(player)
--   • models:  optional BoolValue child named "Invincible" set true

local StunService = {}

------------------------------ Deps
local RS        = game:GetService("ReplicatedStorage")
local Players   = game:GetService("Players")

local CombatState        = require(RS:WaitForChild("CombatState"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local SpeedController    = require(RS:WaitForChild("SpeedController"))

-- Optional client FX
local RemoteEvents = RS:FindFirstChild("RemoteEvents")
local StunToggle   = RemoteEvents and RemoteEvents:FindFirstChild("StunToggle")

------------------------------ State
local hardEndAt       = {}   -- [entity] = os.clock() deadline
local softEndAt       = {}   -- [entity] = os.clock() deadline
local lockedByStun    = {}   -- [entity] = true if we locked
local activeTracks    = {}   -- [entity] = AnimationTrack
local savedPhys       = {}   -- [entity] = { JumpPower, AutoRotate, PlatformStand }
-- Model baselines for soft-stun restore (weak keys)
local modelBaselineWS = setmetatable({}, { __mode = "k" }) -- [Model] = base WalkSpeed


-- NPC-only slow management (players use SpeedController)
local modelOrigSpeed  = setmetatable({}, { __mode = "k" }) -- [Model] = number
local modelSlowTimer  = setmetatable({}, { __mode = "k" }) -- [Model] = thread
local slowedByStun    = setmetatable({}, { __mode = "k" }) -- [Player] = true

------------------------------ Helpers
local function isInstance(x) return typeof(x) == "Instance" end

local function asModel(ent)
	if not isInstance(ent) then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model")  then return ent end
	return nil
end

local function getHumanoid(ent)
	local mdl = asModel(ent)
	return mdl and mdl:FindFirstChildOfClass("Humanoid") or nil
end

local function rootOf(ent)
	local mdl = asModel(ent)
	return mdl and mdl:FindFirstChild("HumanoidRootPart") or nil
end

local function clamp(x, a, b) return math.max(a, math.min(b, x)) end
local function now() return os.clock() end

local function safeEmitToggle(ent, on)
	if StunToggle and ent and ent:IsA("Player") then
		pcall(function() StunToggle:FireClient(ent, on) end)
	end
end

-- No attributes: prefer IFrameStore for players; for NPCs allow a BoolValue named "Invincible"
local function isInvincible(ent)
	if not isInstance(ent) then return false end

	if ent:IsA("Player") then
		return IFrameStore.IsActive(ent) == true
	end

	local mdl = asModel(ent)
	if not mdl then return false end
	local flag = mdl:FindFirstChild("Invincible")
	return (flag and flag:IsA("BoolValue") and flag.Value) == true
end
local function modelOf(ent)
	if ent and ent:IsA("Player") then return ent.Character end
	return ent
end

local function ensureBaselineWS(mdl, hum)
	-- If we don't have a baseline, compute a safe one.
	if not modelBaselineWS[mdl] then
		local ws = hum.WalkSpeed
		if ws < 10 or ws > 30 then ws = 16 end
		modelBaselineWS[mdl] = ws
	end
	return modelBaselineWS[mdl]
end

------------------------------ Internal clears
local function clearHard(ent)
	hardEndAt[ent] = nil

	if lockedByStun[ent] then
		CombatState.Unlock(ent, "Stun:HardClear")
		lockedByStun[ent] = nil
	end

	local hum = getHumanoid(ent)
	local s   = savedPhys[ent]
	if hum and s then
		hum.JumpPower     = s.JumpPower
		hum.AutoRotate    = s.AutoRotate
		hum.PlatformStand = s.PlatformStand
	end
	savedPhys[ent] = nil

	local track = activeTracks[ent]
	if track then pcall(function() track:Stop() end) end
	activeTracks[ent] = nil

	safeEmitToggle(ent, false)
end

local function clearSoft(ent)

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\AI\Attention.lua -----

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\AI\Blackboard.lua -----
-- ReplicatedStorage/AI/Blackboard.lua
-- TTL flags per target (blocking, parryWindow, dodgeActive, incoming tags, etc.)
local Blackboard = {}
Blackboard.__index = Blackboard

local function now() return os.clock() end

function Blackboard.new()
	return setmetatable({
		flags = {},   -- name -> { value=any, expires=number|nil }
	}, Blackboard)
end

function Blackboard:set(name, value, ttl)
	local e = ttl and (now() + ttl) or nil
	self.flags[name] = { value = value, expires = e }
end

function Blackboard:touch(name, ttl)
	local slot = self.flags[name]
	if not slot then return end
	if ttl then slot.expires = now() + ttl end
end

function Blackboard:get(name)
	local slot = self.flags[name]
	if not slot then return nil end
	if slot.expires and slot.expires <= now() then
		self.flags[name] = nil
		return nil
	end
	return slot.value
end

function Blackboard:clear(name) self.flags[name] = nil end

return Blackboard

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\AI\EnemyController.lua -----
-- ReplicatedStorage/AI/EnemyController.lua
local Players     = game:GetService("Players")
local RS          = game:GetService("ReplicatedStorage")
local RunService  = game:GetService("RunService")

local Attention   = require(RS:WaitForChild("AI"):WaitForChild("Attention"))
local Blackboard  = require(RS:WaitForChild("AI"):WaitForChild("Blackboard"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))

-- Optional NodeLibrary adapter
local NL
do
	local libScript = game.ServerScriptService:FindFirstChild("NodeLibrary") or RS:FindFirstChild("NodeLibrary")
	if libScript then NL = require(libScript) end
end

-- === Moves (with NPC dodge fallback) ========================================
local Moves = {}

local function _charOf(actor)
	if typeof(actor) == "Instance" and actor:IsA("Model") then return actor end
	if typeof(actor) == "Instance" and actor:IsA("Player") then return actor.Character end
	return nil
end
local function _hrpOf(m) return m and m:FindFirstChild("HumanoidRootPart") end

function Moves.M1(actor)              if NL and NL.Punch      then NL.Punch(actor)          end end
function Moves.Heavy(actor)           if NL and NL.Heavy      then NL.Heavy(actor)          end end
function Moves.BlockStart(actor)      if NL and NL.BlockStart then NL.BlockStart(actor)      end end
function Moves.BlockEnd(actor)        if NL and NL.BlockEnd   then NL.BlockEnd(actor)        end end
function Moves.Revolver(actor, dir)   if NL and NL.Revolver   then NL.Revolver(actor, dir)   end end

-- Fallback Dodge: simple BodyVelocity burst (movement only; no iframes)
local function _fallbackDodgeBurst(actor, dirVec, dur)
	local ch  = _charOf(actor)
	local hrp = _hrpOf(ch)
	if not hrp then return end
	local dir = (dirVec and dirVec.Magnitude > 0) and dirVec.Unit or hrp.CFrame.LookVector
	local bv  = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(1e5, 0, 1e5)
	bv.P        = 1250
	bv.Velocity = dir * 50
	bv.Parent   = hrp
	task.delay(dur or 0.20, function() if bv then bv:Destroy() end end)
end

-- If NL expects a Player, pass it; otherwise pass the actor through.
local function _actorForNL(actor)
	if typeof(actor) == "Instance" and actor:IsA("Model") then
		return Players:GetPlayerFromCharacter(actor) or actor
	end
	return actor
end

-- Only skip fallback when NL.Dodge returns true explicitly.
function Moves.Dodge(actor, dirVec)
	if NL and NL.Dodge then
		local a = _actorForNL(actor)
		local ok, res = pcall(NL.Dodge, a, dirVec)
		if ok and res == true then
			return true
		end
	end
	_fallbackDodgeBurst(actor, dirVec, 0.22)
	return true
end

function Moves.DodgeAway(actorModel, fromPos)
	local hrp = actorModel and actorModel:FindFirstChild("HumanoidRootPart")
	if hrp and fromPos then
		local away = (hrp.Position - fromPos)
		if away.Magnitude > 0 then
			return Moves.Dodge(actorModel, away.Unit)
		end
	end
	return Moves.Dodge(actorModel)
end

-- === Controller =============================================================
local Controller = {}
Controller.__index = Controller

local function hrpOf(m) return m and m:FindFirstChild("HumanoidRootPart") end
local function humOf(m) return m and m:FindFirstChildOfClass("Humanoid") end
local function dist(a,b) return (a-b).Magnitude end
local function dir(from,to) local v=(to-from) local m=v.Magnitude return m>0 and (v/m) or v end
local function clamp01(x) return math.max(0, math.min(1, x)) end
local function lerp(a,b,t) return a + (b-a) * t end

-- DEF/OFF → timings/weights
local function reactDelayByDEF(def) return lerp(0.35, 0.06, clamp01(def/100)) end
local function blockProbByDEF(def)  return lerp(0.25, 0.95, clamp01(def/100)) end
local function dodgeProbByDEF(def)  return lerp(0.20, 0.90, clamp01(def/100)) end
local function tempoGapByOFF(off)   return lerp(0.60, 0.15, clamp01(off/100)) end
local function comboLenByOFF(off)   return math.floor(lerp(2, 5, clamp01(off/100)) + 0.5) end

local DEBUG = false
local function log(...) if DEBUG then print("[EnemyController]", ...) end end

-- === NodeSense → flags =======================================================
local function setIncoming(self, what, ttl) self.board:set(what, true, ttl or 0.6) end
local function clearIncoming(self)
	self.board:set("incomingHeavy",        false, 0.2)
	self.board:set("incomingUnblockable",  false, 0.2)
	self.board:set("incomingBlockable",    false, 0.2)
	self.board:set("incomingParryable",    false, 0.2)
	self.board:set("rangedThreat",         false, 0.2)
end

-- Treat any “breaks block” as an unblockable-level danger for dodge logic.
local function interpretIntent(self, node, tags, closeEnough)
	if not closeEnough then return end
	local lower = (node or "Unknown"):lower()
	if tags and next(tags) then
		if tags.Unblockable then setIncoming(self, "incomingUnblockable", 0.8) end
		if tags.Heavy       then setIncoming(self, "incomingHeavy", 0.8) end
		if tags.Ranged or tags.Projectile then setIncoming(self, "rangedThreat", 0.8) end
		if tags.BreaksBlock or tags.GuardBreak or tags.ShieldBreak then
			setIncoming(self, "incomingUnblockable", 0.8)
		end

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\Horses\Default.lua -----

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\BlockEnd.lua -----
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))

local NL = require(game.ServerScriptService:FindFirstChild("NodeLibrary")
	or RS:FindFirstChild("NodeLibrary"))

local BlockEnd = NodeFactory.Create{
	Name        = "BlockEnd",
	Keybind     = Enum.KeyCode.Unknown,
	Cooldown    = 0,
	Radius      = 0.1,
	Damage      = 0,
	GuardDamage = 0,
	Stun        = 0,
}

if NL and NL.BlockEnd then
	BlockEnd.OnStart = function(player, ...)
		-- No NodeSense intent here: GuardService.EndBlock will emit "BlockEnd".
		return NL.BlockEnd(player, ...)
	end
end

return BlockEnd

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\BlockStart.lua -----
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))

local NL = require(game.ServerScriptService:FindFirstChild("NodeLibrary")
	or RS:FindFirstChild("NodeLibrary"))

local BlockStart = NodeFactory.Create{
	Name        = "BlockStart",
	Keybind     = Enum.KeyCode.Unknown,
	Cooldown    = 0,
	Radius      = 0.1,
	Damage      = 0,
	GuardDamage = 0,
	Stun        = 0,
}

if NL and NL.BlockStart then
	BlockStart.OnStart = function(player, ...)
		-- Intent ping so AI sets targetBlocking immediately.
		local tags = NodeSense.CollectTags(BlockStart, {
			Defensive = true,
			Block     = true,
		})
		NodeSense.Emit(player, "Block", tags, {
			nodeName = "Block",
		})

		return NL.BlockStart(player, ...)
	end
end

return BlockStart

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\Dodge.lua -----
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(game.ReplicatedStorage.NodeFactory)
local NodeSense   = require(RS:WaitForChild("NodeSense"))

local NL = require(game.ServerScriptService:FindFirstChild("NodeLibrary")
	or RS:FindFirstChild("NodeLibrary"))

local Dodge = NodeFactory.Create{
	Name        = "Dodge",
	Keybind     = Enum.KeyCode.Unknown,
	Cooldown    = 0,
	Radius      = 0.1,
	Damage      = 0,
	GuardDamage = 0,
	Stun        = 0,
}

if NL and NL.Dodge then
	Dodge.OnStart = function(player, ...)
		-- Intent ping so AI recognizes an incoming evade/i-frame action.
		local tags = NodeSense.CollectTags(Dodge, {
			Defensive = true,
			Dodge     = true,
			IFrame    = true,
			Evade     = true,
		})

		NodeSense.Emit(player, "Dodge", tags, {
			nodeName = "Dodge",
			-- duration can be inferred later from IFrameStore if needed
		})

		return NL.Dodge(player, ...)
	end
end

return Dodge

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\Gallop.lua -----
-- ReplicatedStorage/NodeModules/Gallop.lua
-- Hidden passive unlock used as a durable flag via PlayerDataService.
-- Not clickable, not on hotbar; just marks that the player owns Gallop.
local M = {
	Name = "Gallop",
	Passive = true,
	Hidden = true,          -- NodeManager should ignore it in UI
	AllowWhileMounted = true,
}
function M.OnStart(player)
	-- No direct activation; server HorseMountServer handles it.
	return false
end
return M

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\Heavy.lua -----
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))
local Facts       = require(RS:WaitForChild("CardinalFacts"))

local NL
do
	local s = (game.ServerScriptService:FindFirstChild("NodeLibrary") or RS:FindFirstChild("NodeLibrary"))
	if s then NL = require(s) end
end

local Heavy = NodeFactory.Create{
	Name   = "Heavy",
	Radius = 0.1,          -- satisfy NodeFactory assert; not used for telemetry
}

if NL and NL.Heavy then
	Heavy.OnStart = function(actor, ...)
		local f = Facts.Heavy
		NodeSense.EmitWithDef(actor, f, { Attack = true }, {
			nodeName    = "Heavy",
			damage      = f.Damage,
			guardDamage = f.GuardDamage,
			stun        = f.Stun,
			kbForce     = f.KnockbackForce,
		})
		return NL.Heavy(actor, ...)
	end
end

return Heavy

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\Punch.lua -----
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))
local Facts       = require(RS:WaitForChild("CardinalFacts"))

local NL
do
	local s = (game.ServerScriptService:FindFirstChild("NodeLibrary") or RS:FindFirstChild("NodeLibrary"))
	if s then NL = require(s) end
end

local Punch = NodeFactory.Create{
	Name   = "Punch",
	Radius = 0.1,          -- satisfy NodeFactory assert; not used for telemetry
}

if NL and NL.Punch then
	Punch.OnStart = function(actor, ...)
		local f = Facts.Punch
		NodeSense.EmitWithDef(actor, f, { Attack = true }, {
			nodeName    = "Punch",
			damage      = f.Damage,
			guardDamage = f.GuardDamage,
			stun        = f.Stun,
		})
		return NL.Punch(actor, ...)
	end
end

return Punch

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\Revolver.lua -----
--------------------------------------------------------------------
-- NodeModules/Revolver.lua (lock + interrupt aware, with prop fallback)
-- NodeFactory-driven revolver
-- Obeys CombatState.IsLocked and AttackStateService interruption.
--------------------------------------------------------------------
local RS      = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris  = game:GetService("Debris")

local NodeFactory        = require(RS:WaitForChild("NodeFactory"))
local CooldownService    = require(RS:WaitForChild("CooldownService"))
local CombatState        = require(RS:WaitForChild("CombatState"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local NodeSense          = require(RS:WaitForChild("NodeSense"))

local RemoteEvents   = RS:WaitForChild("RemoteEvents")
local CooldownNotice = RemoteEvents:WaitForChild("CooldownNotice")

--------------------------------------------------------------------
-- CONFIG
--------------------------------------------------------------------
local SHOT_COUNT        = 4
local SHOT_INTERVAL     = 0.2
local FIRST_SHOT_DELAY  = 0.2

local BULLET_SPEED      = 150
local BULLET_LIFETIME   = 15
local VIS_SIZE          = 0.2
local HIT_RADIUS        = 1

local COOLDOWN_TIME     = 15
local ANIM_ID           = "rbxassetid://95110526176115"

-- side offset (studs) so it appears from right hand side
local SIDE_OFFSET       = 1

-- Optional: name/path for gun prop template
local GUN_PROP_NAME     = "GunProp"

--------------------------------------------------------------------
-- Helpers: lock/interrupt gates
--------------------------------------------------------------------
local function isInterrupted(player: Player?, char: Model?): boolean
	-- 1) Global move lock (horse/combat lock, etc.)
	if player and CombatState and CombatState.IsLocked and CombatState.IsLocked(player) then
		return true
	end

	-- 2) AttackStateService interruption
	if AttackStateService and type(AttackStateService.IsInterrupted) == "function" then
		local ok, res = pcall(AttackStateService.IsInterrupted, player) -- use player, not char
		if ok and res then return true end
	end

	-- 3) Lightweight fallbacks
	if char then
		if char:GetAttribute("Interrupted") or char:GetAttribute("Stunned") then
			return true
		end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Health <= 0 then return true end
			local st = hum:GetState()
			if st == Enum.HumanoidStateType.Dead
				or st == Enum.HumanoidStateType.Ragdoll
				or st == Enum.HumanoidStateType.FallingDown then
				return true
			end
		end
	end

	return false
end

--------------------------------------------------------------------
-- Node definition
--------------------------------------------------------------------
local RevolverNode = NodeFactory.Create({
	Name             = "Revolver",

	UseMovingHitbox  = true,
	Radius           = HIT_RADIUS,
	Lifetime         = 10,   -- hitbox lifetime per bullet (not the visual)
	OneShot          = true,
	DestroyOnHit     = true,

	GetCFrame        = function(bullet) return bullet.CFrame end,
	LinkedParts      = function(bullet) return { bullet } end,

	Damage           = 5,
	GuardDamage      = 10,
	Parryable        = true,

	Stun             = 0.1,
	KnockbackForce   = 20,

	Cooldown         = 0    -- module handles its own cooldown gating
})

local module = {}

--------------------------------------------------------------------
-- Gun prop resolution + attach/detach
--------------------------------------------------------------------
local function resolveGunPropTemplate(): Instance?
	-- 1) Direct child
	local m = RS:FindFirstChild(GUN_PROP_NAME)
	if m and m:IsA("Model") then return m end

	-- 2) Common folders
	for _, folderName in ipairs({ "Props", "Assets", "Models" }) do
		local f = RS:FindFirstChild(folderName)
		if f then
			local c = f:FindFirstChild(GUN_PROP_NAME)
			if c and c:IsA("Model") then return c end
		end
	end

	-- 3) Deep search (one-time, cheap enough)
	for _, d in ipairs(RS:GetDescendants()) do

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\NodeModules\SummonHorse.lua -----
-- ReplicatedStorage/NodeModules/SummonHorse.lua
-- Toggle summon/dismiss, unlock + cooldown gated.

local RS  = game:GetService("ReplicatedStorage")
local SSS = game:GetService("ServerScriptService")

local CooldownService = require(RS:WaitForChild("CooldownService"))
local HS  = require(SSS:WaitForChild("HorseService"))

local Remotes        = RS:WaitForChild("RemoteEvents")
local ConfirmSuccess = Remotes:FindFirstChild("ConfirmSuccess")
local CooldownNotice = Remotes:FindFirstChild("CooldownNotice")

local NODE_NAME   = "SummonHorse"
local COOLDOWN_S  = 10
local LEFT_OFFSET = 5
local UNLOCK_ATTR = "HasHorse" -- only blocks if explicitly false

local function toast(p, msg)
	if ConfirmSuccess then ConfirmSuccess:FireClient(p, { ok = true, msg = msg }) end
end

local function pushCD(p)
	if CooldownNotice then
		CooldownNotice:FireClient(p, { name = NODE_NAME, duration = COOLDOWN_S, started = os.clock() })
	end
end

local M = { Name = NODE_NAME }

function M.OnStart(player, dirVec)
	-- unlock gate: if attr missing -> allow; if false -> block
	if player:GetAttribute(UNLOCK_ATTR) == false then
		toast(player, "You haven't unlocked your horse yet.")
		return false
	end

	-- cooldown gate
	if not CooldownService.CanUse(player, NODE_NAME) then return false end
	CooldownService.Apply(player, NODE_NAME, COOLDOWN_S)
	pushCD(player)

	local char = player.Character
	local hrp  = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end

	local active = HS.GetActive and HS.GetActive(player)
	if active then
		HS.Despawn(player)
		toast(player, "Dismissed your horse.")
		return true
	else
		local cf = hrp.CFrame * CFrame.new(-LEFT_OFFSET, 0, 0)
		local horse = HS.SummonTo(player, cf)
		if horse then toast(player, "Summoned your horse.") end
		return horse ~= nil
	end
end

return M

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\Stories\Horse_Keeper.lua -----

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\Stories\Hotpants_Start.lua -----

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\Stories\Johnny_Joestar_Start.lua -----

----- C:\Users\James\OneDrive\Documents\GitHub\Steve-Lebron\src\shared\Unlockables\Unlockables.lua -----
-- Unlockables.lua (ServerScriptService)
-- Master list of all unlockable nodes beyond the defaults.
-- Also mirrors them into ReplicatedStorage/Unlockables as StringValues.

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Unlockables = {
	"Revolver",
	"SummonHorse",
	"Gallop", 
	-- add future unlockable moves here...
}

-- Mirror to RS/Unlockables for clients/NodeManager/PlayerDataService
local folder = ReplicatedStorage:FindFirstChild("Unlockables")
if not folder then
	folder = Instance.new("Folder")
	folder.Name = "Unlockables"
	folder.Parent = ReplicatedStorage
end
for _, child in ipairs(folder:GetChildren()) do child:Destroy() end
for _, name in ipairs(Unlockables) do
	local sv = Instance.new("StringValue")
	sv.Name = name
	sv.Value = name
	sv.Parent = folder
end

return Unlockables


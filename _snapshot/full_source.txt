_BEGIN_SOURCE_DUMP_
===== FILE: src/client/StarterGui/ScreenGui/LocalScript.client.lua =====
-- ScreenGui/LocalScript  â€” CLEAN VERSION (no unlock stuff)

---------------- Services ----------------
local Players       = game:GetService("Players")
local Replicated    = game:GetService("ReplicatedStorage")
local TweenService  = game:GetService("TweenService")
local RunService    = game:GetService("RunService")
local StarterGui    = game:GetService("StarterGui")
local UIS           = game:GetService("UserInputService")
local TS            = game:GetService("TweenService")

local player = Players.LocalPlayer
local gui    = script.Parent  -- your existing ScreenGui instance
if gui:IsA("ScreenGui") then
	gui.IgnoreGuiInset = true -- normalize across Studio/live, center math stays true
end

---------------- Menu Pieces (placement only; toggle is at bottom) ----------------
local SmallIcon  = gui:WaitForChild("SmallIcon")
local MenuFrame  = gui:WaitForChild("MenuFrame")

-- small icon: always bottom-right
SmallIcon.AnchorPoint = Vector2.new(1,1)
SmallIcon.Position    = UDim2.new(1, -16, 1, -16) -- margin tweakable

-- menu: centered when open, dumped below screen when closed
MenuFrame.AnchorPoint = Vector2.new(0.5, 0.5)
local OPEN_POS   = UDim2.fromScale(0.5, 0.5)   -- camera/screen center
local CLOSED_POS = UDim2.new(0.5, 0, 1.2, 0)   -- dump below screen
MenuFrame.Position = CLOSED_POS
MenuFrame.Visible  = false

-- global-ish menu state for other blocks
local isMenuOpen = false

----------------------------------------------------------------
--                      HUD: COOLDOWNS (robust clocks + visible)
----------------------------------------------------------------
local RemoteEvents   = Replicated:WaitForChild("RemoteEvents")
local CooldownNotice = RemoteEvents:WaitForChild("CooldownNotice")

-- Toggle this to bypass unlockables filtering for testing
local ONLY_UNLOCKABLES = true

-- Live allow-list from ReplicatedStorage/Unlockables
local UNLOCKABLES_SET = {}
local function refreshUnlockablesClient()
	table.clear(UNLOCKABLES_SET)
	local f = Replicated:FindFirstChild("Unlockables")
	if f then
		for _, sv in ipairs(f:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				UNLOCKABLES_SET[sv.Value] = true
			end
		end
	end
end
refreshUnlockablesClient()
local uf = Replicated:FindFirstChild("Unlockables")
if uf then
	uf.ChildAdded:Connect(refreshUnlockablesClient)
	uf.ChildRemoved:Connect(refreshUnlockablesClient)
end

-- Container (top-right)
local cdContainer = Instance.new("Frame")
cdContainer.Name = "CooldownStack"
cdContainer.AnchorPoint = Vector2.new(1,0)
cdContainer.Position = UDim2.new(1, -12, 0, 12)
cdContainer.Size = UDim2.new(0, 260, 1, -24)
cdContainer.BackgroundTransparency = 1
cdContainer.Visible = false
cdContainer.Parent = gui

local cdList = Instance.new("UIListLayout")
cdList.FillDirection = Enum.FillDirection.Vertical
cdList.HorizontalAlignment = Enum.HorizontalAlignment.Right
cdList.VerticalAlignment = Enum.VerticalAlignment.Top
cdList.SortOrder = Enum.SortOrder.LayoutOrder
cdList.Padding = UDim.new(0, 6)
cdList.Parent = cdContainer

local cdItems = {} -- [name] = {frame,label,bar,endsAtClock,duration}

local function setCdContainerVisible()
	for _ in pairs(cdItems) do
		cdContainer.Visible = true
		return
	end
	cdContainer.Visible = false
end

local function createCdItem(name: string)
	local f = Instance.new("Frame")
	f.Name = name
	f.Size = UDim2.new(0, 260, 0, 34)
	f.BackgroundColor3 = Color3.fromRGB(25,25,25)
	f.BackgroundTransparency = 0.15
	f.BorderSizePixel = 0
	f.Parent = cdContainer

	local title = Instance.new("TextLabel")
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -10, 1, -14)
	title.Position = UDim2.new(0, 10, 0, 2)
	title.Font = Enum.Font.GothamSemibold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextColor3 = Color3.new(1,1,1)
	title.TextScaled = true
	title.Text = name .. ": 0.0s"
	title.Parent = f

	local barBg = Instance.new("Frame")
	barBg.BorderSizePixel = 0
	barBg.BackgroundColor3 = Color3.fromRGB(50,50,50)
	barBg.Size = UDim2.new(1, -12, 0, 4)
	barBg.Position = UDim2.new(0, 6, 1, -6)
	barBg.Parent = f

	local bar = Instance.new("Frame")
	bar.BorderSizePixel = 0
	bar.BackgroundColor3 = Color3.fromRGB(120,200,255)
	bar.Size = UDim2.new(0, 0, 1, 0)
	bar.Parent = barBg

	cdItems[name] = {frame=f, label=title, bar=bar, endsAtClock=0, duration=0}
	setCdContainerVisible()
	return cdItems[name]
end

local function destroyCdItem(name)
	local it = cdItems[name]
	if not it then return end
	if it.frame then it.frame:Destroy() end
	cdItems[name] = nil
	setCdContainerVisible()
end

-- Convert whatever the server sends into "remaining seconds"
local function computeRemaining(payload, duration)
	if payload and tonumber(payload.remaining) then
		return math.max(0, tonumber(payload.remaining))
	end
	if payload and tonumber(payload.endsAtEpoch) then
		return math.max(0, tonumber(payload.endsAtEpoch) - time())
	end
	if payload and tonumber(payload.started) and tonumber(payload.started) > 1e6 then
		return math.max(0, (tonumber(payload.started) + duration) - time())
	end
	return math.max(0, duration)
end

CooldownNotice.OnClientEvent:Connect(function(payload)
	if not payload or not payload.name then
		warn("[Cooldown] Missing payload/name:", payload)
		return
	end

	local name = tostring(payload.name)

	if ONLY_UNLOCKABLES and not UNLOCKABLES_SET[name] then
		warn(("[Cooldown] '%s' ignored (not in Unlockables)."):format(name))
		return
	end

	local duration = tonumber(payload.duration) or 0
	local remaining = computeRemaining(payload, duration)

	local it = cdItems[name] or createCdItem(name)
	it.duration = duration > 0 and duration or math.max(remaining, 0.001)
	it.endsAtClock = os.clock() + remaining  -- convert to client's clock domain

	local r = math.max(0, it.endsAtClock - os.clock())
	it.label.Text = string.format("%s: %.1fs", name, r)
	it.bar.Size   = UDim2.new(1 - (r / it.duration), 0, 1, 0)
	it.frame.LayoutOrder = math.floor(r * 1000)

	print(("[Cooldown] show '%s' for %.2fs (dur=%.2f)"):format(name, r, it.duration))
end)

RunService.RenderStepped:Connect(function()
	local nowClock = os.clock()
	for name, it in pairs(cdItems) do
		local remaining = math.max(0, it.endsAtClock - nowClock)
		local dur = it.duration > 0 and it.duration or 1

		it.label.Text = remaining > 0 and string.format("%s: %.1fs", name, remaining) or (name .. ": READY")
		it.bar.Size   = UDim2.new(1 - (remaining/dur), 0, 1, 0)

		if remaining <= 0 then
			it.bar.BackgroundColor3 = Color3.fromRGB(120,255,170)
		elseif remaining <= 1.5 then
			it.bar.BackgroundColor3 = Color3.fromRGB(255,200,120)
		else
			it.bar.BackgroundColor3 = Color3.fromRGB(120,200,255)
		end

		it.frame.LayoutOrder = math.floor(remaining * 1000)

		if remaining <= 0 then
			local stamp = nowClock
			task.delay(0.35, function()
				local cur = cdItems[name]
				if cur and cur.endsAtClock <= stamp then
					destroyCdItem(name)
				end
			end)
		end
	end
end)

----------------------------------------------------------------
--                HUD: HEALTH (top-middle)
----------------------------------------------------------------
StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Health, false)

local healthFrame = Instance.new("Frame")
healthFrame.Name = "HealthBar"
healthFrame.AnchorPoint = Vector2.new(0.5, 0)
healthFrame.Position = UDim2.new(0.5, 0, 0, 12)
healthFrame.Size = UDim2.new(0, 220, 0, 20)
healthFrame.BackgroundColor3 = Color3.fromRGB(25,25,25)
healthFrame.BackgroundTransparency = 0.2
healthFrame.BorderSizePixel = 0
healthFrame.Parent = gui

local hbBg = Instance.new("Frame")
hbBg.Size = UDim2.new(1, -8, 1, -8)
hbBg.Position = UDim2.new(0, 4, 0, 4)
hbBg.BackgroundColor3 = Color3.fromRGB(50,50,50)
hbBg.BorderSizePixel = 0
hbBg.Parent = healthFrame

local hbFill = Instance.new("Frame")
hbFill.Name = "Fill"
hbFill.Size = UDim2.new(1, 0, 1, 0)
hbFill.BackgroundColor3 = Color3.fromRGB(120,255,170)
hbFill.BorderSizePixel = 0
hbFill.Parent = hbBg

local hbLabel = Instance.new("TextLabel")
hbLabel.BackgroundTransparency = 1
hbLabel.Size = UDim2.new(1, 0, 1, 0)
hbLabel.TextXAlignment = Enum.TextXAlignment.Center
hbLabel.Font = Enum.Font.GothamBold
hbLabel.TextColor3 = Color3.new(1,1,1)
hbLabel.TextScaled = true
hbLabel.Text = "100 / 100"
hbLabel.Parent = healthFrame

local function hookHumanoid(hum)
	if not hum then return end
	local function refreshHP()
		local hp  = math.max(0, hum.Health)
		local max = math.max(1, hum.MaxHealth)
		local t   = hp / max
		hbFill.Size = UDim2.new(t, 0, 1, 0)
		hbLabel.Text = string.format("%d / %d", math.floor(hp + 0.5), math.floor(max + 0.5))
		if t <= 0.25 then
			hbFill.BackgroundColor3 = Color3.fromRGB(255,110,110)
		elseif t <= 0.5 then
			hbFill.BackgroundColor3 = Color3.fromRGB(255,200,120)
		else
			hbFill.BackgroundColor3 = Color3.fromRGB(120,255,170)
		end
	end
	refreshHP()
	hum:GetPropertyChangedSignal("Health"):Connect(refreshHP)
	hum:GetPropertyChangedSignal("MaxHealth"):Connect(refreshHP)
end

local function onCharacter(char)
	local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
	hookHumanoid(hum)
end

if player.Character then onCharacter(player.Character) end
player.CharacterAdded:Connect(onCharacter)

----------------------------------------------------------------
--                HUD: DODGE CHARGES (under health)
----------------------------------------------------------------
local DodgeEvt = RemoteEvents:WaitForChild("DodgeCharges")

local chargesFrame = Instance.new("Frame")
chargesFrame.Name = "DodgeCharges"
chargesFrame.AnchorPoint = Vector2.new(0.5, 0)
chargesFrame.Position = UDim2.new(0.5, 0, 0, 36)   -- just under health bar
chargesFrame.Size = UDim2.new(0, 120, 0, 10)
chargesFrame.BackgroundTransparency = 1
chargesFrame.Parent = gui

local hlist = Instance.new("UIListLayout")
hlist.FillDirection = Enum.FillDirection.Horizontal
hlist.HorizontalAlignment = Enum.HorizontalAlignment.Center
hlist.VerticalAlignment = Enum.VerticalAlignment.Top
hlist.Padding = UDim.new(0, 6)
hlist.Parent = chargesFrame

local dodgeBars = {}
for i=1,3 do
	local slot = Instance.new("Frame")
	slot.Size = UDim2.new(0, 32, 1, 0)
	slot.BackgroundColor3 = Color3.fromRGB(40,100,255)
	slot.BackgroundTransparency = 0.35
	slot.BorderSizePixel = 0
	slot.Parent = chargesFrame

	local fill = Instance.new("Frame")
	fill.Name = "Fill"
	fill.Size = UDim2.new(1, 0, 1, 0)
	fill.BackgroundColor3 = Color3.fromRGB(90,170,255)
	fill.BorderSizePixel = 0
	fill.Parent = slot

	dodgeBars[i] = slot
end

local function setDodgeCount(n)
	for i=1,3 do
		local active = i <= n
		local slot = dodgeBars[i]
		if active then
			slot.Fill.Visible = true
			slot.BackgroundTransparency = 0.15
		else
			slot.Fill.Visible = false
			slot.BackgroundTransparency = 0.85
		end
	end
end

DodgeEvt.OnClientEvent:Connect(function(current, max)
	setDodgeCount(tonumber(current) or 0)
end)

setDodgeCount(3) -- default to full; server will correct

----------------------------------------------------------------
--                DIALOGUE (inline, minimal) â€” low middle, no clipping
----------------------------------------------------------------
local Remotes         = Replicated:WaitForChild("RemoteEvents")
local BeginDialogue   = Remotes:WaitForChild("BeginDialogue")
local ChooseOption    = Remotes:WaitForChild("ChooseOption")
local DialogueUpdate  = Remotes:WaitForChild("DialogueUpdate")

-- container
local dlgGui = Instance.new("Frame")
dlgGui.Name = "Dialogue"
dlgGui.AnchorPoint = Vector2.new(0.5, 1)          -- bottom-aligned
dlgGui.Position = UDim2.fromScale(0.5, 0.95)      -- low middle by default
dlgGui.Size = UDim2.new(0.62, 0, 0, 180)
dlgGui.BackgroundTransparency = 0.05
dlgGui.Visible = false
dlgGui.Parent = gui

local dlgCorner = Instance.new("UICorner"); dlgCorner.CornerRadius = UDim.new(0, 16); dlgCorner.Parent = dlgGui
local dlgPad = Instance.new("UIPadding"); dlgPad.PaddingTop = UDim.new(0,12); dlgPad.PaddingBottom = UDim.new(0,12); dlgPad.PaddingLeft = UDim.new(0,12); dlgPad.PaddingRight = UDim.new(0,12); dlgPad.Parent = dlgGui

local dlgText = Instance.new("TextLabel")
dlgText.BackgroundTransparency = 1
dlgText.Size = UDim2.new(1, 0, 0, 86)
dlgText.TextWrapped = true
dlgText.TextXAlignment = Enum.TextXAlignment.Left
dlgText.TextYAlignment = Enum.TextYAlignment.Top
dlgText.Font = Enum.Font.Gotham
dlgText.TextSize = 20
dlgText.TextColor3 = Color3.new(125,125,125)
dlgText.Text = ""
dlgText.Parent = dlgGui

local optsHolder = Instance.new("Frame")
optsHolder.Position = UDim2.new(0, 0, 0, 90)
optsHolder.Size = UDim2.new(1, 0, 1, -90)
optsHolder.BackgroundTransparency = 1
optsHolder.Parent = dlgGui

local optsList = Instance.new("UIListLayout")
optsList.Padding = UDim.new(0, 6)
optsList.FillDirection = Enum.FillDirection.Vertical
optsList.HorizontalAlignment = Enum.HorizontalAlignment.Left
optsList.Parent = optsHolder

local function clearOptions()
	for _, c in ipairs(optsHolder:GetChildren()) do
		if c:IsA("TextButton") then c:Destroy() end
	end
end

local function makeOption(label, onClick)
	local b = Instance.new("TextButton")
	b.Size = UDim2.new(1, 0, 0, 34)
	b.Font = Enum.Font.GothamSemibold
	b.TextSize = 18
	b.TextColor3 = Color3.new(255,255,255)
	b.Text = label
	b.AutoButtonColor = true
	b.BackgroundTransparency = 0.15
	local ic = Instance.new("UICorner"); ic.CornerRadius = UDim.new(0, 10); ic.Parent = b
	b.Parent = optsHolder
	b.MouseButton1Click:Connect(onClick)
end

local activeStoryId, activeNodeId

local function closeDialogue()
	dlgGui.Visible = false
	dlgText.Text = ""
	clearOptions()
	activeStoryId, activeNodeId = nil, nil
end

-- viewport-safe positioning
local function updateDialoguePosition()
	local cam = workspace.CurrentCamera
	if not cam then return end
	local vpY = cam.ViewportSize.Y > 0 and cam.ViewportSize.Y or 1080
	local bottomMargin = 24 -- px above bottom edge
	local halfH = dlgGui.AbsoluteSize.Y * 0.5
	local safeScale = 1 - math.max(bottomMargin, halfH) / vpY
	local yScale = 1 - (bottomMargin / vpY)
	dlgGui.Position = UDim2.fromScale(0.5, math.min(yScale, safeScale))
end

local function hookCam(cam)
	if not cam then return end
	cam:GetPropertyChangedSignal("ViewportSize"):Connect(updateDialoguePosition)
end
hookCam(workspace.CurrentCamera)
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	hookCam(workspace.CurrentCamera)
	updateDialoguePosition()
end)
task.defer(updateDialoguePosition)

local function openDialogue(text, options, storyId, nodeId)
	dlgGui.Visible = true
	dlgText.Text = text or ""
	clearOptions()
	activeStoryId, activeNodeId = storyId, nodeId
	for i, opt in ipairs(options or {}) do
		makeOption(tostring(opt.label or ("Option "..i)), function()
			ChooseOption:FireServer(storyId, nodeId, i)
		end)
	end
	updateDialoguePosition()
end

DialogueUpdate.OnClientEvent:Connect(function(payload)
	print("[Client] DialogueUpdate", payload and payload.storyId, payload and payload.nodeId, "isEnd=", payload and payload.isEnd)
	if not payload then return end
	if payload.isEnd then
		closeDialogue()
		return
	end
	openDialogue(payload.text or "", payload.options or {}, payload.storyId, payload.nodeId)
end)

BeginDialogue.OnClientEvent:Connect(function(storyId, startNode)
	BeginDialogue:FireServer(storyId, startNode)
end)

----------------------------------------------------------------
-- KEYBINDS (5-slot system; menu tween-in; robust initial refresh)
----------------------------------------------------------------
local RE  = Replicated:WaitForChild("RemoteEvents")
local ActivateNode = RE:WaitForChild("ActivateNode")
local GetKeybinds  = RE:WaitForChild("GetKeybinds")
local SetKeybind   = RE:WaitForChild("SetKeybind")
local GetUnlocked  = RE:WaitForChild("GetUnlockedNodes")

-- Use KeyCode.Name strings everywhere (server expects these)
local KEYNAME_TO_KEYCODE = {
	One=Enum.KeyCode.One, Two=Enum.KeyCode.Two, Three=Enum.KeyCode.Three, Four=Enum.KeyCode.Four, Five=Enum.KeyCode.Five,
	Six=Enum.KeyCode.Six, Seven=Enum.KeyCode.Seven, Eight=Enum.KeyCode.Eight, Nine=Enum.KeyCode.Nine, Zero=Enum.KeyCode.Zero,
	Z=Enum.KeyCode.Z, X=Enum.KeyCode.X, C=Enum.KeyCode.C, V=Enum.KeyCode.V, B=Enum.KeyCode.B, N=Enum.KeyCode.N, M=Enum.KeyCode.M,
}
local KEYNAME_TO_LABEL = {
	One="1", Two="2", Three="3", Four="4", Five="5",
	Six="6", Seven="7", Eight="8", Nine="9", Zero="0",
	Z="Z", X="X", C="C", V="V", B="B", N="N", M="M",
}

-- UI: 5 slots at bottom center (hidden until menu is open)
local bar = Instance.new("Frame")
bar.Name = "KeybindBar"
bar.AnchorPoint = Vector2.new(0.5, 1)
local KB_OPEN_POS  = UDim2.new(0.5, 0, 1, -72)
local KB_CLOSED_POS= UDim2.new(0.5, 0, 1,  20)
bar.Position = KB_CLOSED_POS
bar.Size = UDim2.new(0, 520, 0, 48)
bar.BackgroundTransparency = 1 -- start hidden (we tween to 0.2 on open)
bar.BackgroundColor3 = Color3.fromRGB(25,25,25)
bar.Visible = false
bar.Parent = gui

local barCorner = Instance.new("UICorner"); barCorner.CornerRadius = UDim.new(0, 12); barCorner.Parent = bar
local list = Instance.new("UIListLayout")
list.FillDirection = Enum.FillDirection.Horizontal
list.Padding = UDim.new(0, 8)
list.HorizontalAlignment = Enum.HorizontalAlignment.Center
list.Parent = bar

local slots = {} -- { [1..5] = {frame, keyLabel, nodeLabel, btn, delBtn, keyCode?, keyName?, nodeName?} }
for i=1,5 do
	local f = Instance.new("Frame"); f.Size = UDim2.new(0, 96, 1, -8); f.Position = UDim2.new(0,0,0,4)
	f.BackgroundColor3 = Color3.fromRGB(40,40,40); f.BackgroundTransparency = 1; f.Parent = bar
	local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0,10); c.Parent = f

	local key = Instance.new("TextLabel")
	key.Size = UDim2.new(0, 30, 1, 0); key.Position = UDim2.new(0, 6, 0, 0)
	key.BackgroundTransparency = 1; key.Font = Enum.Font.GothamBlack; key.TextSize = 18
	key.TextColor3 = Color3.fromRGB(255,255,255); key.TextXAlignment = Enum.TextXAlignment.Left
	key.TextTransparency = 1
	key.Text = "-"
	key.Parent = f

	local node = Instance.new("TextLabel")
	node.Size = UDim2.new(1, -62, 1, 0); node.Position = UDim2.new(0, 40, 0, 0)
	node.BackgroundTransparency = 1; node.Font = Enum.Font.Gotham; node.TextSize = 16
	node.TextColor3 = Color3.fromRGB(245,245,255); node.TextXAlignment = Enum.TextXAlignment.Left
	node.TextTransparency = 1
	node.Text = "Empty"
	node.Parent = f

	-- click area to (re)bind
	local btn = Instance.new("TextButton")
	btn.BackgroundTransparency = 1
	btn.Size = UDim2.new(1, -24, 1, 0) -- leave room for delete âœ•
	btn.Text = ""
	btn.Parent = f

	-- delete / unbind (âœ•) button
	local del = Instance.new("TextButton")
	del.Size = UDim2.new(0, 20, 0, 20)
	del.Position = UDim2.new(1, -22, 0.5, -10)
	del.BackgroundColor3 = Color3.fromRGB(70,70,70)
	del.BackgroundTransparency = 1
	del.Text = "âœ•"
	del.Font = Enum.Font.GothamBold
	del.TextSize = 14
	del.TextColor3 = Color3.fromRGB(245,245,255)
	del.TextTransparency = 1
	del.Visible = false
	del.Parent = f
	local dc = Instance.new("UICorner"); dc.CornerRadius = UDim.new(1,0); dc.Parent = del

	slots[i] = {frame=f, keyLabel=key, nodeLabel=node, btn=btn, delBtn=del, keyCode=nil, keyName=nil, nodeName=nil}
end

-- Overlay chooser
local overlay = Instance.new("Frame")
overlay.Visible = false
overlay.AnchorPoint = Vector2.new(0.5, 0.5)
overlay.Position = UDim2.new(0.5, 0, 0.5, 0)
overlay.Size = UDim2.new(0, 360, 0, 300)
overlay.BackgroundColor3 = Color3.fromRGB(20,20,20)
overlay.BackgroundTransparency = 0.1
overlay.Parent = gui
local oc = Instance.new("UICorner"); oc.CornerRadius = UDim.new(0,12); oc.Parent = overlay
local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1; title.Size = UDim2.new(1, -16, 0, 28); title.Position = UDim2.new(0, 8, 0, 8)
title.Font = Enum.Font.GothamBold; title.TextSize = 18; title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(245,245,255)
title.Text = "Press a key (1-0 or Z-M)â€¦"
title.Parent = overlay

-- Unbind + Cancel row
local actions = Instance.new("Frame")
actions.BackgroundTransparency = 1
actions.Size = UDim2.new(1, -16, 0, 28)
actions.Position = UDim2.new(0, 8, 1, -36)
actions.Parent = overlay
local cancel = Instance.new("TextButton")
cancel.Size = UDim2.new(0, 100, 1, 0); cancel.Position = UDim2.new(1, -108, 0, 0)
cancel.BackgroundTransparency = 0.2; cancel.BackgroundColor3 = Color3.fromRGB(60,60,60)
cancel.Font = Enum.Font.GothamSemibold; cancel.TextSize = 16; cancel.TextColor3 = Color3.fromRGB(245,245,255)
cancel.Text = "Cancel"; cancel.Parent = actions
local oc2 = Instance.new("UICorner"); oc2.CornerRadius = UDim.new(0,8); oc2.Parent = cancel
local unbindBtn = Instance.new("TextButton")
unbindBtn.Size = UDim2.new(0, 110, 1, 0); unbindBtn.Position = UDim2.new(0, 0, 0, 0)
unbindBtn.BackgroundTransparency = 0.2; unbindBtn.BackgroundColor3 = Color3.fromRGB(80,50,50)
unbindBtn.Font = Enum.Font.GothamSemibold; unbindBtn.TextSize = 16; unbindBtn.TextColor3 = Color3.fromRGB(255,235,235)
unbindBtn.Text = "Unbind Key"; unbindBtn.Parent = actions
local oc3 = Instance.new("UICorner"); oc3.CornerRadius = UDim.new(0,8); oc3.Parent = unbindBtn

local scroll = Instance.new("ScrollingFrame")
scroll.Position = UDim2.new(0, 8, 0, 40); scroll.Size = UDim2.new(1, -16, 0, 220)
scroll.BackgroundTransparency = 1; scroll.CanvasSize = UDim2.new(0,0,0,0); scroll.ScrollBarThickness = 6
scroll.Parent = overlay
local sl = Instance.new("UIListLayout"); sl.Padding = UDim.new(0,6); sl.Parent = scroll

-- State
local activeMap = {} -- [KeyCode] = nodeName
local listeningSlot = nil
local pendingKeyName = nil

-- Render
local function renderBinds(map)
	table.clear(activeMap)
	local items = {}
	for k,v in pairs(map) do table.insert(items, {key=k, node=v}) end
	table.sort(items, function(a,b) return a.key < b.key end)
	for i=1,5 do
		local s = slots[i]
		local item = items[i]
		if item then
			local kc = KEYNAME_TO_KEYCODE[item.key]
			s.keyCode = kc; s.keyName = item.key; s.nodeName = item.node
			s.keyLabel.Text = KEYNAME_TO_LABEL[item.key] or item.key
			s.nodeLabel.Text = item.node
			if kc then activeMap[kc] = item.node end
			s.delBtn.Visible = true
		else
			s.keyCode = nil; s.keyName = nil; s.nodeName = nil
			s.keyLabel.Text = "-"
			s.nodeLabel.Text = "Empty"
			s.delBtn.Visible = false
		end
	end
end

-- Safe refresh (with pcall)
local function refresh()
	local ok, serverMap = pcall(function() return GetKeybinds:InvokeServer() end)
	renderBinds(ok and serverMap or {})
end

-- Boot-time extra refresh attempts (handles profile not-ready)
task.defer(function()
	refresh()
	task.wait(0.4); refresh()
	task.wait(0.8); refresh()
end)

local function closeOverlay()
	overlay.Visible = false
	listeningSlot = nil
	pendingKeyName = nil
end

local function openChooser(slotIndex)
	if not isMenuOpen then return end
	listeningSlot = slotIndex
	pendingKeyName = nil
	title.Text = "Press a key (1-0 or Z-M)â€¦"
	for _, child in ipairs(scroll:GetChildren()) do
		if child:IsA("TextButton") or child:IsA("TextLabel") then child:Destroy() end
	end
	overlay.Visible = true
end

cancel.MouseButton1Click:Connect(closeOverlay)

-- Unbind current pending key (after a key is chosen)
unbindBtn.MouseButton1Click:Connect(function()
	if not pendingKeyName then return end
	local res = SetKeybind:InvokeServer({ key = pendingKeyName, node = "" })
	closeOverlay()
	if res and res.binds then renderBinds(res.binds) else refresh() end
end)

-- Populate node list for chosen key (unlockables only)
local function populateNodesForKey()
	title.Text = string.format("Select node for key [%s]", KEYNAME_TO_LABEL[pendingKeyName] or pendingKeyName)
	for _, child in ipairs(scroll:GetChildren()) do
		if child:IsA("TextButton") or child:IsA("TextLabel") then child:Destroy() end
	end

	local ok, unlocked = pcall(function() return GetUnlocked:InvokeServer() end)
	unlocked = ok and unlocked or {}

	-- Safety: also local-filter against RS/Unlockables in case server changes
	local f = Replicated:FindFirstChild("Unlockables")
	local localSet = {}
	if f then
		for _, sv in ipairs(f:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then localSet[sv.Value] = true end
		end
	end

	for _, name in ipairs(unlocked) do
		if localSet[name] then
			local b = Instance.new("TextButton")
			b.Size = UDim2.new(1, -8, 0, 28)
			b.BackgroundTransparency = 0.2
			b.BackgroundColor3 = Color3.fromRGB(45,45,45)
			b.Font = Enum.Font.GothamSemibold
			b.TextSize = 16
			b.TextXAlignment = Enum.TextXAlignment.Left
			b.TextColor3 = Color3.fromRGB(245,245,255)
			b.Text = name
			b.Parent = scroll
			local bc = Instance.new("UICorner"); bc.CornerRadius = UDim.new(0,8); bc.Parent = b
			b.MouseButton1Click:Connect(function()
				local res = SetKeybind:InvokeServer({ key = pendingKeyName, node = name })
				closeOverlay()
				if res and res.binds then renderBinds(res.binds) else refresh() end
			end)
		end
	end
	scroll.CanvasSize = UDim2.new(0,0,0, (#unlocked)*34)
end

-- Slot click: open chooser / delete
for i=1,5 do
	slots[i].btn.MouseButton1Click:Connect(function()
		openChooser(i)
	end)
	slots[i].delBtn.MouseButton1Click:Connect(function()
		local s = slots[i]
		if not s.keyName then return end
		local res = SetKeybind:InvokeServer({ key = s.keyName, node = "" })
		if res and res.binds then renderBinds(res.binds) else refresh() end
	end)
end

-- Input handling: choose key, Backspace to unbind, normal activation
UIS.InputBegan:Connect(function(input, gp)
	if gp or input.UserInputType ~= Enum.UserInputType.Keyboard then return end
	local kc = input.KeyCode

	-- If chooser open: accept key or allow Backspace to unbind
	if listeningSlot then
		if kc == Enum.KeyCode.Backspace then
			if pendingKeyName then
				local res = SetKeybind:InvokeServer({ key = pendingKeyName, node = "" })
				closeOverlay()
				if res and res.binds then renderBinds(res.binds) else refresh() end
			end
			return
		end

		local name = kc.Name -- "One","Two","Z",...
		if KEYNAME_TO_KEYCODE[name] then
			pendingKeyName = name
			populateNodesForKey()
		end
		return
	end

	-- Normal play: trigger bound node (send camera dir + camera right)
	local node = activeMap[kc]
	if node and node ~= "" then
		local cam = workspace.CurrentCamera
		local dir = cam and cam.CFrame.LookVector or nil
		local right = cam and cam.CFrame.RightVector or nil
		ActivateNode:FireServer(node, dir, right)
	end
end)

-- ======= Keybind bar tweens =======
local function tweenBarIn()
	bar.Visible = true
	bar.Position = KB_CLOSED_POS
	bar.BackgroundTransparency = 1
	for _, s in ipairs(slots) do
		s.frame.BackgroundTransparency = 1
		s.keyLabel.TextTransparency = 1
		s.nodeLabel.TextTransparency = 1
		s.delBtn.TextTransparency = 1
		s.delBtn.BackgroundTransparency = 1
	end

	TS:Create(bar, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = KB_OPEN_POS,
		BackgroundTransparency = 0.2
	}):Play()

	for _, s in ipairs(slots) do
		TS:Create(s.frame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundTransparency = 0.1
		}):Play()
		TS:Create(s.keyLabel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			TextTransparency = 0
		}):Play()
		TS:Create(s.nodeLabel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			TextTransparency = 0
		}):Play()
		if s.delBtn.Visible then
			TS:Create(s.delBtn, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				TextTransparency = 0,
				BackgroundTransparency = 0.2
			}):Play()
		end
	end
end

local function tweenBarOut()
	TS:Create(bar, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		Position = KB_CLOSED_POS,
		BackgroundTransparency = 1
	}):Play()
	for _, s in ipairs(slots) do
		TS:Create(s.frame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			BackgroundTransparency = 1
		}):Play()
		TS:Create(s.keyLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			TextTransparency = 1
		}):Play()
		TS:Create(s.nodeLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			TextTransparency = 1
		}):Play()
		TS:Create(s.delBtn, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			TextTransparency = 1,
			BackgroundTransparency = 1
		}):Play()
	end
	task.delay(0.26, function()
		if bar then bar.Visible = false end
	end)
end

----------------------------------------------------------------
--       FINAL MENU TOGGLE (single handler, bulletproof hide)
----------------------------------------------------------------
do
	local state = "closed" -- "closed","opening","open","closing"
	local tween  : Tween? = nil
	local doneCn : RBXScriptConnection? = nil
	local OPEN_T  = 0.4
	local CLOSE_T = 0.25

	local function stopTween()
		if tween then tween:Cancel(); tween = nil end
		if doneCn then doneCn:Disconnect(); doneCn = nil end
	end

	local function openMenu()
		stopTween()
		state = "opening"
		isMenuOpen = true
		MenuFrame.Visible = true
		tween = TweenService:Create(MenuFrame, TweenInfo.new(OPEN_T, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = OPEN_POS
		})
		doneCn = tween.Completed:Connect(function(pb)
			if pb and pb ~= Enum.PlaybackState.Completed then return end
			state = "open"
		end)
		tween:Play()

		-- keybind hooks
		pcall(refresh)
		tweenBarIn()
	end

	local function closeMenu()
		stopTween()
		state = "closing"
		isMenuOpen = false
		MenuFrame.Visible = true -- keep visible during tween out
		tween = TweenService:Create(MenuFrame, TweenInfo.new(CLOSE_T, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = CLOSED_POS
		})
		doneCn = tween.Completed:Connect(function(pb)
			if pb and pb ~= Enum.PlaybackState.Completed then return end
			state = "closed"
			MenuFrame.Visible = false
		end)
		tween:Play()

		-- keybind hooks
		tweenBarOut()
		closeOverlay()

		-- fallback: hide even if Completed never fires
		task.delay(CLOSE_T + 0.05, function()
			if state ~= "open" and tween == nil then
				state = "closed"
				MenuFrame.Visible = false
			end
		end)
	end

	SmallIcon.MouseButton1Click:Connect(function()
		if state == "open" or state == "opening" then
			closeMenu()
		else
			openMenu()
		end
	end)

	-- optional helper if you ever need to force-close from elsewhere:
	_G.ForceCloseMenu = function()
		stopTween()
		state = "closed"
		isMenuOpen = false
		MenuFrame.Position = CLOSED_POS
		MenuFrame.Visible = false
		tweenBarOut()
		closeOverlay()
	end
end


===== FILE: src/client/StarterPlayerScripts/CustomShiftlock.client.lua =====
-- CustomShiftlock.client.lua (two-attachment AO; camera-facing yaw or no lock)
-- Make sure StarterPlayer.EnableMouseLockOption = false (disables Roblox default shiftlock).

local Players    = game:GetService("Players")
local UIS        = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace  = game:GetService("Workspace")

local player = Players.LocalPlayer
local cam    = Workspace.CurrentCamera

-- ========= CONFIG =========
local LOCK_MOUSE   = true      -- center mouse while locked
local SHOW_CURSOR  = false
local LOCK_BODY    = true      -- << set to false to NOT rotate body; still toggles mouse lock

-- ========= STATE =========
local isLocked = false
local char, hum, hrp
local att0        -- Attachment on HRP
local ao          -- AlignOrientation on HRP
local aimPart     -- invisible anchored part we rotate to camera yaw
local aimAtt      -- Attachment on aimPart

-- ========= UTILS =========
local function flat(v: Vector3)
	local f = Vector3.new(v.X, 0, v.Z)
	return (f.Magnitude > 1e-4) and f.Unit or Vector3.new(0,0,-1)
end

local function setMouseLock(on: boolean)
	if not UIS.MouseEnabled then return end
	UIS.MouseBehavior    = (on and LOCK_MOUSE) and Enum.MouseBehavior.LockCenter or Enum.MouseBehavior.Default
	UIS.MouseIconEnabled = (not on) or SHOW_CURSOR
end

-- Build/remove constraint (TWO-ATTACHMENT mode ensures world-yaw matches camera)
local function ensureConstraint()
	if not (LOCK_BODY and hrp) then return end

	if not aimPart then
		aimPart = Instance.new("Part")
		aimPart.Name = "_ShiftlockAim"
		aimPart.Size = Vector3.new(0.2, 0.2, 0.2)
		aimPart.Anchored = true
		aimPart.CanCollide = false
		aimPart.Transparency = 1
		aimPart.CFrame = hrp.CFrame
		aimPart.Parent = Workspace
	end
	if not aimAtt then
		aimAtt = Instance.new("Attachment")
		aimAtt.Name = "_ShiftlockA1"
		aimAtt.Parent = aimPart
	end
	if not att0 then
		att0 = Instance.new("Attachment")
		att0.Name = "_ShiftlockA0"
		att0.Parent = hrp
	end
	if not ao then
		ao = Instance.new("AlignOrientation")
		ao.Name = "_ShiftlockAO"
		ao.Attachment0 = att0
		ao.Attachment1 = aimAtt
		ao.RigidityEnabled = true      -- crisp lock
		ao.Responsiveness  = 200       -- snappy
		ao.ReactionTorqueEnabled = false
		-- Be generous with torque if your character is heavy:
		pcall(function() ao.MaxTorque = math.huge end)
		ao.Parent = hrp
	end
end

local function destroyConstraint()
	if ao then ao:Destroy(); ao = nil end
	if att0 then att0:Destroy(); att0 = nil end
	if aimAtt then aimAtt:Destroy(); aimAtt = nil end
	if aimPart then aimPart:Destroy(); aimPart = nil end
end

-- ========= ALIGN LOOP =========
local BIND = "CustomShiftlockAlign_TwoAttach"

local function alignStep()
	if not isLocked then return end
	if LOCK_BODY and not (hum and hrp and ao and aimPart) then return end
	if not cam then return end

	-- Skip physics-hostile states
	local st = hum and hum:GetState()
	if st == Enum.HumanoidStateType.Seated
		or st == Enum.HumanoidStateType.Dead
		or st == Enum.HumanoidStateType.Ragdoll then
		return
	end

	-- Update the (invisible) aimPartâ€™s orientation to camera yaw.
	-- Using hrp.Position keeps the yaw intuitive; position doesn't matter for AO.
	local f = flat(cam.CFrame.LookVector)
	if LOCK_BODY and aimPart then
		local pos = hrp and hrp.Position or aimPart.Position
		aimPart.CFrame = CFrame.lookAt(pos, pos + f, Vector3.yAxis)
	end
end

local function bindLoop()
	RunService:BindToRenderStep(BIND, Enum.RenderPriority.Last.Value, alignStep)
end

local function unbindLoop()
	pcall(function() RunService:UnbindFromRenderStep(BIND) end)
end

-- ========= TOGGLE =========
local function setLocked(on: boolean)
	isLocked = on
	if hum then hum.AutoRotate = not (on and LOCK_BODY) end
	if char then char:SetAttribute("CustomShiftlock", on and LOCK_BODY) end

	if on then
		if LOCK_BODY then ensureConstraint() end
		setMouseLock(true)
		bindLoop()
	else
		setMouseLock(false)
		unbindLoop()
		destroyConstraint()
	end
end

-- ========= CHARACTER LIFECYCLE =========
local function onCharacter(c: Model)
	char = c
	hum  = c:WaitForChild("Humanoid")
	hrp  = c:WaitForChild("HumanoidRootPart")
	if isLocked then
		if LOCK_BODY then ensureConstraint() end
		hum.AutoRotate = not (LOCK_BODY)
	end
end
player.CharacterAdded:Connect(onCharacter)
if player.Character then onCharacter(player.Character) end

player.CharacterRemoving:Connect(function()
	unbindLoop()
	destroyConstraint()
	setMouseLock(false)
end)

-- ========= SHIFT TOGGLE =========
UIS.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
	if UIS:GetFocusedTextBox() then return end
	if input.KeyCode ~= Enum.KeyCode.LeftShift and input.KeyCode ~= Enum.KeyCode.RightShift then return end
	setLocked(not isLocked)
end)

-- Safety cleanup
script.AncestryChanged:Connect(function(_, parent)
	if not parent then
		unbindLoop()
		destroyConstraint()
		setMouseLock(false)
	end
end)


===== FILE: src/client/StarterPlayerScripts/HorseMountClient.client.lua =====
-- StarterPlayerScripts/HorseMountClient.client.lua
-- While mounted:
--   W          = throttle
--   Space      = jump
--   Q          = GALLOP (spends a DodgeCharge)  â† overrides your normal Q-dodge
--   R          = dismount
-- On dismount, we unbind and your regular Q-dodge works again.

local Players       = game:GetService("Players")
local RS            = game:GetService("ReplicatedStorage")
local RunService    = game:GetService("RunService")
local CAS           = game:GetService("ContextActionService")

local player        = Players.LocalPlayer

-- === Remotes ===
local RE            = RS:WaitForChild("RemoteEvents")
local RE_Face       = RE:WaitForChild("Horse_Face")
local RE_Move       = RE:WaitForChild("Horse_Move")
local RE_Jump       = RE:WaitForChild("Horse_Jump")
local RE_Dismount   = RE:WaitForChild("Horse_RequestDismount")
local RE_Gallop     = RE:WaitForChild("Horse_Gallop")

-- === Config ===
local SEAT_NAME     = "SaddleSeat"
local GALLOP_KEY    = Enum.KeyCode.Q    -- â† replace your dodge key here if different
local PRIORITY      = (Enum.ContextActionPriority.High.Value or 2000) + 1
local DEBUG         = false
local function dprint(...) if DEBUG then print("[HorseClient]", ...) end end

-- === State ===
local mountedHorse: Model? = nil
local forwardDown          = false
local faceConn             = nil

-- === Helpers ===
local function isHorseSeat(seat: Instance?): boolean
	if not (seat and seat:IsA("Seat") and seat.Name == SEAT_NAME) then return false end
	local model = seat:FindFirstAncestorOfClass("Model")
	return model and model:GetAttribute("IsHorse") == true or false
end

local function flat(vec: Vector3): Vector3
	local f = Vector3.new(vec.X, 0, vec.Z)
	return (f.Magnitude > 1e-3) and f.Unit or Vector3.new(0,0,-1)
end

local function sensorCF(): CFrame
	local char = player.Character
	if not (char and char.Parent) then return CFrame.new() end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return CFrame.new() end
	local cam = workspace.CurrentCamera
	local look = cam and cam.CFrame.LookVector or hrp.CFrame.LookVector
	local pos  = hrp.Position
	return CFrame.lookAt(pos, pos + flat(look), Vector3.yAxis)
end

-- === Controls ===
local function bindControls()
	dprint("Bind controls (W/Space/Q/R)")

	CAS:BindAction("Horse_Forward", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Sink end
		if state == Enum.UserInputState.Begin then
			if not forwardDown then
				forwardDown = true
				RE_Move:FireServer(mountedHorse, true)
			end
		elseif state == Enum.UserInputState.End then
			if forwardDown then
				forwardDown = false
				RE_Move:FireServer(mountedHorse, false)
			end
		end
		return Enum.ContextActionResult.Sink
	end, false, Enum.KeyCode.W)

	CAS:BindAction("Horse_Jump", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Sink end
		if state == Enum.UserInputState.Begin then
			RE_Jump:FireServer()
		end
		return Enum.ContextActionResult.Sink
	end, false, Enum.KeyCode.Space)

	-- IMPORTANT: Use BindActionAtPriority so we PREEMPT your normal Q-dodge while mounted.
	CAS:BindActionAtPriority("Horse_Gallop_Q", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Pass end
		if state == Enum.UserInputState.Begin then
			RE_Gallop:FireServer()
		end
		return Enum.ContextActionResult.Sink -- swallow so your dodge handler never sees Q while mounted
	end, false, PRIORITY, GALLOP_KEY)

	CAS:BindAction("Horse_Dismount", function(_, state)
		if not mountedHorse then return Enum.ContextActionResult.Sink end
		if state == Enum.UserInputState.Begin then
			RE_Dismount:FireServer()
		end
		return Enum.ContextActionResult.Sink
	end, false, Enum.KeyCode.R)
end

local function unbindControls()
	dprint("Unbind controls")
	CAS:UnbindAction("Horse_Forward")
	CAS:UnbindAction("Horse_Jump")
	CAS:UnbindAction("Horse_Gallop_Q")
	CAS:UnbindAction("Horse_Dismount")
	forwardDown = false
end

-- Stream facing every frame while mounted
local function startFaceStream()
	if faceConn then return end
	faceConn = RunService.RenderStepped:Connect(function()
		if mountedHorse then
			RE_Face:FireServer(mountedHorse, sensorCF())
		end
	end)
end
local function stopFaceStream()
	if faceConn then faceConn:Disconnect() end
	faceConn = nil
end

-- === Seat hooks ===
local function onSeated(active: boolean, seatPart: BasePart?)
	if active and seatPart and isHorseSeat(seatPart) then
		mountedHorse = seatPart:FindFirstAncestorOfClass("Model")
		dprint("Mounted", mountedHorse and mountedHorse.Name or "?")
		bindControls()
		startFaceStream()
	else
		dprint("Unmounted")
		unbindControls()
		stopFaceStream()
		mountedHorse = nil
	end
end

local function onCharacterAdded(char: Model)
	local hum = char:WaitForChild("Humanoid")
	hum.Seated:Connect(onSeated)
	-- If we spawn already seated
	if hum.SeatPart and isHorseSeat(hum.SeatPart) then
		onSeated(true, hum.SeatPart)
	end
end

if player.Character then onCharacterAdded(player.Character) end
player.CharacterAdded:Connect(onCharacterAdded)


===== FILE: src/client/StarterPlayerScripts/InputHandler.client.lua =====
-- src/client/StarterPlayerScripts/InputHandler.client.lua
-- Minimal client input: Block start/end only. SummonHorse handled elsewhere.

local Players           = game:GetService("Players")
local UserInputService  = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Remotes       = ReplicatedStorage:WaitForChild("RemoteEvents")
local ActivateNode  = Remotes:WaitForChild("ActivateNode")

local LOCAL_PLAYER  = Players.LocalPlayer

-- You can change these to your preferred keys/buttons.
local BLOCK_KEYS = {
	[Enum.KeyCode.F] = true,
}
local BLOCK_MOUSE = {
	[Enum.UserInputType.MouseButton2] = true, -- right mouse
}

local blockDown = false

local function beginBlock()
	if blockDown then return end
	blockDown = true
	-- Your NodeModules implement BlockStart; server routes via ActivateNode
	ActivateNode:FireServer("BlockStart")
end

local function endBlock()
	if not blockDown then return end
	blockDown = false
	ActivateNode:FireServer("BlockEnd")
end

-- Keyboard / mouse listeners -------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.UserInputType == Enum.UserInputType.Keyboard and BLOCK_KEYS[input.KeyCode] then
		beginBlock()
	elseif BLOCK_MOUSE[input.UserInputType] then
		beginBlock()
	end
end)

UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end
	if input.UserInputType == Enum.UserInputType.Keyboard and BLOCK_KEYS[input.KeyCode] then
		endBlock()
	elseif BLOCK_MOUSE[input.UserInputType] then
		endBlock()
	end
end)

-- Defensive cleanup on character reset (not strictly necessary here)
LOCAL_PLAYER.CharacterAdded:Connect(function()
	-- Ensure block isnâ€™t stuck down across respawns
	blockDown = false
end)


===== FILE: src/client/StarterPlayerScripts/LocalScript.client.lua =====
-- StarterPlayerScripts/SummonHorseKey.client.lua
-- Press H to toggle SummonHorse (always available; server enforces unlock/cooldown).

local UIS = game:GetService("UserInputService")
local RS  = game:GetService("ReplicatedStorage")

local Remotes      = RS:WaitForChild("RemoteEvents")
local ActivateNode = Remotes:WaitForChild("ActivateNode")

local SUMMON_KEY = Enum.KeyCode.H

UIS.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == SUMMON_KEY then
		local cam = workspace.CurrentCamera
		local dir = cam and cam.CFrame.LookVector or Vector3.new(0,0,-1)
		ActivateNode:FireServer("SummonHorse", dir)
	end
end)


===== FILE: src/server/NodeLibrary/FixedDashAndAnimation.lua =====
-- Assumes 'char' is the character model passed into the function
local function DashAndAnimate(char)
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hum or not hrp then return end

    -- Load Animation (use Animator for R15 and future compatibility)
    local animator = hum:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = hum
    end
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://110397380149359"
    local track = animator:LoadAnimation(anim)
    track:Play()

    -- Dash movement burst (use AssemblyLinearVelocity for physics consistency)
    local dodgeForce = 50
    local moveDir = hum.MoveDirection
    if moveDir.Magnitude > 0 then
        hrp.AssemblyLinearVelocity = moveDir.Unit * dodgeForce
    end
end

return {
    DashAndAnimate = DashAndAnimate
}



===== FILE: src/server/NodeLibrary/NodeLibrary.lua =====
local NodeLibrary = {}

-- Services / Modules
local RS        = game:GetService("ReplicatedStorage")
local Players   = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local CombatState         = require(RS:WaitForChild("CombatState"))
local CooldownService     = require(RS:WaitForChild("CooldownService"))
local DamageService       = require(RS:WaitForChild("DamageService"))
local GuardService        = require(RS:WaitForChild("GuardService"))
local KnockbackService    = require(RS:WaitForChild("KnockbackService"))
local ComboService        = require(RS:WaitForChild("ComboService"))
local StunService         = require(RS:WaitForChild("StunService"))
local DodgeChargeService  = require(RS:WaitForChild("DodgeChargeService"))
local AttackStateService  = require(RS:WaitForChild("AttackStateService"))
local SpeedController     = require(RS:WaitForChild("SpeedController"))
local NodeSense = require(RS:WaitForChild("NodeSense"))
local RunService = game:GetService("RunService")


local ConfirmSuccess = RS:FindFirstChild("RemoteEvents")
	and RS.RemoteEvents:FindFirstChild("ConfirmSuccess")

-- Optional (used by your Revolver and weâ€™ll piggyback for melee if present)
local HitboxService = RS:FindFirstChild("HitboxService") and require(RS.HitboxService)

-- =============== utils =================
local function isPlayer(x)  return typeof(x) == "Instance" and x:IsA("Player") end

local function resolveCharacter(entity)
	if typeof(entity) == "Instance" then
		if entity:IsA("Player") then return entity.Character end
		if entity:IsA("Model") and entity:FindFirstChildOfClass("Humanoid") then return entity end
	elseif typeof(entity) == "table" and typeof(entity.Character) == "Instance" then
		return entity.Character
	end
	return nil
end

local function partsOf(actor)
	local char = resolveCharacter(actor)
	if not char then return nil end
	local hum  = char:FindFirstChildOfClass("Humanoid")
	local hrp  = char:FindFirstChild("HumanoidRootPart")
	return char, hum, hrp
end

local function playAndUnlock(humanoid, animId, actor)
	local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
	local anim = Instance.new("Animation")
	anim.AnimationId = animId
	local track = animator:LoadAnimation(anim)
	track:Play()
	track.Stopped:Connect(function() CombatState.Unlock(actor) end)
end

-- Tiny model speed shim (players use SpeedController; models we emulate)
-- Tiny model speed shim (baseline-safe for Models; Players use SpeedController)
local _modelBaseline = setmetatable({}, {__mode="k"}) -- [Model] = base WalkSpeed
local _modelTimer    = setmetatable({}, {__mode="k"}) -- [Model] = thread

local function calcBaseline(hum)
	-- If current WS looks â€œbogusâ€ (already slowed or extreme), fall back to 16
	local ws = hum.WalkSpeed
	if ws < 10 or ws > 30 then return 16 end
	return ws
end

local function baselineFor(model, hum)
	if not _modelBaseline[model] then
		_modelBaseline[model] = calcBaseline(hum)
	end
	return _modelBaseline[model]
end

local function applySpeed(actor, newSpeed, duration)
	if isPlayer(actor) then
		return SpeedController.Apply(actor, newSpeed, duration)
	end
	local char, hum = partsOf(actor)
	if not hum then return end

	-- Always restore to baseline, never to a potentially-slow snapshot
	local base = baselineFor(char, hum)

	-- cancel previous timed restore for this model
	if _modelTimer[char] then task.cancel(_modelTimer[char]) end

	hum.WalkSpeed = newSpeed
	_modelTimer[char] = task.delay(duration, function()
		if hum and hum.Parent then
			hum.WalkSpeed = base
		end
		_modelTimer[char] = nil
	end)
end


-- Faction helper: anything with IsEnemy=true is "enemy", else "player"
local function factionOf(model)
	return (model and model:GetAttribute("IsEnemy")) and "enemy" or "player"
end

-- Collect nearby valid targets (prefers HitboxService; falls back to scan), filtered by faction
local function collectTargetsAround(actor, radius)
	local char, _, root = partsOf(actor)
	if not (char and root) then return {} end

	local mine = factionOf(char)
	local raw, ok
	if HitboxService then
		if HitboxService.SphereFromPoint then
			ok, raw = pcall(HitboxService.SphereFromPoint, root.Position, radius, {humanoidsOnly = true, exclude = char})
		elseif HitboxService.Sphere then
			ok, raw = pcall(HitboxService.Sphere, root.Position, radius, {humanoidsOnly = true, exclude = char})
		elseif HitboxService.CollectHumanoids then
			ok, raw = pcall(HitboxService.CollectHumanoids, root.Position, radius, {exclude = char})
		end
	end

	local out = {}
	if ok and raw and #raw > 0 then
		for _, item in ipairs(raw) do
			local mdl = item
			if typeof(item) == "Instance" and item:IsA("Humanoid") then mdl = item.Parent end
			if typeof(mdl) == "Instance" and mdl:IsA("Model") and mdl ~= char and mdl:FindFirstChildOfClass("Humanoid") then
				if factionOf(mdl) ~= mine then
					table.insert(out, mdl)
				end
			end
		end
	else
		for _, inst in ipairs(Workspace:GetDescendants()) do
			if inst:IsA("Model") and inst ~= char then
				local hum = inst:FindFirstChildOfClass("Humanoid")
				local hrp = inst:FindFirstChild("HumanoidRootPart")
				if hum and hum.Health > 0 and hrp and (hrp.Position - root.Position).Magnitude <= radius then
					if factionOf(inst) ~= mine then
						table.insert(out, inst)
					end
				end
			end
		end
	end
	return out
end

-- Apply a damage table to a Model/Player using DamageService; returns true if we attempted
local function dealToEntity(targetModel, dmgTbl, sourceActor)
	local asPlayer = Players:GetPlayerFromCharacter(targetModel)
	return DamageService.DealDamage(asPlayer or targetModel, dmgTbl, sourceActor)
end
-- helper (top of file is fine)
local function safeUnlock(actor, why)
	if CombatState.IsLocked(actor) then
		CombatState.Unlock(actor, why or "Node end")
	end
end


-- =============== PUNCH =================
-- ===== PUNCH (soft-stun on real hit; no guard dmg/chip; not parryable) =====
function NodeLibrary.Punch(actor)
	if CombatState.IsLocked(actor) or not CooldownService.CanUse(actor, "Punch") then return end

	CombatState.Lock(actor)
	CooldownService.Apply(actor, "Punch", 0.5)

	local char, hum = partsOf(actor)
	if not hum then safeUnlock(actor, "no humanoid"); return end

	AttackStateService.Start(actor, { duration = 0.25, nodeName = "Punch" })
	applySpeed(actor, hum.WalkSpeed * 0.5, 0.5)

	local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
	local anim = Instance.new("Animation"); anim.AnimationId = "rbxassetid://121093639008688"
	local track = animator:LoadAnimation(anim)
	track.Stopped:Connect(function() safeUnlock(actor, "anim stopped") end)
	track:Play()

	task.delay(0.18, function()
		-- if interrupted during windup, unlock immediately
		if AttackStateService.IsInterrupted(actor) then
			safeUnlock(actor, "interrupted")
			return
		end

		local dmgTbl = {
			nodeName  = "Punch",
			type      = "Melee",
			guard     = 0,     -- per your latest tuning
			hp        = 3.3,
			chip      = 0,
			blockable = true,
			parryable = false,
		}

		local targets = collectTargetsAround(actor, 5)
		local landed = 0
		for _, mdl in ipairs(targets) do
			dealToEntity(mdl, dmgTbl, actor)
			-- soft stagger + slow (no CombatState lock)
			StunService.Apply(Players:GetPlayerFromCharacter(mdl) or mdl, 0.30, { hard = false, moveScale = 0.20 })
			landed += 1
		end

		if landed > 0 then ComboService.RegisterHit(actor) end

		-- end the attack and ensure unlock in case anim didnâ€™t stop
		AttackStateService.Clear(actor, "done")
		safeUnlock(actor, "punch end")
	end)
end


-- =============== HEAVY =================
function NodeLibrary.Heavy(actor)
	if CombatState.IsLocked(actor) or not CooldownService.CanUse(actor, "Heavy") then return end

	CombatState.Lock(actor)
	CooldownService.Apply(actor, "Heavy", 2)

	local char, hum, root = partsOf(actor)
	if not (hum and root) then safeUnlock(actor, "no humanoid/root"); return end

	-- interruptible heavy (hyperArmor=false)
	AttackStateService.Start(actor, { duration = 0.60, nodeName = "Heavy" })

	applySpeed(actor, hum.WalkSpeed * 1.5, 0.5)
	task.delay(0.5, function() applySpeed(actor, hum.WalkSpeed * 0.25, 0.35) end)

	local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
	local anim = Instance.new("Animation"); anim.AnimationId = "rbxassetid://90152186812447"
	local track = animator:LoadAnimation(anim)
	track.Stopped:Connect(function() safeUnlock(actor, "anim stopped") end)
	track:Play()

	task.delay(0.55, function()
		if AttackStateService.IsInterrupted(actor) then
			safeUnlock(actor, "interrupted")
			return
		end

		local dmgTbl = {
			nodeName  = "Heavy",
			type      = "MeleeHeavy",
			guard     = 30,
			hp        = 7.0,
			chip      = 2.0,
			blockable = false,
			parryable = true,
		}

		for _, mdl in ipairs(collectTargetsAround(actor, 7)) do
			dealToEntity(mdl, dmgTbl, actor)
			local theirRoot = mdl:FindFirstChild("HumanoidRootPart")
			if theirRoot then
				local dir = (theirRoot.Position - root.Position)
				KnockbackService.Apply(Players:GetPlayerFromCharacter(mdl) or mdl, dir, 90, 0.35)
			end
			-- heavy can do a short hard stun if you want; keep soft if preferred
			StunService.Apply(Players:GetPlayerFromCharacter(mdl) or mdl, 0.40, { hard = true })
		end

		if isPlayer(actor) and ConfirmSuccess then
			ConfirmSuccess:FireClient(actor, "Heavy")
		end

		AttackStateService.Clear(actor, "done")
		safeUnlock(actor, "heavy end")
	end)
end
-- Module-local state
local _isBlocking = setmetatable({}, { __mode = "k" })

local function _forceUnblock(actor, why)
	_isBlocking[actor] = nil
	pcall(function() DamageService.EndBlock(actor) end)
	pcall(function() CombatState.StopCurrentTrack(actor) end)
	pcall(function() CombatState.Unlock(actor, "ForceUnblock:" .. tostring(why or "?")) end)
	applySpeed(actor, 16, 0.05)
end

-- Only keep movement slow alive; never cancel just because GuardService says false
local function _startBlockWatch(actor)
	task.spawn(function()
		while _isBlocking[actor] do
			-- renew the slow in short pulses so it never â€œsticksâ€
			applySpeed(actor, 8, 0.30)

			local _, hum = partsOf(actor)
			if not hum or hum.Health <= 0 then
				_forceUnblock(actor, "NoHumanoid")
				break
			end

			-- Guard-break / hard stun flips PlatformStand â†’ stop blocking immediately
			if hum.PlatformStand then
				_forceUnblock(actor, "PlatformStand")
				break
			end

			task.wait(0.12)
		end
	end)
end

-- =============== BLOCK =================
-- =============== BLOCK =================
local BLOCK_START_CD  = 0.15
local BLOCK_REARM_CD  = 0.60
local PARRY_REARM_CD  = 0.60
local lastParryAt     = setmetatable({}, {__mode="k"})

local function canBeginBlock(actor)
	return (not CombatState.IsLocked(actor))
		and CooldownService.CanUse(actor, "BlockStart")
		and CooldownService.CanUse(actor, "BlockRearm")
end

function NodeLibrary.BlockStart(actor)
	if _isBlocking[actor] then return true end
	if not canBeginBlock(actor) then return false end

	_isBlocking[actor] = true
	CombatState.Lock(actor, "Block")
	DamageService.StartBlock(actor)

	-- Parry window gate
	local ParryService = require(RS:WaitForChild("ParryService"))
	local now = os.clock()
	if (not lastParryAt[actor]) or (now - lastParryAt[actor] >= PARRY_REARM_CD) then
		ParryService.OpenWindow(actor)
		lastParryAt[actor] = now
	end

	applySpeed(actor, 8, 0.30)
	_startBlockWatch(actor)

	local _, hum = partsOf(actor)
	if not hum then
		_forceUnblock(actor, "BlockStart:NoHum")
		return false
	end
	local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
	local upAnim   = Instance.new("Animation"); upAnim.AnimationId = "rbxassetid://132302528927640"
	animator:LoadAnimation(upAnim):Play()

	task.delay(0.10, function()
		if _isBlocking[actor] and CombatState.IsLocked(actor) then
			local holdAnim = Instance.new("Animation"); holdAnim.AnimationId = "rbxassetid://72122053405063"
			local holdTrack = animator:LoadAnimation(holdAnim)
			holdTrack.Looped = true
			holdTrack:Play()
			CombatState.RegisterTrack(actor, holdTrack)
		end
	end)

	if isPlayer(actor) and ConfirmSuccess then
		ConfirmSuccess:FireClient(actor, "Block")
	end
	CooldownService.Apply(actor, "BlockStart", BLOCK_START_CD)
	return true
end

function NodeLibrary.BlockEnd(actor)
	if not _isBlocking[actor] then return false end
	_forceUnblock(actor, "BlockEnd")
	CooldownService.Apply(actor, "BlockRearm", BLOCK_REARM_CD)
	return true
end


-- =============== DODGE =================
function NodeLibrary.Dodge(actor, camDir : Vector3?)
	if not DodgeChargeService.CanDodge(actor) then return end
	if CombatState.IsLocked(actor) then return end
	if not CooldownService.CanUse(actor, "Dodge") then return end
	DodgeChargeService.Consume(actor)

	CooldownService.Apply(actor, "Dodge", 1.5)
	CombatState.Lock(actor)

	local char, hum, hrp = partsOf(actor)
	if not hum or not hrp then CombatState.Unlock(actor); return end

	local anim  = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://110397380149359"
	local track = hum:LoadAnimation(anim)
	track:Play()
	track.Stopped:Connect(function() CombatState.Unlock(actor) end)

	camDir = (camDir and camDir.Magnitude > 0) and camDir.Unit or nil

	local function dash(dir, mult, dur)
		local bv = Instance.new("BodyVelocity")
		bv.Velocity = dir * 50 * mult
		bv.MaxForce = Vector3.new(1e5, 0, 1e5)
		bv.P = 1250
		bv.Parent = hrp
		task.delay(dur, function() bv:Destroy() end)
	end

	local function currentMoveDir()
		if hum.MoveDirection.Magnitude > 0 then return hum.MoveDirection.Unit end
		if camDir and camDir.Magnitude > 0 then return camDir.Unit end
		return hrp.CFrame.LookVector
	end

	dash(currentMoveDir(), 0.25, 0.2)
	task.delay(0.1, function() DamageService.GrantIFrames(actor, 1.0) end)

	task.delay(0.2, function()
		local total, step = 0, 0.05
		while total < 0.4 and hrp.Parent do
			dash(currentMoveDir(), 1.0, step)
			task.wait(step)
			total += step
		end
	end)

	task.delay(0.5, function() dash(currentMoveDir(), 1.0, 0.1) end)
	task.delay(0.6, function() dash(currentMoveDir(), 0.50, 0.4) end)
end
if RunService:IsServer() and NodeSense and NodeSense.ServerEvent then
	NodeSense.ServerEvent.Event:Connect(function(payload)
		local out = payload and payload.context and payload.context.outcome
		if out == "GuardBroken" then
			-- Payload actor is the *victim* of the guard break
			local victim = payload.actorPlayer or payload.actorModel
			if victim then
				_forceUnblock(victim, "GuardBroken")
			end
		end
	end)
end
	
return NodeLibrary


===== FILE: src/server/00_MounterFirewall.server.lua =====
-- 00_MountedFirewall.server.lua
-- Global, future-proof block for actions while mounted.
-- Patches NodeFactory.Create and DamageService.DealDamage at runtime.
-- Hardened to accept attacker as Player/Model/Humanoid/BasePart or table context.

local RS      = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- ===== CONFIG =====
local DEBUG = false
local function dprint(...) if DEBUG then print("[MountedFirewall]", ...) end end

-- Nodes allowed while mounted (e.g., emotes)
local ALLOW_WHILE_MOUNTED: {[string]: boolean} = {
	-- ["WaveEmote"] = true,
}

-- ---------- Helpers ----------
local function characterFromInstance(inst: Instance?)
	if not inst then return nil end
	if inst:IsA("Model") then return inst end
	if inst:IsA("Humanoid") then return inst.Parent end
	if inst:IsA("BasePart") then return inst:FindFirstAncestorOfClass("Model") end
	return nil
end

local function playerFromAnything(x): Player?
	if typeof(x) == "Instance" then
		if x:IsA("Player") then return x end
		local char = characterFromInstance(x)
		if char then return Players:GetPlayerFromCharacter(char) end
	elseif typeof(x) == "table" then
		-- Common table fields we might see from services
		local pCands = { x.player, x.Player, x.AttackerPlayer, x.Owner, x.SourcePlayer, x.Source }
		for _, p in ipairs(pCands) do
			if typeof(p) == "Instance" and p:IsA("Player") then return p end
		end
		local cCands = { x.Character, x.char, x.AttackerChar, x.AttackerCharacter, x.SourceCharacter, x.SourceChar, x.CharacterModel, x.Model, x.RootPart }
		for _, c in ipairs(cCands) do
			if typeof(c) == "Instance" then
				if c:IsA("Player") then return c end
				local char = characterFromInstance(c) or (c:IsA("Model") and c or nil)
				if char then
					local plr = Players:GetPlayerFromCharacter(char)
					if plr then return plr end
				end
			end
		end
	end
	return nil
end

local function characterFromAnything(x): Model?
	if typeof(x) == "Instance" then
		return characterFromInstance(x)
	elseif typeof(x) == "table" then
		local cCands = { x.Character, x.char, x.AttackerChar, x.AttackerCharacter, x.SourceCharacter, x.SourceChar, x.CharacterModel, x.Model, x.RootPart }
		for _, c in ipairs(cCands) do
			if typeof(c) == "Instance" then
				local ch = characterFromInstance(c) or (c:IsA("Model") and c or nil)
				if ch then return ch end
			end
		end
	end
	return nil
end

local function isMountedPlayer(plr: Player?): boolean
	if not plr then return false end
	local hum = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

local function isMountedAnything(x): boolean
	local plr = playerFromAnything(x)
	if plr then return isMountedPlayer(plr) end
	local char = characterFromAnything(x)
	if not char then return false end
	local hum = char:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

-- ---------- Patch NodeFactory.Create (guards every node function) ----------
local NodeFactory = require(RS:WaitForChild("NodeFactory"))

do
	local __wrappedCache = setmetatable({}, { __mode = "k" })
	local __fnCache      = setmetatable({}, { __mode = "k" })

	local function guardFunc(nodeTbl, key, fn)
		local nodeFns = __fnCache[nodeTbl]; if not nodeFns then nodeFns = {}; __fnCache[nodeTbl] = nodeFns end
		if nodeFns[key] then return nodeFns[key] end

		local wrapped = function(...)
			-- Resolve caller from either form:
			--   node.OnStart(player, dir) OR node.Execute(player, dir)
			--   node:Execute(rootPart, extra)
			local a1, a2 = ...
			local plr = playerFromAnything(a1) or playerFromAnything(a2)
			local name = tostring(nodeTbl.Name or key or "?")
			local allowed = ALLOW_WHILE_MOUNTED[name] or nodeTbl.AllowWhileMounted

			if plr and (not allowed) and isMountedPlayer(plr) then
				dprint(("BLOCK node=%s fn=%s while mounted"):format(name, key))
				return
			end
			return fn(...)
		end
		nodeFns[key] = wrapped
		return wrapped
	end

	local function wrapNode(nodeTbl)
		if type(nodeTbl) ~= "table" then return nodeTbl end
		if __wrappedCache[nodeTbl] then return __wrappedCache[nodeTbl] end

		local proxy = setmetatable({}, {
			__index = function(_, k)
				local v = nodeTbl[k]
				if type(v) == "function" then
					return guardFunc(nodeTbl, k, v)
				else
					return v
				end
			end,
			__newindex = function(_, k, v) nodeTbl[k] = v end,
			__pairs = function() return pairs(nodeTbl) end,
			__ipairs = function() return ipairs(nodeTbl) end,
		})
		__wrappedCache[nodeTbl] = proxy
		return proxy
	end

	if type(NodeFactory) == "table" and type(NodeFactory.Create) == "function" then
		local oldCreate = NodeFactory.Create
		NodeFactory.Create = function(cfg)
			local raw = oldCreate(cfg)
			return wrapNode(raw)
		end
		dprint("Patched NodeFactory.Create")
	else
		warn("[MountedFirewall] NodeFactory.Create not found; cannot patch")
	end
end

-- ---------- Patch DamageService.DealDamage (belt-and-suspenders) ----------
do
	local ok, DamageService = pcall(function() return require(RS:WaitForChild("DamageService")) end)
	if ok and type(DamageService) == "table" and type(DamageService.DealDamage) == "function" then
		local old = DamageService.DealDamage
		DamageService.DealDamage = function(targetChar, dmg, attacker, ...)
			if isMountedAnything(attacker) then
				dprint("BLOCK damage while mounted")
				return
			end
			return old(targetChar, dmg, attacker, ...)
		end
		dprint("Patched DamageService.DealDamage")
	else
		warn("[MountedFirewall] Could not patch DamageService.DealDamage")
	end
end

===== FILE: src/server/ActivateNodeRouter.server.lua =====
-- ActivateNodeRouter.server.lua
-- Forwards ActivateNode to node module; passes camera dir + camera right
local RS = game:GetService("ReplicatedStorage")
local Remotes = RS:WaitForChild("RemoteEvents")
local ActivateNode = Remotes:WaitForChild("ActivateNode")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local okNM, NodeManager = pcall(function() return require(RS:WaitForChild("NodeManager")) end)

local function sanitizeDir(v)
	if typeof(v) ~= "Vector3" or v.Magnitude <= 0 then return nil end
	return v.Unit
end

local function orthoRight(dir, rightGuess)
	-- try provided right; make it orthogonal to dir
	if typeof(rightGuess) == "Vector3" and rightGuess.Magnitude > 0 then
		local r = (rightGuess - dir * rightGuess:Dot(dir))
		if r.Magnitude > 1e-4 then return r.Unit end
	end
	-- fallback from dir and world up
	local up = Vector3.yAxis
	local r = up:Cross(dir) -- screen-style right given look and up
	if r.Magnitude < 1e-4 then
		r = dir:Cross(up)
	end
	return r.Magnitude > 0 and r.Unit or Vector3.xAxis
end

ActivateNode.OnServerEvent:Connect(function(player, nodeName, dirVec, camRight)
	if type(nodeName) ~= "string" or nodeName == "" or #nodeName > 40 then return end
	if not PlayerDataService.HasUnlock(player, nodeName) then return end

	local dir = sanitizeDir(dirVec)
	local right = dir and orthoRight(dir, camRight) or nil

	-- Prefer NodeManager if it exposes Activate(player, nodeName, dir, right)
	if okNM and NodeManager and typeof(NodeManager.Activate) == "function" then
		local ok, err = pcall(function() NodeManager.Activate(player, nodeName, dir, right) end)
		if not ok then warn("[ActivateNodeRouter] NodeManager.Activate error:", err) end
		return
	end

	-- Fallback: require module and call OnStart(player, dir, right)
	local folder = RS:FindFirstChild("NodeModules")
	local mod = folder and folder:FindFirstChild(nodeName)
	if not (mod and mod:IsA("ModuleScript")) then return end

	local ok, nodeMod = pcall(require, mod)
	if not ok then warn("[ActivateNodeRouter] require failed:", nodeMod) return end
	if type(nodeMod) == "table" and type(nodeMod.OnStart) == "function" then
		local ok2, err2 = pcall(nodeMod.OnStart, player, dir, right)
		if not ok2 then warn("[ActivateNodeRouter] OnStart error:", err2) end
	end
end)


===== FILE: src/server/CollisionGroups.server.lua =====
-- ServerScriptService/CollisionGroups.server.lua
-- Disable collisions between player characters and enemy NPC rigs
-- using the modern CollisionGroups API.

local Players        = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService")

local GROUP_PLAYER = "Players"
local GROUP_ENEMY  = "Enemies"

-- Create/register groups (idempotent)
pcall(function() PhysicsService:RegisterCollisionGroup(GROUP_PLAYER) end)
pcall(function() PhysicsService:RegisterCollisionGroup(GROUP_ENEMY)  end)

-- Players <-> Enemies: do NOT collide
PhysicsService:CollisionGroupSetCollidable(GROUP_PLAYER, GROUP_ENEMY, false)

-- Helper: apply a collision group to all BaseParts in a model and keep it updated
local function watchModelCollisionGroup(model: Model, groupName: string)
	-- initial pass
	for _, inst in ipairs(model:GetDescendants()) do
		if inst:IsA("BasePart") then
			inst.CollisionGroup = groupName
		end
	end
	-- keep future parts in sync (accessories, cloned tools, etc.)
	model.DescendantAdded:Connect(function(inst)
		if inst:IsA("BasePart") then
			inst.CollisionGroup = groupName
		end
	end)
end

-- Treat any Model with IsEnemy=true as an enemy
local function isEnemyModel(m: Instance)
	return m:IsA("Model") and m:GetAttribute("IsEnemy") == true
end

-- Players -> GROUP_PLAYER
local function hookPlayer(plr: Player)
	local function onChar(char: Model)
		watchModelCollisionGroup(char, GROUP_PLAYER)
	end
	if plr.Character then onChar(plr.Character) end
	plr.CharacterAdded:Connect(onChar)
end

Players.PlayerAdded:Connect(hookPlayer)
for _, plr in ipairs(Players:GetPlayers()) do
	hookPlayer(plr)
end

-- Enemies -> GROUP_ENEMY
-- Apply immediately for existing enemies
for _, inst in ipairs(workspace:GetDescendants()) do
	if isEnemyModel(inst) then
		watchModelCollisionGroup(inst, GROUP_ENEMY)
	end
end

-- Watch for new enemy models or models that flip IsEnemy later
workspace.DescendantAdded:Connect(function(inst)
	if inst:IsA("Model") then
		-- If attribute appears/changes later
		inst:GetAttributeChangedSignal("IsEnemy"):Connect(function()
			if inst:GetAttribute("IsEnemy") == true then
				watchModelCollisionGroup(inst, GROUP_ENEMY)
			end
		end)
		-- If already tagged
		if isEnemyModel(inst) then
			watchModelCollisionGroup(inst, GROUP_ENEMY)
		end
	end
end)


===== FILE: src/server/EnemyBootstrap.server.lua =====
-- ServerScriptService/EnemyBootstrap.server.lua
local RS       = game:GetService("ReplicatedStorage")
local Looks    = require(RS:WaitForChild("EnemyLooks"))
local Specs    = require(RS:WaitForChild("EnemySpecs"))
local RigKit   = require(RS:WaitForChild("RigMadLibs"))

local ENEMY_ROOT = workspace:FindFirstChild("Enemies") or workspace

-- ===== AI module resolve (EnemyController preferred; fallback Controller) ===
local function resolveAIModule()
	local aiFolder = RS:WaitForChild("AI")
	local mod = aiFolder:FindFirstChild("EnemyController") or aiFolder:FindFirstChild("Controller")
	if not mod then
		warn("[EnemyBootstrap] No AI module found under ReplicatedStorage/AI (expected 'EnemyController' or 'Controller').")
		return nil
	end
	local ok, ctrl = pcall(require, mod)
	if not ok then
		warn("[EnemyBootstrap] Failed to require AI module:", ctrl)
		return nil
	end
	if type(ctrl) ~= "table" or type(ctrl.Start) ~= "function" then
		warn("[EnemyBootstrap] AI module does not return a table with Start(self, spec).")
		return nil
	end
	return ctrl
end

local Controller = resolveAIModule()

-- ===== Looks helpers ========================================================
local function firstLook(key)
	local t = Looks[key]
	return (t and #t > 0) and t[1] or nil
end

local function applyLook(model: Model, spec: table, overrideSkinKey: string?)
	if model:GetAttribute("Skinned") then return end

	local entry
	if overrideSkinKey and overrideSkinKey ~= "" then
		entry = firstLook(overrideSkinKey)
	elseif spec and spec.skinKey then
		entry = firstLook(spec.skinKey)
	elseif spec and spec.skin then
		entry = spec.skin -- inline recipe: { userId=.. | outfitId=.. | assets={..} }
	end
	if not entry then return end

	if entry.userId then
		RigKit.applyUserLook(model, entry.userId)
	elseif entry.outfitId then
		RigKit.applyOutfit(model, entry.outfitId)
	elseif entry.assets then
		RigKit.applyAssets(model, entry.assets)
	end

	model:SetAttribute("Skinned", true)
end

-- ===== Binder ===============================================================
local function bind(model: Model)
	if model:GetAttribute("Bound") then return end
	if not model:GetAttribute("IsEnemy") then return end

	local hum = model:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	local enemyId = model:GetAttribute("enemyId")
	if not enemyId or enemyId == "" then enemyId = model.Name end

	local spec = Specs[enemyId]
	if not spec then
		warn(("[EnemyBootstrap] Unknown enemyId '%s' on '%s'"):format(enemyId, model:GetFullName()))
		return
	end

	-- Appearance
	applyLook(model, spec, model:GetAttribute("SkinKey"))

	-- Defaults / labels
	model:SetAttribute("enemyType", spec.enemyType or "Unknown")
	model:SetAttribute("AIProfile", spec.aiProfile or "")
	if spec.leashRadius and model:GetAttribute("LeashRadius") == nil then
		model:SetAttribute("LeashRadius", spec.leashRadius)
	end
	if spec.DEF ~= nil then model:SetAttribute("DEF", spec.DEF) end
	if spec.OFF ~= nil then model:SetAttribute("OFF", spec.OFF) end

	-- Stats
	if spec.stats then
		if spec.stats.WalkSpeed then hum.WalkSpeed = spec.stats.WalkSpeed end
		if spec.stats.JumpPower then hum.JumpPower = spec.stats.JumpPower end
	end

	-- Start controller (only if we actually resolved it)
	if Controller then
		local ok, err = pcall(function()
			Controller.Start(model, spec)
		end)
		if not ok then
			warn("[EnemyBootstrap] Controller.Start failed:", err)
		end
	else
		warn("[EnemyBootstrap] No Controller available; enemy will not act.")
	end

	model:SetAttribute("Bound", true)
end

-- ===== Initial sweep + live binding ========================================
for _, m in ipairs(ENEMY_ROOT:GetDescendants()) do
	if m:IsA("Model") then bind(m) end
end

ENEMY_ROOT.DescendantAdded:Connect(function(inst)
	if inst:IsA("Model") then bind(inst) end
end)


===== FILE: src/server/EnemySpawner.server.lua =====
-- ServerScriptService/EnemySpawner.server.lua  âœ… clean, self-contained
local ServerStorage = game:GetService("ServerStorage")

local ENEMY_PREFABS = ServerStorage:WaitForChild("Enemies")
local LEASHES       = workspace:FindFirstChild("EnemyLeashes")  -- folder of pads

local function ensureEnemiesFolder()
	local f = workspace:FindFirstChild("Enemies")
	if not f then
		f = Instance.new("Folder")
		f.Name = "Enemies"
		f.Parent = workspace
	end
	return f
end

local ENEMY_ROOT = ensureEnemiesFolder()

local function topCenterCF(p: BasePart)
	return p.CFrame * CFrame.new(0, p.Size.Y/2 + 3, 0)
end

local function spawnFromFolder(folder: Instance, prefabName: string): Model?
	local src = folder:FindFirstChild(prefabName)
	return (src and src:Clone()) or nil
end

local function pivotAndFace(rig: Model, cf: CFrame)
	if not rig.PrimaryPart then
		local hrp = rig:FindFirstChild("HumanoidRootPart")
		if hrp then rig.PrimaryPart = hrp end
	end
	rig:PivotTo(cf)
end

local function spawnEnemyAt(leash: BasePart, offset: CFrame?)
	local prefabName = leash:GetAttribute("Prefab")
	if not prefabName or prefabName == "" then
		warn("[EnemySpawner] Leash missing Prefab:", leash:GetFullName())
		return nil
	end

	local rig = spawnFromFolder(ENEMY_PREFABS, prefabName)
	if not rig then
		warn("[EnemySpawner] Enemy prefab not found:", prefabName)
		return nil
	end

	rig.Name   = prefabName
	rig.Parent = ENEMY_ROOT
	pivotAndFace(rig, topCenterCF(leash) * (offset or CFrame.new()))

	-- Identity & behavior (enemyId is your â€œenemy storyIdâ€)
	local enemyId = leash:GetAttribute("EnemyId") or prefabName
	rig:SetAttribute("IsEnemy", true)
	rig:SetAttribute("enemyId", enemyId)

	-- Optional overrides
	local skinKey = leash:GetAttribute("SkinKey")
	if skinKey and skinKey ~= "" then rig:SetAttribute("SkinKey", skinKey) end

	rig:SetAttribute("LeashRadius", leash:GetAttribute("LeashRadius") or 30)
	rig:SetAttribute("ArenaId",     leash:GetAttribute("ArenaId") or "")

	-- Pointer back to the leash
	local leashRef = Instance.new("ObjectValue")
	leashRef.Name  = "LeashPoint"
	leashRef.Value = leash
	leashRef.Parent = rig

	-- Respawn (default true)
	local respawn = leash:GetAttribute("Respawn")
	if respawn == nil then respawn = true end
	if respawn then
		local hum = rig:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Died:Connect(function()
				local t = leash:GetAttribute("RespawnTime") or 10
				task.delay(t, function()
					if leash.Parent then spawnEnemyAt(leash) end
				end)
			end)
		end
	end

	print(("[EnemySpawner] âœ… Spawned %s at %s (enemyId=%s)")
		:format(prefabName, leash.Name, enemyId))
	return rig
end

-- ===== Boot =====
if not LEASHES then
	warn("[EnemySpawner] No 'EnemyLeashes' folder found in Workspace. Create one and add pads with attributes.")
	return
end

for _, leash in ipairs(LEASHES:GetChildren()) do
	if leash:IsA("BasePart") then
		local count = tonumber(leash:GetAttribute("Count")) or 1
		for i = 1, count do
			local angle = (i-1) * (math.pi * 2 / math.max(1, count))
			local off = CFrame.new(math.cos(angle) * 2, 0, math.sin(angle) * 2)
			spawnEnemyAt(leash, off)
		end
	end
end


===== FILE: src/server/GameInit.server.lua =====
-- src/server/GameInit.server.lua
-- Creates remotes, wires player load/unload, boots story + keybind systems.

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local sss               = script.Parent
local PlayerDataService = require(sss:WaitForChild("PlayerDataService"))
local NodeManager       = require(ReplicatedStorage:WaitForChild("NodeManager"))

-- Remote bootstrap -----------------------------------------------------------
local remotes = ReplicatedStorage:FindFirstChild("RemoteEvents") or Instance.new("Folder")
remotes.Name = "RemoteEvents"
remotes.Parent = ReplicatedStorage

local function ensureRemote(name)
	local ev = remotes:FindFirstChild(name)
	if not ev then
		ev = Instance.new("RemoteEvent")
		ev.Name = name
		ev.Parent = remotes
	end
	return ev
end

local function ensureRemoteFunction(name)
	local rf = remotes:FindFirstChild(name)
	if not rf then
		rf = Instance.new("RemoteFunction")
		rf.Name = name
		rf.Parent = remotes
	end
	return rf
end

-- Events used elsewhere
ensureRemote("ActivateNode")
ensureRemote("UnlockNode")
ensureRemote("NodeActions")
ensureRemote("ConfirmSuccess")
ensureRemote("CooldownNotice")
ensureRemote("DodgeCharges")
ensureRemote("UnlockStory")
ensureRemote("BeginDialogue")
ensureRemote("ChooseOption")
ensureRemote("DialogueUpdate")

-- Keybind RemoteFunctions
ensureRemoteFunction("GetKeybinds")
ensureRemoteFunction("SetKeybind")
ensureRemoteFunction("GetUnlockedNodes")

-- Story scaffolding folders (donâ€™t rely on Studio placement)
local storyAllow = ReplicatedStorage:FindFirstChild("StoryUnlockables") or Instance.new("Folder", ReplicatedStorage)
storyAllow.Name = "StoryUnlockables"
local stories = ReplicatedStorage:FindFirstChild("Stories") or Instance.new("Folder", ReplicatedStorage)
stories.Name = "Stories"

-- Player lifecycle -----------------------------------------------------------
Players.PlayerAdded:Connect(function(player)
	local profile = PlayerDataService.WaitForProfile(player, 10)
	if not profile then
		warn("[GameInit] Profile failed to load for", player.Name)
		return
	end
	NodeManager.LoadUnlocked(player, profile)
end)

Players.PlayerRemoving:Connect(function(player)
	NodeManager.Unload(player)
end)

-- Boot story/keybind systems -------------------------------------------------
require(sss:WaitForChild("StoryDataService"))
require(sss:WaitForChild("StoryUnlockHandler"))
require(sss:WaitForChild("StoryDialogueHandler"))
require(sss:WaitForChild("StoryUnlockables")) -- list/allow rules
require(sss:WaitForChild("KeybindHandler"))

return true


===== FILE: src/server/GuardBreakEnforcer.server.lua =====
-- ServerScriptService/GuardBreakEnforcer.server.lua
-- Robust guard-break enforcement + anti-hold-F reblock during rearm.

local Players           = game:GetService("Players")
local RS                = game:GetService("ReplicatedStorage")

local NodeSense         = require(RS:WaitForChild("NodeSense"))
local CombatState       = require(RS:WaitForChild("CombatState"))
local DamageService     = require(RS:WaitForChild("DamageService"))
local StunService       = require(RS:WaitForChild("StunService"))
local CooldownService   = require(RS:WaitForChild("CooldownService"))
local SpeedController   = require(RS:WaitForChild("SpeedController"))
local GuardService      = require(RS:WaitForChild("GuardService"))

local GUARD_BREAK_STUN  = 0.45   -- hard-stun on break
local GUARD_BREAK_REARM = 1.10   -- cannot re-block during this window
local BASE_WALK         = 16     -- fallback for NPC models

local function asModel(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model") then return ent end
	return nil
end

local function asPlayer(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent end
	return Players:GetPlayerFromCharacter(ent)
end

local function humOf(ent)
	local m = asModel(ent)
	return m and m:FindFirstChildOfClass("Humanoid") or nil
end

-- Resolve the defender for a GuardBroken outcome, regardless of nodeName
local function resolveDefender(payload)
	-- Case A: guard events emitted from "Block" use the defender as actor
	if tostring(payload.nodeName) == "Block" then
		return payload.actorPlayer or payload.actorModel
	end

	-- Case B: emitted from the attacker node, target is in context.targetId
	local ctx = payload.context or {}
	if ctx.targetId then
		local plr = Players:GetPlayerByUserId(ctx.targetId)
		if plr then return plr end
	end

	-- Fallback: nearest blocking humanoid to the attacker (best-effort)
	local attackerModel = payload.actorModel
	local attackerHRP   = attackerModel and attackerModel:FindFirstChild("HumanoidRootPart")
	if not attackerHRP then return nil end

	local nearest, nd = nil, 10
	for _, plr in ipairs(Players:GetPlayers()) do
		local ch = plr.Character
		local hum = ch and ch:FindFirstChildOfClass("Humanoid")
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hum and hrp and hum.Health > 0 then
			local d = (hrp.Position - attackerHRP.Position).Magnitude
			if d < nd and GuardService.IsBlocking(plr) then
				nearest, nd = plr, d
			end
		end
	end
	return nearest
end

local function forceUnblock(target)
	-- 1) End block + unlock + stop hold anim/track
	pcall(DamageService.EndBlock, target)
	pcall(CombatState.StopCurrentTrack, target)
	pcall(CombatState.Unlock, target, "GuardBroken")

	-- 2) Clear any block slow / restore speed
	local plr = asPlayer(target)
	if plr then
		pcall(SpeedController.Reset, plr)
	else
		local hum = humOf(target)
		if hum then hum.WalkSpeed = BASE_WALK end
	end

	-- 3) Brief hard-stun to sell the break
	pcall(StunService.Apply, target, GUARD_BREAK_STUN, { hard = true })

	-- 4) Re-arm cooldown so holding F canâ€™t instantly re-block
	pcall(CooldownService.Apply, target, "BlockRearm", GUARD_BREAK_REARM)
end

-- If the player tries to BlockStart while BlockRearm is active, cancel it immediately.
local function cancelIllegalBlockStart(actor)
	if not actor then return end
	-- If they cannot use BlockRearm yet, they are still in rearm window.
	if not CooldownService.CanUse(actor, "BlockRearm") then
		-- Immediately force them out of block (prevents â€œhold Fâ€ exploit)
		forceUnblock(actor)
	end
end

-- Subscribe to NodeSense
if NodeSense.ServerEvent then
	NodeSense.ServerEvent.Event:Connect(function(payload)
		if not payload or not payload.context then return end
		local outcome = payload.context.outcome

		-- Enforce on GuardBroken from ANY node
		if outcome == "GuardBroken" then
			local defender = resolveDefender(payload)
			if defender then
				forceUnblock(defender)
			else
				warn("[GuardBreakEnforcer] GuardBroken without resolvable defender for node=", payload.nodeName)
			end
			return
		end

		-- Stop illegal re-block attempts during rearm
		if outcome == "BlockStart" then
			local actor = payload.actorPlayer or payload.actorModel
			cancelIllegalBlockStart(actor)
		end
	end)
else
	warn("[GuardBreakEnforcer] NodeSense.ServerEvent not available; enforcer inactive.")
end


===== FILE: src/server/HorseMountServer.server.lua =====
-- ServerScriptService/HorseMountServer.lua
-- W = throttle, Space = jump, Q (client) = gallop (spends DodgeCharge), R = dismount.

-- ========= Animation IDs =========
local WALK_ANIM_ID   = "rbxassetid://81146949344342"
local JUMP_ANIM_ID   = "rbxassetid://98771585060096"
local GALLOP_ANIM_ID = "rbxassetid://83469750908764" -- loop during gallop

-- ========= Services / Deps =========
local Players     = game:GetService("Players")
local RS          = game:GetService("ReplicatedStorage")
local Workspace   = game:GetService("Workspace")
local RunService  = game:GetService("RunService")

local CombatState       = require(RS:WaitForChild("CombatState"))
local DodgeCharges      = require(RS:WaitForChild("DodgeChargeService"))
local PlayerDataService = require(game:GetService("ServerScriptService"):WaitForChild("PlayerDataService"))

-- ========= Remotes (auto-created) =========
local Remotes = RS:FindFirstChild("RemoteEvents") or Instance.new("Folder", RS)
Remotes.Name = "RemoteEvents"

local function ensureRemote(name)
	local r = Remotes:FindFirstChild(name)
	if not r then r = Instance.new("RemoteEvent"); r.Name = name; r.Parent = Remotes end
	return r
end

local RE_Face      = ensureRemote("Horse_Face")
local RE_Move      = ensureRemote("Horse_Move")
local RE_Jump      = ensureRemote("Horse_Jump")
local RE_Dismount  = ensureRemote("Horse_RequestDismount")
local RE_LockMoves = ensureRemote("LockMoves")
local RE_Gallop    = ensureRemote("Horse_Gallop")
local ConfirmSuccess = ensureRemote("ConfirmSuccess") -- ensure it's present for toasts

-- ========= Defaults (per-horse Attributes can override) =========
local SEAT_NAME               = "SaddleSeat"
local DEFAULT_SPEED           = 32
local DEFAULT_JUMP_POWER      = 30
local DEFAULT_JUMP_IMPULSE    = 60
local DEFAULT_JUMP_COOLDOWN   = 1.0

local REQUIRE_GROUND_TO_JUMP  = true
local DEFAULT_SURFACE_YAW_DEG = -90
local DEFAULT_FORWARD_BASIS   = "Left"
local DEFAULT_GROUND_RAY      = 12

local DEFAULT_FRICTION_K      = 2.5
local FRICTION_BOOST_VALUE    = 1.25

-- Gallop
local DEFAULT_GALLOP_MULT     = 2.0   -- BaseSpeed * mult
local DEFAULT_GALLOP_DURATION = 1.5   -- seconds per charge

-- Display
local PLAYER_HORSE_NAME       = "Get That Call"

-- mounts[player] = {...}
local mounts = {}

-- ========= Logging =========
local DEBUG = true
local function slog(st, ...) if (st and st.debug) or DEBUG then print("[HORSE]", ...) end end
local function swarn(st, ...) if (st and st.debug) or DEBUG then warn("[HORSE]", ...) end end

-- ========= Helpers =========
local function findHorseFromSeat(seat: Instance)
	if not (seat and seat:IsA("Seat") and seat.Name == SEAT_NAME) then return nil end
	local m = seat:FindFirstAncestorOfClass("Model")
	if m and m:GetAttribute("IsHorse") then return m end
	return nil
end

local function ensureHumanoid(horse: Model)
	local hum = horse:FindFirstChildOfClass("Humanoid")
	if not hum then hum = Instance.new("Humanoid", horse) end
	hum.AutoRotate   = false
	hum.UseJumpPower = true
	hum.WalkSpeed    = horse:GetAttribute("BaseSpeed") or DEFAULT_SPEED
	hum.JumpPower    = horse:GetAttribute("HorseJumpPower") or DEFAULT_JUMP_POWER
	return hum
end

local function buildFacingConstraint(horse: Model)
	local root = horse.PrimaryPart or horse:FindFirstChild("HumanoidRootPart")
	if not (root and root:IsA("BasePart")) then return end

	local att0 = root:FindFirstChild("_HorseA0")
	if not att0 then
		att0 = Instance.new("Attachment")
		att0.Name = "_HorseA0"
		att0.CFrame = CFrame.new()
		att0.Parent = root
	end

	local sensorPart = Instance.new("Part")
	sensorPart.Name = "_HorseSensor"
	sensorPart.Size = Vector3.new(0.2, 0.2, 0.2)
	sensorPart.Transparency = 1
	sensorPart.CanCollide = false
	sensorPart.Anchored = true
	sensorPart.CFrame = root.CFrame
	sensorPart.Parent = Workspace

	local sensorAtt = Instance.new("Attachment")
	sensorAtt.Name = "_HorseA1"
	sensorAtt.Parent = sensorPart

	local ao = Instance.new("AlignOrientation")
	ao.Name = "_HorseFace"
	ao.Attachment0 = att0
	ao.Attachment1 = sensorAtt
	ao.RigidityEnabled = true
	ao.Responsiveness = 200
	pcall(function() ao.MaxTorque = math.huge end)
	ao.Parent = root

	return ao, att0, sensorPart, sensorAtt
end

local function setMovesLocked(player: Player, locked: boolean)
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	if hum then hum:SetAttribute("Mounted", locked) end
	if locked then
		CombatState.Lock(player)
		pcall(function() CombatState.StopCurrentTrack(player) end)
	else
		CombatState.Unlock(player)
		pcall(function() CombatState.SetUnlockBuffer(player, 0.2) end)
	end
	RE_LockMoves:FireClient(player, locked)
end

local function applyFrictionBoost(st, enable: boolean)
	if st.frictionApplied == enable then return end
	st.frictionApplied = enable
	if enable then st._origPhys = st._origPhys or {} end
	for _, d in ipairs(st.horse:GetDescendants()) do
		if d:IsA("BasePart") then
			if enable then
				if not st._origPhys[d] then st._origPhys[d] = d.CustomPhysicalProperties end
				local cp = d.CustomPhysicalProperties
				local density    = (cp and cp.Density) or 1
				local elasticity = (cp and cp.Elasticity) or 0
				local friction   = math.max(FRICTION_BOOST_VALUE, (cp and cp.Friction) or 0.3)
				d.CustomPhysicalProperties = PhysicalProperties.new(density, friction, elasticity, 1, 1)
			else
				d.CustomPhysicalProperties = st._origPhys[d]
			end
		end
	end
	if not enable then st._origPhys = nil end
end

local function cleanupMount(st)
	if st.hbConn then st.hbConn:Disconnect() end
	if st.stateConn then st.stateConn:Disconnect() end
	if st.watch then for _, c in ipairs(st.watch) do pcall(function() c:Disconnect() end) end end
	if st.ao then st.ao:Destroy() end
	if st.att0 then st.att0:Destroy() end
	if st.sensorAtt then st.sensorAtt:Destroy() end
	if st.sensorPart then st.sensorPart:Destroy() end

	for _, track in ipairs({st.gallopTrack, st.walkTrack, st.jumpTrack}) do
		if track then pcall(function() track:Stop(0.1); track:Destroy() end) end
	end
	st.gallopTrack, st.walkTrack, st.jumpTrack = nil, nil, nil

	pcall(function()
		if st.horse then
			local hum = st.horse:FindFirstChildOfClass("Humanoid")
			if hum then hum.DisplayName = st.origDisplayName or "" end
			if st.origModelName then st.horse.Name = st.origModelName end
		end
	end)

	st.baseSpeed = st.nominalSpeed or DEFAULT_SPEED
	applyFrictionBoost(st, false)
end

local function forceDismountSeat(seat: Seat, st)
	local occ = seat.Occupant
	if occ then
		occ.Sit = false
		pcall(function() seat:Sit(nil) end)
		pcall(function() occ.Jump = true end)
	end
	local weld = seat:FindFirstChild("SeatWeld"); if weld then weld:Destroy() end
	if occ and occ.Parent then
		local hrp = occ.Parent:FindFirstChild("HumanoidRootPart")
		if hrp then hrp.CFrame = hrp.CFrame + Vector3.new(0, 3, 0) end
	end
end

local function dismount(player: Player)
	local st = mounts[player]
	
	if not st then return end

	if st.riderHum then
		pcall(function()
			st.riderHum:SetStateEnabled(Enum.HumanoidStateType.Jumping, st.riderJumpingEnabled ~= false)
			st.riderHum.AutoJumpEnabled = (st.riderAutoJump == true)
			st.riderHum.Sit = false
			st.riderHum.Jump = true
		end)
	end

	local hHum = st.horse and st.horse:FindFirstChildOfClass("Humanoid")
	if hHum then hHum:Move(Vector3.zero) end
	if st.seat and st.seat:IsA("Seat") then forceDismountSeat(st.seat, st) end

	cleanupMount(st)
	setMovesLocked(player, false)
	mounts[player] = nil
end

Players.PlayerRemoving:Connect(dismount)

-- Grounded check
local function isGrounded(hum: Humanoid?, root: BasePart?, rayLen: number)
	if hum and hum.FloorMaterial ~= Enum.Material.Air then return true end
	if not root then return false end
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = {root.Parent}
	local hit = Workspace:Raycast(root.Position, Vector3.new(0, -rayLen, 0), params)
	return hit ~= nil
end

-- Verify rider
local function isCurrentRider(player: Player, st): boolean
	if not (st and st.seat and st.seat.Occupant) then return false end
	local occChar = st.seat.Occupant.Parent
	return occChar == (player.Character or nil)
end

-- ========= Anim state chooser =========
local function updateMoveAnim(st)
	if not st then return end
	local now = os.clock()
	local galloping = (st.gallopUntil or 0) > now and st.throttle

	if not st.throttle then
		if st.gallopTrack and st.gallopTrack.IsPlaying then st.gallopTrack:Stop(0.12) end
		if st.walkTrack   and st.walkTrack.IsPlaying   then st.walkTrack:Stop(0.12)   end
		return
	end

	if galloping then
		if st.walkTrack   and st.walkTrack.IsPlaying       then st.walkTrack:Stop(0.10) end
		if st.gallopTrack and not st.gallopTrack.IsPlaying then st.gallopTrack:Play(0.10, 1, 1.0) end
	else
		if st.gallopTrack and st.gallopTrack.IsPlaying     then st.gallopTrack:Stop(0.10) end
		if st.walkTrack   and not st.walkTrack.IsPlaying   then st.walkTrack:Play(0.12, 1, 1.0)   end
	end
end

-- ========= Orientation stream =========
RE_Face.OnServerEvent:Connect(function(player: Player, horse: Model, sensorCF: CFrame)
	local st = mounts[player]
	if not (st and st.horse == horse and isCurrentRider(player, st)) then return end
	local root = st.horse.PrimaryPart or st.horse:FindFirstChild("HumanoidRootPart")
	if not (root and st.sensorPart) then return end
	if typeof(sensorCF) ~= "CFrame" then return end

	local f = sensorCF.LookVector; f = Vector3.new(f.X, 0, f.Z)
	if f.Magnitude < 1e-3 then f = Vector3.new(0,0,-1) else f = f.Unit end

	local base = CFrame.lookAt(root.Position, root.Position + f, Vector3.yAxis)
	local modelOffset   = math.rad(st.horse:GetAttribute("YawOffsetDeg") or 0)
	local surfaceOffset = math.rad(st.horse:GetAttribute("SurfaceYawOffsetDeg") or DEFAULT_SURFACE_YAW_DEG)
	st.sensorPart.CFrame = base * CFrame.Angles(0, modelOffset + surfaceOffset, 0)
end)

-- ========= Move (W) =========
RE_Move.OnServerEvent:Connect(function(player: Player, horse: Model, forwardDown: boolean)
	local st = mounts[player]
	if not (st and st.horse == horse and isCurrentRider(player, st)) then return end
	st.throttle = forwardDown and true or false
	updateMoveAnim(st)
end)

-- ========= Jump (Space) =========
RE_Jump.OnServerEvent:Connect(function(player: Player)
	local st = mounts[player]
	if not (st and isCurrentRider(player, st)) then return end
	slog(st, "Jump remote received")

	local now = time()
	local cd = st.horse:GetAttribute("HorseJumpCooldown")
	if cd == nil then cd = DEFAULT_JUMP_COOLDOWN end
	if (st.nextJumpTime or 0) > now then return end

	local hum  = st.horse:FindFirstChildOfClass("Humanoid")
	local root = st.horse.PrimaryPart or st.horse:FindFirstChild("HumanoidRootPart")
	if not hum then swarn(st, "Jump aborted: no horse Humanoid"); return end

	local requireGround = st.horse:GetAttribute("RequireGroundToJump")
	if requireGround == nil then requireGround = REQUIRE_GROUND_TO_JUMP end
	local rayLen = st.horse:GetAttribute("JumpGroundRay") or DEFAULT_GROUND_RAY

	if (not requireGround) or isGrounded(hum, root, rayLen) then
		st.nextJumpTime = now + cd
		hum.Jump = true
		if st.jumpTrack then pcall(function() st.jumpTrack:Play(0.05, 1, 1.0) end) end
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
		if root then
			local mult = st.horse:GetAttribute("HorseJumpImpulse") or DEFAULT_JUMP_IMPULSE
			local mass = root.AssemblyMass or 100
			root:ApplyImpulse(Vector3.new(0, mass * mult, 0))
		end
	end
end)

-- ========= Gallop (spends DodgeCharge) =========
local function startOrExtendGallop(player: Player, st)
	if not st or not st.horse then return end
	local mult = st.horse:GetAttribute("GallopMult");     if mult == nil then mult = DEFAULT_GALLOP_MULT end
	local dur  = st.horse:GetAttribute("GallopDuration"); if dur  == nil then dur  = DEFAULT_GALLOP_DURATION end

	st.baseSpeed   = (st.nominalSpeed or DEFAULT_SPEED) * mult
	local now      = os.clock()
	st.gallopUntil = math.max(st.gallopUntil or 0, now + dur)

	st.gallopToken = (st.gallopToken or 0) + 1
	local myTok    = st.gallopToken

	updateMoveAnim(st)

	task.delay(dur, function()
		if mounts[player] == st and st.gallopToken == myTok and os.clock() >= (st.gallopUntil or 0) then
			st.baseSpeed = st.nominalSpeed or DEFAULT_SPEED
			updateMoveAnim(st)
		end
	end)
end

-- ===== UX toasts (rate-limited) =====
local _toastAt = setmetatable({}, { __mode = "k" })
local function toast(player, msg)
	local now, last = os.clock(), _toastAt[player] or 0
	if (now - last) < 1.0 then return end -- 1s cooldown for any toast
	_toastAt[player] = now
	ConfirmSuccess:FireClient(player, { ok = false, msg = msg })
end

RE_Gallop.OnServerEvent:Connect(function(player: Player)
	-- If this prints, the client actually fired the remote:
	print("[HORSE] RE_Gallop from", player.Name)

	local st = mounts[player]
	if not st then
		toast(player, "You must be mounted to gallop.")
		return
	end
	if not isCurrentRider(player, st) then
		toast(player, "You must be mounted to gallop.")
		return
	end

	-- Durable unlock gate (ProfileService-backed). Attribute fallback for legacy.
	local hasUnlock = false
	local ok, res = pcall(function() return PlayerDataService.HasUnlock(player, "Gallop") end)
	if ok then hasUnlock = res end
	if not hasUnlock and player:GetAttribute("HasGallop") ~= true then
		toast(player, "You haven't learned Gallop yet.")
		return
	end

	-- Shared charge pool with dodge:
	if not DodgeCharges.CanDodge(player) then
		toast(player, "No stamina to gallop.")
		return
	end
	if not DodgeCharges.Consume(player) then
		toast(player, "No stamina to gallop.")
		return
	end

	startOrExtendGallop(player, st)
end)

-- ========= Dismount (R) =========
RE_Dismount.OnServerEvent:Connect(function(player: Player)
	print("[HORSE] RE_Dismount from", player.Name)
	dismount(player)
end)

-- ========= Seat watcher (mount/dismount) =========
local function hookSeat(seat: Seat)
	if seat:GetAttribute("HorseSeatHooked") then return end
	seat:SetAttribute("HorseSeatHooked", true)

	seat:GetPropertyChangedSignal("Occupant"):Connect(function()
		local horse = findHorseFromSeat(seat)
		if not horse then return end

		local occ = seat.Occupant
		if occ and occ.Parent then
			local player = Players:GetPlayerFromCharacter(occ.Parent)
			if not player then return end

			if mounts[player] then dismount(player) end

			local hum = ensureHumanoid(horse)
			local ao, att0, sensorPart, sensorAtt = buildFacingConstraint(horse)

			-- Animator + tracks
			local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

			local walkAnim = Instance.new("Animation"); walkAnim.AnimationId = WALK_ANIM_ID
			local walk = animator:LoadAnimation(walkAnim); walk.Looped = true

			local jumpAnim = Instance.new("Animation"); jumpAnim.AnimationId = JUMP_ANIM_ID
			local jump = animator:LoadAnimation(jumpAnim); jump.Looped = false

			local galAnim = Instance.new("Animation"); galAnim.AnimationId = GALLOP_ANIM_ID
			local gallop = animator:LoadAnimation(galAnim); gallop.Looped = true

			for _, d in ipairs(horse:GetDescendants()) do if d:IsA("BasePart") then d.Anchored = false end end
			if horse.PrimaryPart then pcall(function() horse.PrimaryPart:SetNetworkOwner(nil) end) end

			local riderHum = occ
			local prevJump, prevAuto = true, true
			pcall(function()
				prevJump = riderHum:GetStateEnabled(Enum.HumanoidStateType.Jumping)
				prevAuto = riderHum.AutoJumpEnabled
				riderHum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
				riderHum.AutoJumpEnabled = false
			end)

			local prevModelName = horse.Name
			local prevDisplay   = hum.DisplayName
			pcall(function() hum.DisplayName = PLAYER_HORSE_NAME end)

			local debug     = horse:GetAttribute("DebugHorse")
			local basisAttr = tostring(horse:GetAttribute("ForwardBasis") or DEFAULT_FORWARD_BASIS)
			local baseSpeed = horse:GetAttribute("BaseSpeed") or DEFAULT_SPEED

			local st = {
				horse = horse, seat = seat,
				nominalSpeed = baseSpeed,
				baseSpeed    = baseSpeed,
				forwardBasis = basisAttr,
				frictionK    = horse:GetAttribute("FrictionImpulseK") or DEFAULT_FRICTION_K,
				debug = (debug == nil) and true or (debug == true),

				ao = ao, att0 = att0, sensorPart = sensorPart, sensorAtt = sensorAtt,

				riderHum = riderHum, riderJumpingEnabled = prevJump, riderAutoJump = prevAuto,

				throttle = false, wasThrottle = false, hbConn = nil,
				frictionApplied = false, _origPhys = nil,

				walkTrack = walk, jumpTrack = jump, gallopTrack = gallop,
				stateConn = nil,

				nextJumpTime = 0,
				gallopUntil  = 0, gallopToken = 0,

				origModelName = prevModelName, origDisplayName = prevDisplay,
				watch = {},
			}

			-- Stop jump anim when we land
			st.stateConn = hum.StateChanged:Connect(function(_, new)
				if new == Enum.HumanoidStateType.Landed then
					if st.jumpTrack and st.jumpTrack.IsPlaying then st.jumpTrack:Stop(0.1) end
				end
			end)

			-- Auto-dismount watchers
			local function autoDismount(reason)
				if mounts[player] then slog(st, "Auto-dismount ("..reason..")"); dismount(player) end
			end
			table.insert(st.watch, horse.AncestryChanged:Connect(function(_, parent) if parent == nil then autoDismount("horse destroyed") end end))
			table.insert(st.watch, seat.AncestryChanged:Connect(function(_, parent)  if parent == nil then autoDismount("seat destroyed")  end end))

			local char = player.Character
			if char then
				local pHum = char:FindFirstChildOfClass("Humanoid")
				if pHum then table.insert(st.watch, pHum.Died:Connect(function() autoDismount("player died") end)) end
				table.insert(st.watch, char.AncestryChanged:Connect(function(_, parent) if parent == nil then autoDismount("character removed") end end))
			end

			slog(st, "Mounted. Speed=", st.baseSpeed, " Basis=", st.forwardBasis, " FricK=", st.frictionK)

			-- SERVER HEARTBEAT: clamp velocity, braking, friction
			st.hbConn = RunService.Heartbeat:Connect(function()
				if not st or not st.horse then return end
				local root = st.horse.PrimaryPart or st.horse:FindFirstChild("HumanoidRootPart")
				local hHum = st.horse:FindFirstChildOfClass("Humanoid")
				if not (root and hHum) then return end

				-- Make forward vector from basis
				local f = (function()
					if st.forwardBasis == "Right" then return root.CFrame.RightVector
					elseif st.forwardBasis == "Left" then return -root.CFrame.RightVector
					elseif st.forwardBasis == "Back" then return -root.CFrame.LookVector
					else return root.CFrame.LookVector end
				end)()
				f = Vector3.new(f.X, 0, f.Z); if f.Magnitude > 0 then f = f.Unit end

				local speed  = st.baseSpeed or DEFAULT_SPEED
				local target = st.throttle and (f * speed) or Vector3.zero

				local v = root.AssemblyLinearVelocity
				local horiz = Vector3.new(v.X, 0, v.Z)

				-- On W release: exact cancel + friction boost
				if st.wasThrottle and (not st.throttle) then
					local mass = root.AssemblyMass or 100
					local k    = st.frictionK or DEFAULT_FRICTION_K
					local cancelImpulse = -horiz * mass * k
					root:ApplyImpulse(cancelImpulse)
					applyFrictionBoost(st, true)
				end

				-- Clamp horizontal velocity
				local tx = math.abs(target.X) < 1e-5 and 0 or target.X
				local tz = math.abs(target.Z) < 1e-5 and 0 or target.Z
				root.AssemblyLinearVelocity = Vector3.new(tx, v.Y, tz)

				if not st.throttle then
					local rayLen   = st.horse:GetAttribute("JumpGroundRay") or DEFAULT_GROUND_RAY
					local grounded = isGrounded(hHum, root, rayLen)
					local v2       = root.AssemblyLinearVelocity
					local h2       = Vector3.new(v2.X, 0, v2.Z)
					local vyThresh = st.horse:GetAttribute("StopVYThreshold") or 0.75

					if grounded or h2.Magnitude > 0.02 then
						local vy = (math.abs(v2.Y) < vyThresh) and 0 or v2.Y
						root.AssemblyLinearVelocity = Vector3.new(0, vy, 0)
					end

					-- Kill tiny spin; keep yaw
					local av = root.AssemblyAngularVelocity
					root.AssemblyAngularVelocity = Vector3.new(0, av.Y, 0)
					hHum:Move(Vector3.zero)
				else
					if st.frictionApplied then applyFrictionBoost(st, false) end
				end

				-- Drive animations continuously
				updateMoveAnim(st)
				st.wasThrottle = st.throttle
			end)

			setMovesLocked(player, true)
			mounts[player] = st
		else
			for p, st in pairs(mounts) do
				if st.seat == seat then slog(st, "Seat emptied â†’ dismount"); dismount(p); break end
			end
		end
	end)
end

local function scan(scope: Instance)
	for _, inst in ipairs(scope:GetDescendants()) do
		if inst:IsA("Seat") and inst.Name == SEAT_NAME then
			if findHorseFromSeat(inst) then hookSeat(inst) end
		end
	end
end

scan(Workspace)
Workspace.DescendantAdded:Connect(function(inst)
	if inst:IsA("Seat") and inst.Name == SEAT_NAME then
		if findHorseFromSeat(inst) then hookSeat(inst) end
	end
end)

-- Horse Attributes:
--   IsHorse=true (required)
--   BaseSpeed (number) [default 32]
--   HorseJumpPower (number) [default 30]
--   HorseJumpImpulse (number) [default 60]
--   HorseJumpCooldown (number) [default 1.0]
--   RequireGroundToJump (bool) [default true]
--   YawOffsetDeg (number) [default 0]
--   SurfaceYawOffsetDeg (number) [default -90]
--   ForwardBasis "Look"|"Right"|"Left"|"Back" [default "Left"]
--   JumpGroundRay (number) [default 12]
--   FrictionImpulseK (number) [default 2.5]
--   DebugHorse (bool) [default true]
--   GallopMult (number) [default 2.0]
--   GallopDuration (number seconds) [default 1.5]


===== FILE: src/server/HorseMoveBlockServer.server.lua =====

-- Blocks combat/move remotes and tools while the player is mounted

local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")

-- ðŸ” CHANGE THESE to match your gameâ€™s remotes (add more if you have them):
local REMOTE_NAMES = {
	"ActivateNode",      -- e.g., your combat/ability trigger
	"UseAbility",        -- example
	"CastSkill",         -- example
}

-- === Reject "move" remotes while mounted ===
for _, name in ipairs(REMOTE_NAMES) do
	local re = RS:FindFirstChild("RemoteEvents") and RS.RemoteEvents:FindFirstChild(name)
	if re and re:IsA("RemoteEvent") then
		re.OnServerEvent:Connect(function(player, ...)
			local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
			if hum and hum:GetAttribute("Mounted") then
				-- hard reject
				return
			end
			-- else: let your existing handler run (this script is a guard, not the main logic)
		end)
	end
end

-- === Optional: block Tools while mounted (unequip instantly) ===
local function hookCharacter(player: Player, char: Model)
	local hum = char:WaitForChild("Humanoid")

	-- if player equips a Tool while mounted, instantly unequip it
	hum.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			if hum:GetAttribute("Mounted") then
				hum:UnequipTools()
			end
			-- also guard the Toolâ€™s own Activated
			child.Activated:Connect(function()
				if hum:GetAttribute("Mounted") then
					hum:UnequipTools()
				end
			end)
		end
	end)

	-- also watch Backpack â†’ move to character
	local backpack = player:FindFirstChildOfClass("Backpack")
	if backpack then
		backpack.ChildAdded:Connect(function(tool)
			if tool:IsA("Tool") then
				tool.Activated:Connect(function()
					if hum:GetAttribute("Mounted") then
						hum:UnequipTools()
					end
				end)
			end
		end)
	end
end

Players.PlayerAdded:Connect(function(p)
	p.CharacterAdded:Connect(function(c) hookCharacter(p, c) end)
	if p.Character then hookCharacter(p, p.Character) end
end)


===== FILE: src/server/HorseService.lua =====
-- ServerScriptService/HorseService.lua
-- Robust horse spawner/manager. Finds RS.Horses.Default, parents into Workspace.Horses,
-- tags with attributes, auto-mounts, and logs loudly if anything goes wrong.

local Players   = game:GetService("Players")
local RS        = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local HorseService = {}
local ACTIVE = {} -- [Player] = Model

local DEBUG = true
local HORSES_FOLDER_NAME = "Horses" -- live horses go under Workspace/Horses

local function log(...) if DEBUG then print("[HorseService]", ...) end end

-- Workspace/Horses container (many firewalls whitelist folders)
local function getOrCreateHorsesFolder()
	local f = Workspace:FindFirstChild(HORSES_FOLDER_NAME)
	if not f then
		f = Instance.new("Folder")
		f.Name = HORSES_FOLDER_NAME
		f.Parent = Workspace
		log("Created Workspace." .. HORSES_FOLDER_NAME)
	end
	return f
end

-- Preferred template locations:
-- 1) ReplicatedStorage/Horses/Default
-- 2) ReplicatedStorage/Default
-- 3) ReplicatedStorage/HorseTemplate
-- 4) Any descendant with IsHorseTemplate=true
-- 5) Any descendant named "Default"
local function findTemplate()
	local horses = RS:FindFirstChild("Horses")
	if horses and horses:IsA("Folder") then
		local d = horses:FindFirstChild("Default")
		if d and d:IsA("Model") then log("Using template:", d:GetFullName()); return d end
	end

	do
		local d = RS:FindFirstChild("Default")
		if d and d:IsA("Model") then log("Using template:", d:GetFullName()); return d end
	end

	do
		local t = RS:FindFirstChild("HorseTemplate")
		if t and t:IsA("Model") then log("Using template:", t:GetFullName()); return t end
	end

	for _, m in ipairs(RS:GetDescendants()) do
		if m:IsA("Model") and m:GetAttribute("IsHorseTemplate") == true then
			log("Using attributed template:", m:GetFullName())
			return m
		end
	end

	for _, m in ipairs(RS:GetDescendants()) do
		if m:IsA("Model") and m.Name == "Default" then
			log("Using fallback 'Default':", m:GetFullName())
			return m
		end
	end

	warn("[HorseService] No horse template found. Put a Model at ReplicatedStorage/Horses/Default.")
	return nil
end

local function ensureSeat(m)
	-- Prefer a seat already named SaddleSeat; else rename first Seat found
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("Seat") and d.Name == "SaddleSeat" then return d end
	end
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("Seat") then d.Name = "SaddleSeat"; return d end
	end
	warn("[HorseService] No Seat found; mounting will fail.")
	return nil
end

local function ensureHumanoid(m)
	local hum = m:FindFirstChildOfClass("Humanoid")
	if not hum then hum = Instance.new("Humanoid", m) end
	hum.AutoRotate = false
	hum.UseJumpPower = true
	return hum
end

local function setPrimaryPartIfPossible(m)
	if m.PrimaryPart and m.PrimaryPart:IsA("BasePart") then return m.PrimaryPart end
	local hrp = m:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then m.PrimaryPart = hrp; return hrp end
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("BasePart") then m.PrimaryPart = d; return d end
	end
	return nil
end

function HorseService.GetActive(p)
	local m = ACTIVE[p]
	if m and m.Parent then return m end
	return nil
end

function HorseService.GetHorseName(p)
	local m = HorseService.GetActive(p)
	return (m and (m:GetAttribute("HorseName") or m.Name)) or "Horse"
end

function HorseService.Despawn(p)
	local m = ACTIVE[p]
	ACTIVE[p] = nil
	if m and m.Parent then m:Destroy() end
end

function HorseService.SummonTo(p, cf, autoMount)
	-- Derive a CFrame if not provided
	if not cf then
		local char = p and p.Character
		local r = char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso"))
		cf = r and r.CFrame or CFrame.new(0, 8, 0)
	end

	local template = findTemplate()
	if not template then return nil end

	-- Replace any existing horse
	if HorseService.GetActive(p) then HorseService.Despawn(p) end

	local h = template:Clone()
	h.Name = template.Name

	-- Attributes for guards/mount code
	h:SetAttribute("IsHorse", true)         -- HorseMountServer uses this
	h:SetAttribute("IsMount", true)         -- generic mount tag
	h:SetAttribute("OwnerUserId", p.UserId) -- for any ownership filters
	h:SetAttribute("BaseSpeed", 32)
	h:SetAttribute("HorseJumpPower", 30)
	h:SetAttribute("HorseJumpImpulse", 60)
	h:SetAttribute("SurfaceYawOffsetDeg", -90) -- your rig prefers Left

	-- Parent into Workspace/Horses (safer than Workspace root)
	local stable = getOrCreateHorsesFolder()
	h.Parent = stable

	-- Position (Model:PivotTo works without PrimaryPart)
	local okPivot, errPivot = pcall(function() h:PivotTo(cf) end)
	if not okPivot then warn("[HorseService] PivotTo error:", errPivot) end

	-- Unanchor all parts (some templates are saved anchored)
	local partCount = 0
	for _, d in ipairs(h:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = false
			partCount += 1
		end
	end

	local seat = ensureSeat(h)
	local hum  = ensureHumanoid(h)
	local pp   = setPrimaryPartIfPossible(h)
	if pp then pcall(function() pp:SetNetworkOwner(nil) end) end

	ACTIVE[p] = h
	log(("Spawned horse for %s â†’ %s"):format(p.Name, h:GetFullName()))

	-- Auto-mount after physics settle
	if autoMount ~= false and seat and seat:IsA("Seat") then
		local char = p.Character
		local riderHum = char and char:FindFirstChildOfClass("Humanoid")
		if riderHum then
			task.defer(function()
				local ok, err = pcall(function() seat:Sit(riderHum) end)
				if not ok then warn("[HorseService] seat:Sit error:", err) end
			end)
		end
	end

	-- If something deletes it right away, complain loudly
	task.delay(0.2, function()
		if not h.Parent then
			warn("[HorseService] Horse destroyed immediately after spawn (firewall?). Whitelist Workspace."..HORSES_FOLDER_NAME..".")
		end
	end)

	-- Keep ACTIVE clean
	h.AncestryChanged:Connect(function(_, parent)
		if parent == nil and ACTIVE[p] == h then ACTIVE[p] = nil end
	end)

	return h
end

Players.PlayerRemoving:Connect(function(p)
	HorseService.Despawn(p)
	ACTIVE[p] = nil
end)

return HorseService


===== FILE: src/server/KeybindHandler.lua =====
-- src/server/KeybindHandler.lua
-- Wires RemoteFunctions for keybinds and discoverable unlocks.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local sss               = script.Parent

local PlayerDataService = require(sss:WaitForChild("PlayerDataService"))

local Remotes           = ReplicatedStorage:WaitForChild("RemoteEvents")
local GetKeybindsRF     = Remotes:WaitForChild("GetKeybinds")
local SetKeybindRF      = Remotes:WaitForChild("SetKeybind")
local GetUnlockedNodesRF= Remotes:WaitForChild("GetUnlockedNodes")

-- ---------------------------------------------------------------------------
-- Build allow-set of unlockable node names (tolerant to different sources)
local UNLOCKABLES_SET = {}

local function addToSet(name)
	if type(name) == "string" and #name > 0 then
		UNLOCKABLES_SET[name] = true
	end
end

-- Preferred: module returns list or map
do
	local ok, allow = pcall(function()
		return require(sss:WaitForChild("StoryUnlockables"))
	end)
	if ok and allow then
		if typeof(allow) == "table" then
			for k, v in pairs(allow) do
				if typeof(k) == "string" and (v == true or typeof(v) == "table") then
					addToSet(k)
				elseif typeof(v) == "string" then
					addToSet(v)
				end
			end
		end
	end
end

-- Fallback: scan folders by child names
local function harvestFolder(folderName)
	local f = ReplicatedStorage:FindFirstChild(folderName)
	if f then
		for _, child in ipairs(f:GetChildren()) do
			addToSet(child.Name)
		end
	end
end

if next(UNLOCKABLES_SET) == nil then
	harvestFolder("StoryUnlockables")
	harvestFolder("Unlockables")
end

-- ---------------------------------------------------------------------------
-- Helpers
local function getData(player)
	return PlayerDataService.GetData(player) or {}
end

local function getBinds(player)
	local data = getData(player)
	data.Keybinds = data.Keybinds or {}
	return data.Keybinds, data
end

-- ---------------------------------------------------------------------------
-- GetKeybinds: returns player's keybind mapping (no defaults forced)
GetKeybindsRF.OnServerInvoke = function(player)
	local binds = getBinds(player)
	-- Return a shallow copy to avoid accidental mutation on client
	local copy = {}
	for k, v in pairs(binds) do copy[k] = v end
	return copy
end

-- SetKeybind: action -> key (e.g., "Block" -> "F")
SetKeybindRF.OnServerInvoke = function(player, action, key)
	if typeof(action) ~= "string" or action == "" then
		return false, "Invalid action"
	end
	if typeof(key) ~= "string" or key == "" then
		return false, "Invalid key"
	end

	local binds, data = getBinds(player)
	binds[action] = key
	-- If your PlayerDataService has an explicit save, call it here (safe pcall):
	if PlayerDataService.Save then
		pcall(PlayerDataService.Save, player, data)
	end

	local copy = {}
	for k, v in pairs(binds) do copy[k] = v end
	return true, copy
end

-- GetUnlockedNodes: intersection of player's Unlocks with allow-set
GetUnlockedNodesRF.OnServerInvoke = function(player)
	local data = getData(player)
	local out = {}
	for _, n in ipairs((data and data.Unlocks) or {}) do
		if UNLOCKABLES_SET[n] then
			table.insert(out, n)
		end
	end
	table.sort(out)
	return out
end

return true


===== FILE: src/server/KeybindService.lua =====
-- KeybindService.lua
-- Persists per-player keybinds (max 5). Keys: 1-0, Z-M.
-- Enforces that only *unlockable* nodes (mirrored in RS/Unlockables) can be bound.

local RS = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))

local ALLOWED_KEYS = {
	One=true, Two=true, Three=true, Four=true, Five=true,
	Six=true, Seven=true, Eight=true, Nine=true, Zero=true,
	Z=true, X=true, C=true, V=true, B=true, N=true, M=true,
}

-- Live cache of unlockable node names (from RS/Unlockables)
local UNLOCKABLES_SET -- [name]=true

local function refreshUnlockables()
	local set = {}
	local folder = RS:FindFirstChild("Unlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				set[sv.Value] = true
			end
		end
	end
	UNLOCKABLES_SET = set
end
refreshUnlockables()
local uFolder = RS:FindFirstChild("Unlockables")
if uFolder then
	uFolder.ChildAdded:Connect(refreshUnlockables)
	uFolder.ChildRemoved:Connect(refreshUnlockables)
end
local function isUnlockable(name) return UNLOCKABLES_SET and UNLOCKABLES_SET[name] or false end

local Busy = setmetatable({}, { __mode = "k" })

local KeybindService = {}

local function ensure(profile)
	local d = profile.Data
	d.Keybinds = d.Keybinds or {} -- map: keyName -> nodeName
end

local function countBinds(map)
	local n = 0
	for _k, v in pairs(map) do if v and v ~= "" then n += 1 end end
	return n
end

function KeybindService.GetAll(player)
	local p = PlayerDataService.GetProfile(player)
	if not p then return {} end
	ensure(p)
	local out = {}
	for k, v in pairs(p.Data.Keybinds) do out[k] = v end
	return out
end

-- set or clear (nodeName == nil/"" to clear)
function KeybindService.Set(player, keyName, nodeName)
	if type(keyName) ~= "string" or keyName == "" or not ALLOWED_KEYS[keyName] then
		return false, "Key not allowed."
	end
	local prof = PlayerDataService.GetProfile(player)
	if not prof then return false, "Profile not ready." end
	ensure(prof)

	-- Clear always allowed
	if not nodeName or nodeName == "" then
		prof.Data.Keybinds[keyName] = nil
		if prof.Save then pcall(function() prof:Save() end) end
		return true, "Unbound."
	end

	-- Only unlockables may be bound (e.g., Revolver), AND you must own it
	if not isUnlockable(nodeName) then
		return false, "Only unlockable moves can be bound."
	end
	if not PlayerDataService.HasUnlock(player, nodeName) then
		return false, "You don't have that unlock yet."
	end

	if Busy[player] then return false, "Busy." end
	Busy[player] = true

	local ok, msg = pcall(function()
		local binds = prof.Data.Keybinds
		local hadBefore = binds[keyName] ~= nil and binds[keyName] ~= ""
		if not hadBefore and countBinds(binds) >= 5 then
			error("You can only have 5 active keybinds.")
		end
		binds[keyName] = nodeName
		if prof.Save then pcall(function() prof:Save() end) end
	end)

	Busy[player] = nil
	if not ok then return false, msg end
	return true, "Saved."
end

return KeybindService


===== FILE: src/server/NPCBinder.server.lua =====
local RS        = game:GetService("ReplicatedStorage")
local RigKit    = require(RS:WaitForChild("RigMadLibs"))   -- from earlier
local Looks     = require(RS:WaitForChild("EnemyLooks"))

local ROOT = workspace:FindFirstChild("NPCs") or workspace

local function applyLook(model: Model)
	if not model:FindFirstChildOfClass("Humanoid") then return end
	if not model:GetAttribute("IsNPC") then return end
	if model:GetAttribute("Skinned") then return end  -- idempotent

	-- Priority: LookKey > storyId > Name
	local key = model:GetAttribute("LookKey") or model:GetAttribute("storyId") or model.Name
	local options = Looks[key]
	if not options or #options == 0 then return end

	local entry = options[1]  -- or pick by index/random if you want
	if entry.userId   then RigKit.applyUserLook(model, entry.userId)
	elseif entry.outfitId then RigKit.applyOutfit(model, entry.outfitId)
	elseif entry.assets   then RigKit.applyAssets(model, entry.assets) end

	model:SetAttribute("Skinned", true)
end

-- Initial pass + handle NPCs added later
for _, m in ipairs(ROOT:GetDescendants()) do
	if m:IsA("Model") then applyLook(m) end
end

ROOT.DescendantAdded:Connect(function(inst)
	if inst:IsA("Model") then applyLook(inst) end
end)


===== FILE: src/server/PlayerDataService.lua =====
-- PlayerDataService.lua (ServerScriptService)
-- Single source of truth for player data (ProfileService-backed)
-- Public API: GetProfile, GetData, WaitForProfile, HasUnlock, AddUnlock, RemoveUnlock, Save

local Players             = game:GetService("Players")
local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage   = game:GetService("ReplicatedStorage")

local ProfileService      = require(ServerScriptService:WaitForChild("ProfileService"))

-- Bump only if you intentionally migrate to a new store
local PROFILE_STORE = "PlayerData_v1"

-- ---------- DEFAULTS (IMMUTABLE) ----------	
local DEFAULTS = {
	SchemaVersion = 1,
	Unlocks = { "Punch", "Heavy", "Dodge", "BlockStart", "BlockEnd" },
	-- Future fields: Cash = 0, etc.
}
table.freeze(DEFAULTS)

-- ---------- ALLOWLIST (cached from RS/Unlockables + defaults) ----------
local ALLOWED -- lazy-populated set
local function refreshAllowed()
	local t = {}
	local folder = ReplicatedStorage:FindFirstChild("Unlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and type(sv.Value) == "string" and sv.Value ~= "" then
				t[sv.Value] = true
			end
		end
	end
	for _, def in ipairs(DEFAULTS.Unlocks) do t[def] = true end
	ALLOWED = t
end
local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end
-- live refresh if the folder changes at runtime
local unlockFolder = ReplicatedStorage:FindFirstChild("Unlockables")
if unlockFolder then
	unlockFolder.ChildAdded:Connect(refreshAllowed)
	unlockFolder.ChildRemoved:Connect(refreshAllowed)
end

-- ---------- INTERNALS ----------
local store    = ProfileService.GetProfileStore(PROFILE_STORE, DEFAULTS)
local Profiles = {} -- [player] = live profile object

local function cloneArray(a)
	local out = {}
	for i, v in ipairs(a) do out[i] = v end
	return out
end

local function sanitizeUnlocks(profile)
	local data = profile.Data
	data.Unlocks = data.Unlocks or {}
	local allowed = getAllowed()
	local cleaned, seen, changed = {}, {}, false
	for _, name in ipairs(data.Unlocks) do
		if allowed[name] and not seen[name] then
			seen[name] = true
			table.insert(cleaned, name)
		else
			changed = true -- drop junk/dupe/disallowed
		end
	end
	-- Ensure not empty (prevent soft-lock)
	if #cleaned == 0 then
		cleaned = cloneArray(DEFAULTS.Unlocks)
		changed = true
	end
	if changed then
		data.Unlocks = cleaned
		pcall(function() profile:Save() end)
	end
end

local function onRelease(player)
	Profiles[player] = nil
	if player and player.Parent then
		player:Kick("Your data session was released elsewhere. Please rejoin.")
	end
end

-- ---------- PUBLIC API ----------
local PlayerDataService = {}

function PlayerDataService.GetProfile(player)
	return Profiles[player]
end

function PlayerDataService.GetData(player)
	local p = Profiles[player]
	if not p then return nil end
	-- Return a shallow clone so callers can't mutate the live table
	return table.clone(p.Data)
end

function PlayerDataService.WaitForProfile(player, timeout)
	local t0, to = os.clock(), (timeout or 10)
	while os.clock() - t0 < to do
		local p = Profiles[player]
		if p then return p end
		task.wait()
	end
	return nil
end

function PlayerDataService.HasUnlock(player, nodeName)
	local p = Profiles[player]
	if not p or type(nodeName) ~= "string" or nodeName == "" then return false end
	for _, n in ipairs(p.Data.Unlocks or {}) do
		if n == nodeName then return true end
	end
	return false
end

-- basic per-player write lock (avoids interleaving unlock/remove bursts)
local Busy = setmetatable({}, { __mode = "k" })
local function withLock(player, fn)
	while Busy[player] do task.wait() end
	Busy[player] = true
	local ok, r = pcall(fn)
	Busy[player] = nil
	if not ok then warn("[PlayerDataService] Error:", r) end
	return ok and r or false
end

function PlayerDataService.AddUnlock(player, nodeName, saveNow)
	if type(nodeName) ~= "string" or nodeName == "" then return false end
	local profile = Profiles[player]; if not profile then return false end
	local allowed = getAllowed()
	if not allowed[nodeName] then
		warn("[PlayerDataService] AddUnlock rejected (not allowed):", nodeName)
		return false
	end
	return withLock(player, function()
		local list = profile.Data.Unlocks or {}
		for _, n in ipairs(list) do if n == nodeName then return false end end
		table.insert(list, nodeName)
		profile.Data.Unlocks = list
		if saveNow and profile.Save then pcall(function() profile:Save() end) end
		return true
	end)
end

function PlayerDataService.RemoveUnlock(player, nodeName, saveNow)
	if type(nodeName) ~= "string" or nodeName == "" then return false end
	local profile = Profiles[player]; if not profile then return false end
	return withLock(player, function()
		local list = profile.Data.Unlocks or {}
		local out, changed = {}, false
		for _, n in ipairs(list) do
			if n ~= nodeName then table.insert(out, n) else changed = true end
		end
		if not changed then return false end
		profile.Data.Unlocks = out
		if saveNow and profile.Save then pcall(function() profile:Save() end) end
		return true
	end)
end

function PlayerDataService.Save(player)
	local profile = Profiles[player]
	if profile and profile.Save then
		local ok, err = pcall(function() profile:Save() end)
		if not ok then warn("[PlayerDataService] Save error:", err) end
		return ok
	end
	return false
end

-- ---------- LIFECYCLE (load/release) ----------
Players.PlayerAdded:Connect(function(player)
	local key = ("Player_%d"):format(player.UserId)
	local profile = store:LoadProfileAsync(key, "ForceLoad")
	if not profile then
		player:Kick("Data failed to load. Please rejoin.")
		return
	end
	-- Player may have left while datastore was busy
	if not player.Parent then
		profile:Release()
		return
	end
	profile:AddUserId(player.UserId)
	profile:Reconcile() -- adds new keys from DEFAULTS; doesn't overwrite arrays
	sanitizeUnlocks(profile)
	profile:ListenToRelease(function()
		onRelease(player)
	end)
	Profiles[player] = profile
end)

Players.PlayerRemoving:Connect(function(player)
	local profile = Profiles[player]
	if profile then
		profile:Release()
		Profiles[player] = nil
	end
end)

game:BindToClose(function()
	local snapshot = {}
	for plr, prof in pairs(Profiles) do snapshot[plr] = prof end
	for _, prof in pairs(snapshot) do prof:Release() end
end)

return PlayerDataService

===== FILE: src/server/ProfileService.lua =====
-- local Madwork = _G.Madwork
--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--	function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])
			
		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()
		
	Members [Profile]:
	
		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)

		Profile.MetaTagsUpdated   [ScriptSignal] (meta_tags_latest) -- Fires after every auto-save, after
			--	Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved;
			--  .MetaTagsUpdated will fire regardless of whether .MetaTagsLatest changed after update;
			--	.MetaTagsUpdated may fire after the Profile is released - changes to Profile.Data are not saved
			--	after release.

		Profile.RobloxMetaData    [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds           [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo           [DataStoreKeyInfo]
		Profile.KeyInfoUpdated    [ScriptSignal] (key_info [DataStoreKeyInfo])
		
		Profile.GlobalUpdates     [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value [any]
			tag_name   [string]
		
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
			-- WARNING: Profiles can be released externally if another session force-loads
			--	this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)

		Profile:ListenToHopReady(listener) --> [ScriptConnection] () -- Passed listener will be executed after the releasing UpdateAsync call finishes;
			--	Wrap universe teleport requests with this method AFTER releasing the profile to improve session lock sharing between universe places;
			--  :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a release happens
			--	next to an auto-update in regular usage scenarios.

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]

		Profile:Identify() --> [string] -- Returns a string containing DataStore name, scope and key; Used for debug;
			-- Example return: "[Store:"GameData";Scope:"Live";Key:"Player_2312310"]"
		
		Profile:SetMetaTag(tag_name, value) -- Equivalent of Profile.MetaData.MetaTags[tag_name] = value
			tag_name   [string]
			value      [any]
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		-- VIEW-MODE ONLY:

		Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

		Profile:OverwriteAsync() -- (Yields) Saves the profile payload to the DataStore and removes the session lock
		
	Methods [GlobalUpdates]:
	
	-- ALWAYS PUBLIC:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data [table]}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data [table]}, ...}
		
	-- ONLY WHEN FROM "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:LockActiveUpdate(update_id)  -- WARNING: will error after profile expires
		GlobalUpdates:ClearLockedUpdate(update_id) -- WARNING: will error after profile expires
		
	-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
			update_data   [table]
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
			update_data   [table]
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	RobloxWriteCooldown = 7, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 8, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
	MetaTagsUpdatedValues = { -- Technical stuff - do not alter
		ProfileCreateTime = true,
		SessionLoadCount = true,
		ActiveSession = true,
		ForceLoadSession = true,
		LastUpdate = true,
	},
	
}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do

	local MadworkScriptSignal = {}

	local FreeRunnerThread = nil
	
	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		FreeRunnerThread = acquired_runner_thread
	end
	
	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end
	
	-- ScriptConnection object:

	local ScriptConnection = {
		--[[
			_listener = listener,
			_script_signal = script_signal,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,
			
			_next = next_script_connection,
			_is_connected = is_connected,
		--]]
	}
	ScriptConnection.__index = ScriptConnection

	function ScriptConnection:Disconnect()

		if self._is_connected == false then
			return
		end

		self._is_connected = false
		self._script_signal._listener_count -= 1

		if self._script_signal._head == self then
			self._script_signal._head = self._next
		else
			local prev = self._script_signal._head
			while prev ~= nil and prev._next ~= self do
				prev = prev._next
			end
			if prev ~= nil then
				prev._next = self._next
			end
		end

		if self._disconnect_listener ~= nil then
			if not FreeRunnerThread then
				FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
			end
			task.spawn(FreeRunnerThread, self._disconnect_listener, self._disconnect_param)
			self._disconnect_listener = nil
		end

	end
	
	-- ScriptSignal object:

	local ScriptSignal = {
		--[[
			_head = nil,
			_listener_count = 0,
		--]]
	}
	ScriptSignal.__index = ScriptSignal

	function ScriptSignal:Connect(listener, disconnect_listener, disconnect_param) --> [ScriptConnection]

		local script_connection = {
			_listener = listener,
			_script_signal = self,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = self._head,
			_is_connected = true,
		}
		setmetatable(script_connection, ScriptConnection)

		self._head = script_connection
		self._listener_count += 1

		return script_connection

	end

	function ScriptSignal:GetListenerCount() --> [number]
		return self._listener_count
	end

	function ScriptSignal:Fire(...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item._listener, ...)
			end
			item = item._next
		end
	end

	function ScriptSignal:FireUntil(continue_callback, ...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				item._listener(...)
				if continue_callback() ~= true then
					return
				end
			end
			item = item._next
		end
	end

	function MadworkScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_head = nil,
			_listener_count = 0,
			Connect = ScriptSignal.Connect,
			GetListenerCount = ScriptSignal.GetListenerCount,
			Fire = ScriptSignal.Fire,
			FireUntil = ScriptSignal.FireUntil,
		}
	end

	-- Madwork framework namespace:
	
	Madwork = {
		NewScriptSignal = MadworkScriptSignal.NewScriptSignal,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}

end

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down

	IssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
	-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value

	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
	-- (You may alert players with this, or set up analytics)

	ServiceIssueCount = 0,

	_active_profile_stores = {}, -- {profile_store, ...}

	_auto_save_list = {}, -- {profile, ...} -- loaded profile table which will be circularly auto-saved

	_issue_queue = {}, -- [table] {issue_time, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start

	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},

	_use_mock_data_store = false,

}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		RobloxMetaData = {},
		UserIds = {},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local IsLiveCheckActive = false

local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

local CustomWriteQueue = {
	--[[
		[store] = {
			[key] = {
				LastWrite = os.clock(),
				Queue = {callback, ...},
				CleanupJob = nil,
			},
			...
		},
		...
	--]]
}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

----- Private functions -----

local function IdentifyProfile(store_name, store_scope, key)
	return string.format(
		"[Store:\"%s\";%sKey:\"%s\"]",
		store_name,
		store_scope ~= nil and string.format("Scope:\"%s\";", store_scope) or "",
		key
	)
end

local function CustomWriteQueueCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		CustomWriteQueue[store][key] = nil
		if next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueMarkForCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		if CustomWriteQueue[store][key] ~= nil then

			local queue_data = CustomWriteQueue[store][key]
			local queue = queue_data.Queue

			if queue_data.CleanupJob == nil then

				queue_data.CleanupJob = RunService.Heartbeat:Connect(function()
					if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
						queue_data.CleanupJob:Disconnect()
						CustomWriteQueueCleanup(store, key)
					end
				end)

			end

		elseif next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueAsync(callback, store, key) --> ... -- Passed return from callback

	if CustomWriteQueue[store] == nil then
		CustomWriteQueue[store] = {}
	end
	if CustomWriteQueue[store][key] == nil then
		CustomWriteQueue[store][key] = {LastWrite = 0, Queue = {}, CleanupJob = nil}
	end

	local queue_data = CustomWriteQueue[store][key]
	local queue = queue_data.Queue

	-- Cleanup job:

	if queue_data.CleanupJob ~= nil then
		queue_data.CleanupJob:Disconnect()
		queue_data.CleanupJob = nil
	end

	-- Queue logic:

	if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
		queue_data.LastWrite = os.clock()
		return callback()
	else
		table.insert(queue, callback)
		while true do
			if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and queue[1] == callback then
				table.remove(queue, 1)
				queue_data.LastWrite = os.clock()
				return callback()
			end
			task.wait()
		end
	end

end

local function IsCustomWriteQueueEmptyFor(store, key) --> is_empty [bool]
	local lookup = CustomWriteQueue[store]
	if lookup ~= nil then
		lookup = lookup[key]
		return lookup == nil or #lookup.Queue == 0
	end
	return true
end

local function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required
	while IsLiveCheckActive == true do
		task.wait()
	end
end

local function WaitForPendingProfileStore(profile_store)
	while profile_store._is_pending == true do
		task.wait()
	end
end

local function RegisterIssue(error_message, store_name, store_scope, profile_key) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error " .. IdentifyProfile(store_name, store_scope, profile_key) .. " - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterCorruption(store_name, store_scope, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Resolved profile corruption " .. IdentifyProfile(store_name, store_scope, profile_key))
	ProfileService.CorruptionSignal:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = transform
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock, is_get_call, version) --> loaded_data, key_info
	local loaded_data, key_info
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}

			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end

			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table"
					and type(latest_data.MetaData) == "table"
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil
					and latest_data.MetaData == nil
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates or global_updates_data
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end

			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end

			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end
		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
			loaded_data, key_info = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		elseif UseMockDataStore == true then -- Used when API access is disabled
			loaded_data, key_info = MockUpdateAsync(MockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		else
			loaded_data, key_info = CustomWriteQueueAsync(
				function() -- Callback
					if is_get_call == true then
						local get_data, get_key_info
						if version ~= nil then
							local success, error_message = pcall(function()
								get_data, get_key_info = profile_store._global_data_store:GetVersionAsync(profile_key, version)
							end)
							if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
								warn("[ProfileService]: Passed version argument is not valid; Traceback:\n" .. debug.traceback())
							end
						else
							get_data, get_key_info = profile_store._global_data_store:GetAsync(profile_key)
						end
						get_data = transform_function(get_data)
						return get_data, get_key_info
					else
						return profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
					end
				end,
				profile_store._profile_store_lookup, -- Store
				profile_key -- Key
			)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true and is_get_call ~= true then
			RegisterCorruption(
				profile_store._profile_store_name,
				profile_store._profile_store_scope,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		RegisterIssue(
			(error_message ~= nil) and error_message or "Undefined error",
			profile_store._profile_store_name,
			profile_store._profile_store_scope,
			profile_key
		)
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	profile._release_listeners:Fire(place_id, game_job_id)
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					global_updates_object._new_active_update_listeners:Fire(new_global_update[1], new_global_update[4])
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:

					global_updates_object._new_locked_update_listeners:FireUntil(
						function()
							-- Check if listener marked the update to be cleared:
							-- Normally there should be only one listener per profile for new locked global updates, but
							-- in case several listeners are connected we will not trigger more listeners after one listener
							-- marks the locked global update to be cleared.
							return table.find(pending_update_clear, new_global_update[1]) == nil
						end,
						new_global_update[1], new_global_update[4]
					)

				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session, is_overwriting)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(
			profile._profile_store._profile_store_name,
			profile._profile_store._profile_store_scope,
			profile._profile_key
		)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! Profile: " .. profile:Identify())
	end
	if release_from_session == true and is_overwriting ~= true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local last_session_load_count = profile.MetaData.SessionLoadCount
	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again
	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	while repeat_save_flag == true do
		if release_from_session ~= true then
			repeat_save_flag = false
		end
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			profile._profile_store,
			profile._profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local session_owns_profile = false
					local force_load_pending = false

					if is_overwriting ~= true then
						-- 1) Check if this session still owns the profile: --
						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
						end
						if type(force_load_session) == "table" then
							force_load_pending = not IsThisSession(force_load_session)
						end
					else
						session_owns_profile = true
					end

					if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile

						if is_overwriting ~= true then
							-- 2) Manage global updates: --
							local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							local latest_global_updates_list = latest_global_updates_data[2]

							local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
							local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
							local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
							-- Active update locking:
							for i = 1, #latest_global_updates_list do
								for _, lock_id in ipairs(pending_update_lock) do
									if latest_global_updates_list[i][1] == lock_id then
										latest_global_updates_list[i][3] = true
										break
									end
								end
							end
							-- Locked update clearing:
							for _, clear_id in ipairs(pending_update_clear) do
								for i = 1, #latest_global_updates_list do
									if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
										table.remove(latest_global_updates_list, i)
										break
									end
								end
							end
						end

						-- 3) Save profile data: --
						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then
							latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
							latest_data.MetaData.LastUpdate = os.time()
							if release_from_session == true or force_load_pending == true then
								latest_data.MetaData.ActiveSession = nil
							end
						else
							latest_data.MetaData = profile.MetaData
							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil
							latest_data.GlobalUpdates = profile.GlobalUpdates._updates_latest
						end

					end
				end,
			},
			profile._is_user_mock
		)
		if loaded_data ~= nil and key_info ~= nil then
			if is_overwriting == true then
				break
			end
			repeat_save_flag = false
			-- 4) Set latest data in profile: --
			-- Updating DataStoreKeyInfo:
			profile.KeyInfo = key_info
			-- Setting global updates:
			local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
			local old_global_updates_data = global_updates_object._updates_latest
			local new_global_updates_data = loaded_data.GlobalUpdates
			global_updates_object._updates_latest = new_global_updates_data
			-- Setting MetaData:
			local session_meta_data = profile.MetaData
			local latest_meta_data = loaded_data.MetaData
			for key in pairs(SETTINGS.MetaTagsUpdatedValues) do
				session_meta_data[key] = latest_meta_data[key]
			end
			session_meta_data.MetaTagsLatest = latest_meta_data.MetaTags
			-- 5) Check if session still owns the profile: --
			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false
			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
			end
			local is_active = profile:IsActive()
			if session_owns_profile == true then
				-- 6) Check for new global updates: --
				if is_active == true then -- Profile could've been released before the saving thread finished
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				end
			else
				-- Session no longer owns the profile:
				-- 7) Release profile if it hasn't been released yet: --
				if is_active == true then
					ReleaseProfileInternally(profile)
				end
				-- Cleanup reference in custom write queue:
				CustomWriteQueueMarkForCleanup(profile._profile_store._profile_store_lookup, profile._profile_key)
				-- Hop ready listeners:
				if profile._hop_ready == false then
					profile._hop_ready = true
					profile._hop_ready_listeners:Fire()
				end
			end
			-- Signaling MetaTagsUpdated listeners after a possible external profile release was handled:
			profile.MetaTagsUpdated:Fire(profile.MetaData.MetaTagsLatest)
			-- Signaling KeyInfoUpdated listeners:
			profile.KeyInfoUpdated:Fire(key_info)
		elseif repeat_save_flag == true then
			task.wait() -- Prevent infinite loop in case DataStore API does not yield
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		_new_locked_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_active_update_listeners:Connect(listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_locked_update_listeners:Connect(listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready = false,
		
		_view_mode = true / nil, -- [bool] or nil
		
		_load_timestamp = os.clock(),
		
		_is_user_mock = false, -- ProfileStore.Mock
		_mock_key_info = {},
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self._profile_store._profile_template)
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {Disconnect = function() end}
	else
		return self._release_listeners:Connect(listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode - Should you be calling :OverwriteAsync() instead?")
	end
	if self:IsActive() == false then
		warn("[ProfileService]: Attempted saving an inactive profile "
			.. self:Identify() .. "; Traceback:\n" .. debug.traceback())
		return
	end
	-- Reject save request if a save is already pending in the queue - this will prevent the user from
	--	unecessary API request spam which we could not meaningfully execute anyways!
	if IsCustomWriteQueueEmptyFor(self._profile_store._profile_store_lookup, self._profile_key) == true then
		-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
		RemoveProfileFromAutoSave(self)
		AddProfileToAutoSave(self)
		-- Call save function in a new thread:
		task.spawn(SaveProfileAsync, self)
	end
end

function Profile:Release()
	if self._view_mode == true then
		return
	end
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true) -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:ListenToHopReady(listener) --> [ScriptConnection] ()
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToHopReady()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self._hop_ready == true then
		task.spawn(listener)
		return {Disconnect = function() end}
	else
		return self._hop_ready_listeners:Connect(listener)
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :AddUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	if user_id < 0 and self._is_user_mock ~= true and UseMockDataStore ~= true then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end
	
end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :RemoveUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end
	
	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:Identify() --> [string]
	return IdentifyProfile(
		self._profile_store._profile_store_name,
		self._profile_store._profile_store_scope,
		self._profile_key
	)
end

function Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

	if self._view_mode ~= true then
		error("[ProfileService]: :ClearGlobalUpdates() can only be used in view mode")
	end

	local global_updates_object = {
		_updates_latest = {0, {}},
		_profile = self,
	}
	setmetatable(global_updates_object, GlobalUpdates)

	self.GlobalUpdates = global_updates_object

end

function Profile:OverwriteAsync() -- Saves the profile to the DataStore and removes the session lock

	if self._view_mode ~= true then
		error("[ProfileService]: :OverwriteAsync() can only be used in view mode")
	end

	SaveProfileAsync(self, nil, true)

end

-- ProfileVersionQuery object:

local ProfileVersionQuery = {
	--[[
		_profile_store = profile_store,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = pages, -- [DataStoreVersionPages]
		_query_index = index, -- [number]
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	--]]
}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery:_MoveQueue()
	while #self._query_queue > 0 do
		local queue_entry = table.remove(self._query_queue, 1)
		task.spawn(queue_entry)
		if self._is_query_yielded == true then
			break
		end
	end
end

function ProfileVersionQuery:NextAsync(_is_stacking) --> [Profile] or nil

	if self._profile_store == nil then
		return nil
	end

	local profile
	local is_finished = false

	local function query_job()

		if self._query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self._query_pages == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)
			
			local list_success, error_message = pcall(function()
				self._query_pages = self._profile_store._global_data_store:ListVersionsAsync(
					self._profile_key,
					self._sort_direction,
					self._min_date,
					self._max_date
				)
				self._query_index = 0
			end)

			if list_success == false or self._query_pages == nil then
				warn("[ProfileService]: Version query fail - " .. tostring(error_message))
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		local current_page = self._query_pages:GetCurrentPage()
		local next_item = current_page[self._query_index + 1]

		-- No more entries:
		
		if self._query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local success = pcall(function()
				self._query_pages:AdvanceToNextPageAsync()
				self._query_index = 0
			end)

			if success == false or #self._query_pages:GetCurrentPage() == 0 then
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		-- Next page item:

		self._query_index += 1
		profile = self._profile_store:ViewProfileAsync(self._profile_key, next_item.Version)
		is_finished = true

	end

	if self._is_query_yielded == false then
		query_job()
	else
		if _is_stacking == true then
			table.insert(self._query_queue, 1, query_job)
		else
			table.insert(self._query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},
	
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_store_scope = nil, -- [string] or [nil] -- DataStore scope
		_profile_store_lookup = "", -- [string] -- _profile_store_name .. "\0" .. (_profile_store_scope or "")
		
		_profile_template = {}, -- [table]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
		
		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)

	not_released_handler = not_released_handler or "ForceLoad"

	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	local is_user_mock = _use_mock == UseMockTag

	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_lookup == self._profile_store_lookup then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile " .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) .. " is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data, key_info
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = table.pack(StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then
										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
											return
										end
									end
									if steal_session == true or aggressive_steal == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true or aggressive_steal == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			))
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},

						_new_active_update_listeners = Madwork.NewScriptSignal(),
						_new_locked_update_listeners = Madwork.NewScriptSignal(),

						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						MetaTagsUpdated = Madwork.NewScriptSignal(),

						RobloxMetaData = loaded_data.RobloxMetaData or {},
						UserIds = loaded_data.UserIds or {},
						KeyInfo = key_info,
						KeyInfoUpdated = Madwork.NewScriptSignal(),

						GlobalUpdates = global_updates_object,

						_profile_store = self,
						_profile_key = profile_key,

						_release_listeners = Madwork.NewScriptSignal(),
						_hop_ready_listeners = Madwork.NewScriptSignal(),
						_hop_ready = false,

						_load_timestamp = os.clock(),

						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							task.wait() -- Overload prevention
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						task.wait() -- Overload prevention
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							task.wait() -- Overload prevention
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							task.wait() -- Overload prevention
						elseif handler_result == "Steal" then
							aggressive_steal = true
							task.wait() -- Overload prevention
						else
							error(
								"[ProfileService]: Invalid return from not_released_handler (\"" .. tostring(handler_result) .. "\")(" .. type(handler_result) .. ");" ..
									"\n" .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) ..
									" Traceback:\n" .. debug.traceback()
							)
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely the ProfileService.ServiceLocked flag was raised
			end
		else
			task.wait() -- Overload prevention
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end

function ProfileStore:ViewProfileAsync(profile_key, version, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	if version ~= nil and (_use_mock == UseMockTag or UseMockDataStore == true) then
		return nil -- No version support in mock mode
	end

	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)
					latest_data.Data = DeepCopyTable(self._profile_template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {},
					}
				end,
				EditProfile = nil,
			},
			_use_mock == UseMockTag,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handle load_data:
		if loaded_data ~= nil then
			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates, -- {0, {}}
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				MetaTagsUpdated = Madwork.NewScriptSignal(),

				RobloxMetaData = loaded_data.RobloxMetaData or {},
				UserIds = loaded_data.UserIds or {},
				KeyInfo = key_info,
				KeyInfoUpdated = Madwork.NewScriptSignal(),

				GlobalUpdates = global_updates_object,

				_profile_store = self,
				_profile_key = profile_key,

				_view_mode = true,

				_load_timestamp = os.clock(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, _use_mock) --> [ProfileVersionQuery]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return setmetatable({}, ProfileVersionQuery) -- Silently fail :Next() requests
	end

	WaitForPendingProfileStore(self)

	if _use_mock == UseMockTag or UseMockDataStore == true then
		error("[ProfileService]: :ProfileVersionQuery() is not supported in mock mode")
	end

	-- Type check:
	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error("[ProfileService]: Invalid sort_direction (" .. tostring(sort_direction) .. ")")
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error("[ProfileService]: Invalid min_date (" .. tostring(min_date) .. ")")
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error("[ProfileService]: Invalid max_date (" .. tostring(max_date) .. ")")
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	local profile_version_query = {
		_profile_store = self,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = nil,
		_query_index = 0,
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	}
	setmetatable(profile_version_query, ProfileVersionQuery)

	return profile_version_query

end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return false
	end

	WaitForPendingProfileStore(self)

	local wipe_status = false

	if _use_mock == UseMockTag then -- Used when the profile is accessed through ProfileStore.Mock
		local mock_data_store = UserMockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	elseif UseMockDataStore == true then -- Used when API access is disabled
		local mock_data_store = MockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	else
		wipe_status = pcall(function()
			self._global_data_store:RemoveAsync(profile_key)
		end)
	end

	CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)

	return wipe_status
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]

	local profile_store_name
	local profile_store_scope = nil

	-- Parsing profile_store_index:
	if type(profile_store_index) == "string" then
		-- profile_store_index as string:
		profile_store_name = profile_store_index
	elseif type(profile_store_index) == "table" then
		-- profile_store_index as table:
		profile_store_name = profile_store_index.Name
		profile_store_scope = profile_store_index.Scope
	else
		error("[ProfileService]: Invalid or missing profile_store_index")
	end

	-- Type checking:
	if profile_store_name == nil or type(profile_store_name) ~= "string" then
		error("[ProfileService]: Missing or invalid \"Name\" parameter")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: ProfileStore name cannot be an empty string")
	end

	if profile_store_scope ~= nil and (type(profile_store_scope) ~= "string" or string.len(profile_store_scope) == 0) then
		error("[ProfileService]: Invalid \"Scope\" parameter")
	end

	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end

	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key, version)
				return profile_store:ViewProfileAsync(profile_key, version, UseMockTag)
			end,
			FindProfileVersionAsync = function(_, profile_key, sort_direction, min_date, max_date)
				return profile_store:FindProfileVersionAsync(profile_key, sort_direction, min_date, max_date, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},

		_profile_store_name = profile_store_name,
		_profile_store_scope = profile_store_scope,
		_profile_store_lookup = profile_store_name .. "\0" .. (profile_store_scope or ""),

		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
		_is_pending = false,
	}
	setmetatable(profile_store, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if IsLiveCheckActive == true then
		profile_store._is_pending = true
		task.spawn(function()
			WaitForLiveAccessCheck()
			if UseMockDataStore == false then
				profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
			end
			profile_store._is_pending = false
		end)
	else
		if UseMockDataStore == false then
			profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope, options)
		end
	end

	return profile_store
end

function ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)

	WaitForLiveAccessCheck()

	return UseMockDataStore == false

end

----- Initialize -----

if IsStudio == true then
	IsLiveCheckActive = true
	task.spawn(function()
		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)
		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil
		if no_internet_access == true then
			warn("[ProfileService]: No internet access - check your network connection")
		end
		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			UseMockDataStore = true
			ProfileService._use_mock_data_store = true
			print("[ProfileService]: Roblox API services unavailable - data will not be saved")
		else
			print("[ProfileService]: Roblox API services available - data will be saved")
		end
		IsLiveCheckActive = false
	end)
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile._load_timestamp < SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = os.clock()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
task.spawn(function()
	WaitForLiveAccessCheck()
	Madwork.ConnectToOnClose(
		function()
			ProfileService.ServiceLocked = true
			-- 1) Release all active profiles: --
			-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
			local on_close_save_job_count = 0
			local active_profiles = {}
			for index, profile in ipairs(AutoSaveList) do
				active_profiles[index] = profile
			end
			-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
			for _, profile in ipairs(active_profiles) do
				if profile:IsActive() == true then
					on_close_save_job_count = on_close_save_job_count + 1
					task.spawn(function() -- Save profile on new thread
						SaveProfileAsync(profile, true)
						on_close_save_job_count = on_close_save_job_count - 1
					end)
				end
			end
			-- 2) Yield until all active profile jobs are finished: --
			while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
				task.wait()
			end
			return -- We're done!
		end,
		UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
	)
end)

return ProfileService

===== FILE: src/server/ResetCleaner.server.lua =====
-- ResetCleaner (ServerScriptService)

local Players            = game:GetService("Players")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

local CombatState        = require(ReplicatedStorage:WaitForChild("CombatState"))
local CooldownService    = require(ReplicatedStorage:WaitForChild("CooldownService"))
local SpeedController    = require(ReplicatedStorage:WaitForChild("SpeedController"))
local DamageService      = require(ReplicatedStorage:WaitForChild("DamageService"))
local GuardService       = require(ReplicatedStorage:WaitForChild("GuardService"))
local DodgeChargeService = require(ReplicatedStorage:WaitForChild("DodgeChargeService"))
local AttackStateService = require(ReplicatedStorage:WaitForChild("AttackStateService"))
local IFrameStore        = require(ReplicatedStorage:WaitForChild("IFrameStore"))

Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function()
		-- give Roblox a heartbeat to create Humanoid etc.
		task.wait(0.1)

		-- core combat state
		CombatState.Cleanup(player)
		CooldownService.Clear(player)
		SpeedController.Reset(player)

		-- defense / block systems
		DamageService.EndBlock(player)
		GuardService.EndBlock(player)      -- clears guard flags & regen loop

		-- attack / stamina trackers
		AttackStateService.Clear(player)
		DodgeChargeService.Reset(player)

		-- purge residual i-frames
		IFrameStore.Grant(player, 0)
	end)
end)
local Players     = game:GetService("Players")
local RS          = game:GetService("ReplicatedStorage")
local CombatState = require(RS:WaitForChild("CombatState"))

local function clearLocksFor(p: Player, why: string)
	pcall(function() CombatState.ForceUnlock(p, why) end)
	local hum = p.Character and p.Character:FindFirstChildOfClass("Humanoid")
	if hum then hum:SetAttribute("Mounted", false) end
end

Players.PlayerAdded:Connect(function(p)
	p.CharacterAdded:Connect(function(char)
		-- defer to ensure Humanoid exists
		task.defer(function()
			clearLocksFor(p, "spawn")
		end)
		local hum = char:WaitForChild("Humanoid", 5)
		if hum then
			hum.Died:Connect(function()
				clearLocksFor(p, "death")
			end)
		end
	end)
end)


===== FILE: src/server/RounderDiagnostics.server.lua =====
-- ServerScriptService/RounderDiagnostics.server.lua
-- Watches a Rounder NPC even if it spawns later. No GetAttribute calls.

local RS          = game:GetService("ReplicatedStorage")
local RunService  = game:GetService("RunService")

local StunService     = require(RS:WaitForChild("StunService"))
local SpeedController = require(RS:WaitForChild("SpeedController"))

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers
local THIS_SOURCE
do local ok,s=pcall(function() return debug.info(1,"s") end); THIS_SOURCE = ok and s or "" end

local function who()
	for i=3,12 do
		local ok, src = pcall(function() return debug.info(i, "s") end)
		if ok and src and not tostring(src):find("RounderDiagnostics") then
			local ok2, what = pcall(function() return (debug.info(i, "n") or "") end)
			return string.format("%s:%s", tostring(src), tostring(what))
		end
	end
	return "?"
end


local function isHumanoidModel(x)
	return typeof(x) == "Instance" and x:IsA("Model") and x:FindFirstChildOfClass("Humanoid") ~= nil
end

local function looksLikeRounder(m)
	if not isHumanoidModel(m) then return false end
	-- Name checks only (no GetAttribute):
	local n = m.Name:lower()
	if n:find("rounder") then return true end
	-- common child stringValue fallback: enemyId/Id/etc.
	for _, c in ipairs(m:GetChildren()) do
		if c:IsA("StringValue") then
			local v = (c.Value or ""):lower()
			if v:find("rounder") then return true end
		end
	end
	return false
end

local CURRENT    = nil   -- the model we're watching
local HUM        = nil
local baseSpeed  = nil
local conns      = {}
local snapThread = nil
local lastSoftAt, lastHardAt, lastClearAt = 0,0,0

local function disconnectAll()
	for _, cn in ipairs(conns) do pcall(function() cn:Disconnect() end) end
	conns = {}
	if snapThread then
		task.cancel(snapThread)
		snapThread = nil
	end
end

local function attach(model)
	if CURRENT == model then return end
	disconnectAll()

	CURRENT = model
	HUM     = model and model:FindFirstChildOfClass("Humanoid") or nil
	if not (CURRENT and HUM) then
		warn("[RounderDiag] attach failed (no humanoid)")
		CURRENT, HUM = nil, nil
		return
	end

	baseSpeed = HUM.WalkSpeed
	print(("[RounderDiag] Attached to %s  base WS=%.2f")
		:format(CURRENT:GetFullName(), baseSpeed))

	-- Live property logs
	table.insert(conns, HUM:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		print(("[RounderDiag] WalkSpeed â†’ %.2f"):format(HUM.WalkSpeed))
	end))

	table.insert(conns, CURRENT:GetPropertyChangedSignal("Parent"):Connect(function()
		if CURRENT.Parent == nil then
			print("[RounderDiag] Rounder removed; detaching.")
			disconnectAll()
			CURRENT, HUM, baseSpeed = nil, nil, nil
		end
	end))

	-- 1 Hz snapshots + perma-slow heuristic
	snapThread = task.spawn(function()
		while CURRENT and CURRENT.Parent do
			local ws = HUM.WalkSpeed
			local ps = HUM.PlatformStand
			local jr = HUM.JumpPower
			local ar = HUM.AutoRotate
			local hard = false
			pcall(function() hard = StunService.IsStunned(CURRENT) == true end)

		

			local t = os.clock()
			task.wait(1)
		end
	end)
end

-- Pick an existing Rounder if one is already in the world
local function attachExisting()
	-- Prefer workspace.Enemies children named/looking like Rounder
	local enemies = workspace:FindFirstChild("Enemies")
	if enemies then
		for _, m in ipairs(enemies:GetChildren()) do
			if looksLikeRounder(m) then attach(m); return true end
		end
	end
	-- Fallback: search whole workspace for any model that looks like Rounder
	for _, inst in ipairs(workspace:GetDescendants()) do
		if looksLikeRounder(inst) then attach(inst); return true end
	end
	return false
end

-- Watch for future spawns (handles your asynchronous EnemySpawner)
local function onCandidate(inst)
	if CURRENT or not isHumanoidModel(inst) then return end
	-- must be under workspace.Enemies OR look like Rounder by name/id
	if inst:IsDescendantOf(workspace:FindFirstChild("Enemies") or workspace) and looksLikeRounder(inst) then
		attach(inst)
	end
end

workspace.DescendantAdded:Connect(onCandidate)

-- Try to hook immediately if Rounder already spawned
if not attachExisting() then
	print("[RounderDiag] Rounder not present yet; waiting for spawnâ€¦")
end

-- â”€â”€ non-destructive wrappers with dynamic target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local oldStunApply = StunService.Apply
local oldStunClear = StunService.Clear

StunService.Apply = function(entity, duration, opts)
	local match = false
	if CURRENT then
		match = (entity == CURRENT)
		if not match and typeof(entity) == "Instance" and entity:IsA("Player") then
			match = (entity.Character == CURRENT)
		end
	end

	if match then
		local hard  = not (type(opts) == "table" and opts.hard == false)
		local scale = (type(opts) == "table" and tonumber(opts.moveScale)) or 0.20
		print(("[RounderDiag] Stun.Apply hard=%s dur=%.2fs scale=%.2f caller=%s")
			:format(tostring(hard), duration, scale, who()))
		if hard then lastHardAt = os.clock() else lastSoftAt = os.clock() end
	end
	return oldStunApply(entity, duration, opts)
end

StunService.Clear = function(entity)
	local match = (CURRENT and (entity == CURRENT))
	if not match and CURRENT and typeof(entity) == "Instance" and entity:IsA("Player") then
		match = (entity.Character == CURRENT)
	end
	if match then
		print("[RounderDiag] Stun.Clear caller=" .. who())
		lastClearAt = os.clock()
	end
	return oldStunClear(entity)
end

local oldSCApply = SpeedController.Apply
local oldSCReset = SpeedController.Reset

SpeedController.Apply = function(playerOrModel, newSpeed, duration)
	local mdl = playerOrModel
	if typeof(playerOrModel) == "Instance" and playerOrModel:IsA("Player") then
		mdl = playerOrModel.Character
	end
	if CURRENT and mdl == CURRENT then
		print(("[RounderDiag] Speed.Apply â†’ %.2f for %.2fs caller=%s")
			:format(newSpeed, duration, who()))
	end
	return oldSCApply(playerOrModel, newSpeed, duration)
end

SpeedController.Reset = function(playerOrModel)
	local mdl = playerOrModel
	if typeof(playerOrModel) == "Instance" and playerOrModel:IsA("Player") then
		mdl = playerOrModel.Character
	end
	if CURRENT and mdl == CURRENT then
		print("[RounderDiag] Speed.Reset caller=" .. who())
	end
	return oldSCReset(playerOrModel)
end


===== FILE: src/server/Script.server.lua =====
local CollectionService = game:GetService("CollectionService")
local RS = game:GetService("ReplicatedStorage")
local Remotes = RS:WaitForChild("RemoteEvents")
local BeginDlg = Remotes:WaitForChild("BeginDialogue")

local function wire(model)
	local prompt = model:FindFirstChildOfClass("ProximityPrompt")
	print("[NPC] wire?", model:GetFullName(), "prompt=", prompt)
	if not prompt then
		warn("[NPC] No ProximityPrompt on", model:GetFullName())
		return
	end
	local storyId = model:GetAttribute("storyId")
	local startNode = model:GetAttribute("startNode")
	print("[NPC] attrs storyId=", storyId, "startNode=", startNode)

	if type(storyId) ~= "string" or storyId == "" then
		warn("[NPC] Missing storyId on", model:GetFullName()); return
	end

	prompt.Enabled = true
	prompt.RequiresLineOfSight = false
	prompt.MaxActivationDistance = 16
	prompt.HoldDuration = 0

	prompt.Triggered:Connect(function(player)
		print("[NPC] Triggered by", player.Name, "â†’ FireClient BeginDialogue")
		BeginDlg:FireClient(player, storyId, startNode)
	end)
end

for _, m in ipairs(CollectionService:GetTagged("DialogueNPC")) do wire(m) end
CollectionService:GetInstanceAddedSignal("DialogueNPC"):Connect(wire)
print("[NPC] Trigger script ready; tagged count:", #CollectionService:GetTagged("DialogueNPC"))
print()

===== FILE: src/server/SpawnManager.server.lua =====
local ServerStorage = game:GetService("ServerStorage")
local RS            = game:GetService("ReplicatedStorage")
local Debris        = game:GetService("Debris")

-- Optional: skinning helper from earlier. If you didn't make it yet, comment these 2 lines.
local RigMadLibs    = RS:FindFirstChild("RigMadLibs") and require(RS.RigMadLibs)
local Looks         = RS:FindFirstChild("EnemyLooks") and require(RS.EnemyLooks)

local NPC_PREFABS     = ServerStorage:WaitForChild("NPCs")
local ENEMY_PREFABS   = ServerStorage:WaitForChild("Enemies")

local NPC_ANCHORS     = workspace:FindFirstChild("NPCAnchors")
local ENEMY_LEASHES   = workspace:FindFirstChild("EnemyLeashes")

local function topCenterCF(p: BasePart)
	return p.CFrame * CFrame.new(0, p.Size.Y/2 + 0.1, 0)
end

local function pickLook(prefabName: string)
	if not Looks then return nil end
	local list = Looks[prefabName]
	if not (list and #list > 0) then return nil end
	return list[math.random(1, #list)]
end

local function pivotAndFace(rig: Model, cf: CFrame)
	-- Use PivotTo so HRP + full model follows
	if rig and rig.PrimaryPart then
		rig:PivotTo(cf)
	else
		-- fallback: try to set PrimaryPart
		local hrp = rig:FindFirstChild("HumanoidRootPart")
		if hrp then rig.PrimaryPart = hrp end
		rig:PivotTo(cf)
	end
end

local function spawnFromFolder(folder: Instance, prefabName: string)
	return folder:FindFirstChild(prefabName) and folder[prefabName]:Clone() or nil
end

-- === NPCs (stationary) ===
local function spawnNPCAt(anchor: BasePart)
	local prefabName = anchor:GetAttribute("Prefab")
	if not prefabName then warn("NPC anchor missing Prefab:", anchor:GetFullName()) return end

	local rig = spawnFromFolder(NPC_PREFABS, prefabName)
	if not rig then warn("NPC prefab not found:", prefabName) return end

	rig.Name = prefabName
	rig.Parent = workspace
	pivotAndFace(rig, topCenterCF(anchor))

	-- Optional skin
	pcall(function()
		if RigMadLibs then RigMadLibs.applyUserLook(rig, 1) end -- demo; replace with your choice or use EnemyLooks
	end)

	-- Keep where we spawned it
	rig:SetAttribute("IsNPC", true)
	rig:SetAttribute("AnchorName", anchor.Name)

	-- Respawn behavior (usually false for NPCs)
	if anchor:GetAttribute("Respawn") then
		local hum = rig:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Died:Connect(function()
				local t = anchor:GetAttribute("RespawnTime") or 8
				task.delay(t, function()
					if anchor.Parent then spawnNPCAt(anchor) end
				end)
			end)
		end
	end

	return rig
end

-- === Enemies (leashed) ===
local function spawnEnemyAt(leash: BasePart)
	local prefabName = leash:GetAttribute("Prefab")
	if not prefabName then warn("Leash missing Prefab:", leash:GetFullName()) return end

	local rig = spawnFromFolder(ENEMY_PREFABS, prefabName)
	if not rig then warn("Enemy prefab not found:", prefabName) return end

	rig.Name = prefabName
	rig.Parent = workspace:FindFirstChild("Enemies") or workspace
	pivotAndFace(rig, topCenterCF(leash))

	-- Stamp leash attributes for the AI to use later
	rig:SetAttribute("LeashCenterX", leash.Position.X)
	rig:SetAttribute("LeashCenterY", leash.Position.Y)
	rig:SetAttribute("LeashCenterZ", leash.Position.Z)
	rig:SetAttribute("LeashRadius", leash:GetAttribute("LeashRadius") or 30)
	rig:SetAttribute("ArenaId", leash:GetAttribute("ArenaId") or "")

	-- Optional look randomizer
	pcall(function()
		if RigMadLibs then
			local look = pickLook(prefabName)
			if look then RigMadLibs.spawn(prefabName, rig.Parent, rig.PrimaryPart and rig.PrimaryPart.CFrame or rig:GetPivot(), look) end
			-- If you use the line above, delete `rig` first or modify RigMadLibs to apply look to an existing rig.
		end
	end)

	-- Respawn on death (typical for enemies)
	local shouldRespawn = leash:GetAttribute("Respawn")
	if shouldRespawn == nil then shouldRespawn = true end
	if shouldRespawn then
		local hum = rig:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Died:Connect(function()
				local t = leash:GetAttribute("RespawnTime") or 10
				task.delay(t, function()
					if leash.Parent then spawnEnemyAt(leash) end
				end)
			end)
		end
	end

	return rig
end

-- === Boot ===
if NPC_ANCHORS then
	for _, a in ipairs(NPC_ANCHORS:GetChildren()) do
		if a:IsA("BasePart") then
			local count = math.max(1, tonumber(a:GetAttribute("Count") or 1))
			for i = 1, count do spawnNPCAt(a) end
		end
	end
end

if ENEMY_LEASHES then
	for _, l in ipairs(ENEMY_LEASHES:GetChildren()) do
		if l:IsA("BasePart") then
			local count = math.max(1, tonumber(l:GetAttribute("Count") or 1))
			for i = 1, count do
				-- slight radial offset for multiple spawns at one leash
				local cf = topCenterCF(l) * CFrame.new(math.sin(i)*2, 0, math.cos(i)*2)
				local rig = spawnEnemyAt(l)
				if rig then pivotAndFace(rig, cf) end
			end
		end
	end
end


===== FILE: src/server/StoryDataService.lua =====
-- StoryDataService.lua
-- Wrapper over PlayerDataService for StoryUnlocks + lightweight flags

local RS = game:GetService("ReplicatedStorage")
local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))

-- -------- Allow-list (RS/StoryUnlockables) --------
local ALLOWED
local function refreshAllowed()
	ALLOWED = {}
	local folder = RS:FindFirstChild("StoryUnlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and type(sv.Value) == "string" and sv.Value ~= "" then
				ALLOWED[sv.Value] = true
			end
		end
	end
end
local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end
local storyFolder = RS:FindFirstChild("StoryUnlockables")
if storyFolder then
	storyFolder.ChildAdded:Connect(refreshAllowed)
	storyFolder.ChildRemoved:Connect(refreshAllowed)
end

-- -------- Internals --------
local Busy = setmetatable({}, { __mode = "k" })

local StoryDataService = {}

local function ensureFields(profile)
	local data = profile.Data
	data.StoryUnlocks = data.StoryUnlocks or {}   -- map: [id]=true
	data.StoryFlags   = data.StoryFlags   or {}   -- map: [key]=primitive
end

function StoryDataService.HasStory(player, storyId)
	local profile = PlayerDataService.GetProfile(player)
	if not profile or type(storyId) ~= "string" or storyId == "" then return false end
	ensureFields(profile)
	return profile.Data.StoryUnlocks[storyId] == true
end

function StoryDataService.AddStory(player, storyId, saveNow)
	if type(storyId) ~= "string" or storyId == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	local allowed = getAllowed()
	if not allowed[storyId] then
		warn("[StoryDataService] AddStory rejected (not allowed):", storyId)
		return false
	end
	if Busy[player] then return false end
	Busy[player] = true
	local ok, res = pcall(function()
		if profile.Data.StoryUnlocks[storyId] then return false end
		profile.Data.StoryUnlocks[storyId] = true
		if saveNow and profile.Save then pcall(function() profile:Save() end) end
		return true
	end)
	Busy[player] = nil
	if not ok then warn("[StoryDataService] Error:", res) return false end
	return res
end

function StoryDataService.GetFlags(player)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return table.clone(profile.Data.StoryFlags)
end

function StoryDataService.GetFlag(player, key)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return profile.Data.StoryFlags[key]
end

function StoryDataService.SetFlag(player, key, value, saveNow)
	if type(key) ~= "string" or key == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	profile.Data.StoryFlags[key] = value
	if saveNow and profile.Save then pcall(function() profile:Save() end) end
	return true
end

return StoryDataService


===== FILE: src/server/StoryDialogueHandler.lua =====
-- StoryDataService.lua
-- Wrapper over PlayerDataService for StoryUnlocks + lightweight flags

local RS = game:GetService("ReplicatedStorage")
local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))

-- -------- Allow-list (RS/StoryUnlockables) --------
local ALLOWED
local function refreshAllowed()
	ALLOWED = {}
	local folder = RS:FindFirstChild("StoryUnlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and type(sv.Value) == "string" and sv.Value ~= "" then
				ALLOWED[sv.Value] = true
			end
		end
	end
end
local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end
local storyFolder = RS:FindFirstChild("StoryUnlockables")
if storyFolder then
	storyFolder.ChildAdded:Connect(refreshAllowed)
	storyFolder.ChildRemoved:Connect(refreshAllowed)
end

-- -------- Internals --------
local Busy = setmetatable({}, { __mode = "k" })

local StoryDataService = {}

local function ensureFields(profile)
	local data = profile.Data
	data.StoryUnlocks = data.StoryUnlocks or {}   -- map: [id]=true
	data.StoryFlags   = data.StoryFlags   or {}   -- map: [key]=primitive
end

function StoryDataService.HasStory(player, storyId)
	local profile = PlayerDataService.GetProfile(player)
	if not profile or type(storyId) ~= "string" or storyId == "" then return false end
	ensureFields(profile)
	return profile.Data.StoryUnlocks[storyId] == true
end

function StoryDataService.AddStory(player, storyId, saveNow)
	if type(storyId) ~= "string" or storyId == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	local allowed = getAllowed()
	if not allowed[storyId] then
		warn("[StoryDataService] AddStory rejected (not allowed):", storyId)
		return false
	end
	if Busy[player] then return false end
	Busy[player] = true
	local ok, res = pcall(function()
		if profile.Data.StoryUnlocks[storyId] then return false end
		profile.Data.StoryUnlocks[storyId] = true
		if saveNow and profile.Save then pcall(function() profile:Save() end) end
		return true
	end)
	Busy[player] = nil
	if not ok then warn("[StoryDataService] Error:", res) return false end
	return res
end

function StoryDataService.GetFlags(player)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return table.clone(profile.Data.StoryFlags)
end

function StoryDataService.GetFlag(player, key)
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return nil end
	ensureFields(profile)
	return profile.Data.StoryFlags[key]
end

function StoryDataService.SetFlag(player, key, value, saveNow)
	if type(key) ~= "string" or key == "" then return false end
	local profile = PlayerDataService.GetProfile(player)
	if not profile then return false end
	ensureFields(profile)
	profile.Data.StoryFlags[key] = value
	if saveNow and profile.Save then pcall(function() profile:Save() end) end
	return true
end

return StoryDataService


===== FILE: src/server/StoryUnlockables.lua =====
-- StoryUnlockables.lua
-- Master allow-list for story IDs; mirrors to RS/StoryUnlockables as StringValues

local RS = game:GetService("ReplicatedStorage")

local StoryAllow = {
	"Hotpants_Start",
	"Horse_Keeper",
	"Johnny_Joestar_Start",
	-- add more storyIds here...
}

local folder = RS:FindFirstChild("StoryUnlockables")
if not folder then
	folder = Instance.new("Folder")
	folder.Name = "StoryUnlockables"
	folder.Parent = RS
end

for _, child in ipairs(folder:GetChildren()) do child:Destroy() end
for _, id in ipairs(StoryAllow) do
	local sv = Instance.new("StringValue")
	sv.Name = id
	sv.Value = id
	sv.Parent = folder
end

return StoryAllow


===== FILE: src/server/StoryUnlockHandler.lua =====
-- StoryUnlockHandler.lua
-- Mirrors UnlockHandler, but for story unlocks (persistence only)

local RS = game:GetService("ReplicatedStorage")
local Remotes        = RS:WaitForChild("RemoteEvents")
local UnlockStory    = Remotes:WaitForChild("UnlockStory")
local ConfirmSuccess = Remotes:FindFirstChild("ConfirmSuccess")

local StoryDataService = require(script.Parent:WaitForChild("StoryDataService"))

local function notify(player, ok, message)
	if ConfirmSuccess then
		ConfirmSuccess:FireClient(player, { ok = ok, msg = message })
	end
end

local busy = setmetatable({}, { __mode = "k" }) -- weak keys

UnlockStory.OnServerEvent:Connect(function(player, storyId)
	if busy[player] then return end
	busy[player] = true
	task.delay(0.25, function() busy[player] = nil end)

	if type(storyId) ~= "string" or storyId == "" or #storyId > 60 then
		notify(player, false, "Invalid story request.")
		return
	end

	if StoryDataService.HasStory(player, storyId) then
		notify(player, true, ("Story '%s' already unlocked."):format(storyId))
		return
	end

	local added = StoryDataService.AddStory(player, storyId, true)
	if not added then
		notify(player, false, "Story unlock failed or not allowed.")
		return
	end

	notify(player, true, ("Story unlocked: %s"):format(storyId))
end)
return true


===== FILE: src/server/UnlockHandler.server.lua =====
-- UnlockHandler.lua (ServerScriptService)
-- Handles client requests to unlock a node and hot-loads it

local RS = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local NodeManager       = require(game:GetService("ReplicatedStorage"):WaitForChild("NodeManager"))

local Remotes        = RS:WaitForChild("RemoteEvents")
local UnlockNode     = Remotes:WaitForChild("UnlockNode")
local ConfirmSuccess = Remotes:WaitForChild("ConfirmSuccess", 2) -- optional

local function notify(player, ok, message)
	if ConfirmSuccess then
		ConfirmSuccess:FireClient(player, { ok = ok, msg = message })
	end
end

local busy = setmetatable({}, { __mode = "k" }) -- weak keys

UnlockNode.OnServerEvent:Connect(function(player, nodeName)
	if busy[player] then return end
	busy[player] = true
	task.delay(0.25, function() busy[player] = nil end)

	if type(nodeName) ~= "string" or nodeName == "" or #nodeName > 40 then
		notify(player, false, "Invalid unlock request.")
		return
	end

	local profile = PlayerDataService.GetProfile(player)
	if not profile then
		notify(player, false, "Data not ready. Try again in a moment.")
		return
	end

	-- Already has it?
	for _, n in ipairs(profile.Data.Unlocks or {}) do
		if n == nodeName then
			notify(player, true, nodeName .. " already unlocked.")
			return
		end
	end

	local added = PlayerDataService.AddUnlock(player, nodeName, true)
	if not added then
		notify(player, false, "Unlock failed or not allowed.")
		return
	end

	NodeManager.AddUnlock(player, nodeName)
	print(player.Name, "unlocked", nodeName)
	notify(player, true, "Unlocked " .. nodeName .. "!")
end)

===== FILE: src/server/WeaponHandler.server.lua =====

-- ServerScriptService/WeaponHandler.lua
-- Bridges client input -> node execution
-- Blocks most actions while Mounted, but whitelists system actions (SummonHorse, BlockEnd, Dismount).
-- Also lets certain nodes run even if not in the 5-slot loadout.

local RS      = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local PlayerDataService = require(script.Parent:WaitForChild("PlayerDataService"))
local NodeManager       = require(RS:WaitForChild("NodeManager"))

local Remotes       = RS:WaitForChild("RemoteEvents")
local ActivateNode  = Remotes:WaitForChild("ActivateNode")

-- If your node scripts live here:
local NodeModulesFolder = RS:FindFirstChild("NodeModules")

-- ==== MOUNT GUARD CONFIG =====================================================
local DEBUG_MOUNT = true

local ALLOW_WHEN_MOUNTED = {
	BlockEnd = true,                 -- allow releasing block while mounted
	SummonHorse = true,              -- allow summon/dismiss even if mounted
	Horse_RequestDismount = true,    -- if you route this through the same handler
}

-- Always-available "system actions" (not counted in 5-slot loadout)
local ALWAYS_AVAILABLE = {
	SummonHorse = true,
}
-- ============================================================================

local function isMounted(player)
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	return hum ~= nil and hum:GetAttribute("Mounted") == true
end

local function getDirVecOrFallback(player, dirVec)
	if typeof(dirVec) == "Vector3" and dirVec.Magnitude > 0 then
		return dirVec.Unit
	end
	local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if root then return root.CFrame.LookVector end
	return Vector3.new(0, 0, -1)
end

local function resolveNode(player, nodeName)
	-- Loadout-aware path first
	local node = NodeManager.GetNode(player, nodeName)
	if node then return node end

	-- System actions: allow direct require from RS/NodeModules/<name>
	if ALWAYS_AVAILABLE[nodeName] and NodeModulesFolder then
		local mod = NodeModulesFolder:FindFirstChild(nodeName)
		if mod and mod:IsA("ModuleScript") then
			local ok, res = pcall(require, mod)
			if ok then return res end
			warn(("[WeaponHandler] Failed to require NodeModules.%s: %s"):format(nodeName, tostring(res)))
		end
	end

	return nil
end

ActivateNode.OnServerEvent:Connect(function(player, nodeName, dirVec)
	-- 0) Hard gate while mounted (whitelist exceptions)
	if isMounted(player) and not ALLOW_WHEN_MOUNTED[nodeName] then
		if DEBUG_MOUNT then
			print(("[WeaponHandler] BLOCKED while mounted â–¶ %s  node=%s"):format(player.Name, tostring(nodeName)))
		end
		return
	end

	print(('[WeaponHandler] â–¶ %s  node=%s'):format(player.Name, tostring(nodeName)))

	-- 1) Validate
	if type(nodeName) ~= "string" or nodeName == "" then
		warn("[WeaponHandler] Invalid node name from", player.Name); return
	end

	-- 2) Ensure profile
	local profile = PlayerDataService.GetProfile(player)
	if not profile then
		warn("[WeaponHandler] No profile yet for", player.Name, "(ignoring)"); return
	end

	-- 3) Resolve node (loadout first; fallback system action module)
	local node = resolveNode(player, nodeName)
	if not node then
		warn(('[WeaponHandler] Node not found for %s: %s'):format(player.Name, nodeName))
		return
	end

	-- 4) Direction
	dirVec = getDirVecOrFallback(player, dirVec)

	-- 5) Execute via common call patterns
	local ok, err
	if type(node.OnStart) == "function" then
		ok, err = pcall(function() node.OnStart(player, dirVec) end)
		if ok then return else warn("[WeaponHandler] OnStart error:", err) end
	end

	if type(node.Execute) == "function" then
		ok, err = pcall(function() node.Execute(player, dirVec) end)
		if ok then return else warn("[WeaponHandler] Execute(player,dir) error:", err) end

		local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if root then
			ok, err = pcall(function() node:Execute(root, dirVec) end)
			if ok then return else warn("[WeaponHandler] Execute(root,dir) error:", err) end
		end
	end

	warn("[WeaponHandler] No valid call pattern for node:", nodeName)
end)


===== FILE: src/shared/AI/Attention.lua =====


===== FILE: src/shared/AI/Blackboard.lua =====
-- ReplicatedStorage/AI/Blackboard.lua
-- TTL flags per target (blocking, parryWindow, dodgeActive, incoming tags, etc.)
local Blackboard = {}
Blackboard.__index = Blackboard

local function now() return os.clock() end

function Blackboard.new()
	return setmetatable({
		flags = {},   -- name -> { value=any, expires=number|nil }
	}, Blackboard)
end

function Blackboard:set(name, value, ttl)
	local e = ttl and (now() + ttl) or nil
	self.flags[name] = { value = value, expires = e }
end

function Blackboard:touch(name, ttl)
	local slot = self.flags[name]
	if not slot then return end
	if ttl then slot.expires = now() + ttl end
end

function Blackboard:get(name)
	local slot = self.flags[name]
	if not slot then return nil end
	if slot.expires and slot.expires <= now() then
		self.flags[name] = nil
		return nil
	end
	return slot.value
end

function Blackboard:clear(name) self.flags[name] = nil end

return Blackboard


===== FILE: src/shared/AI/EnemyController.lua =====
-- ReplicatedStorage/AI/EnemyController.lua
local Players     = game:GetService("Players")
local RS          = game:GetService("ReplicatedStorage")
local RunService  = game:GetService("RunService")

local Attention   = require(RS:WaitForChild("AI"):WaitForChild("Attention"))
local Blackboard  = require(RS:WaitForChild("AI"):WaitForChild("Blackboard"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))

-- Optional NodeLibrary adapter
local NL
do
	local libScript = game.ServerScriptService:FindFirstChild("NodeLibrary") or RS:FindFirstChild("NodeLibrary")
	if libScript then NL = require(libScript) end
end

-- === Moves (with NPC dodge fallback) ========================================
local Moves = {}

local function _charOf(actor)
	if typeof(actor) == "Instance" and actor:IsA("Model") then return actor end
	if typeof(actor) == "Instance" and actor:IsA("Player") then return actor.Character end
	return nil
end
local function _hrpOf(m) return m and m:FindFirstChild("HumanoidRootPart") end

function Moves.M1(actor)              if NL and NL.Punch      then NL.Punch(actor)          end end
function Moves.Heavy(actor)           if NL and NL.Heavy      then NL.Heavy(actor)          end end
function Moves.BlockStart(actor)      if NL and NL.BlockStart then NL.BlockStart(actor)      end end
function Moves.BlockEnd(actor)        if NL and NL.BlockEnd   then NL.BlockEnd(actor)        end end
function Moves.Revolver(actor, dir)   if NL and NL.Revolver   then NL.Revolver(actor, dir)   end end

-- Fallback Dodge: simple BodyVelocity burst (movement only; no iframes)
local function _fallbackDodgeBurst(actor, dirVec, dur)
	local ch  = _charOf(actor)
	local hrp = _hrpOf(ch)
	if not hrp then return end
	local dir = (dirVec and dirVec.Magnitude > 0) and dirVec.Unit or hrp.CFrame.LookVector
	local bv  = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(1e5, 0, 1e5)
	bv.P        = 1250
	bv.Velocity = dir * 50
	bv.Parent   = hrp
	task.delay(dur or 0.20, function() if bv then bv:Destroy() end end)
end

-- If NL expects a Player, pass it; otherwise pass the actor through.
local function _actorForNL(actor)
	if typeof(actor) == "Instance" and actor:IsA("Model") then
		return Players:GetPlayerFromCharacter(actor) or actor
	end
	return actor
end

-- Only skip fallback when NL.Dodge returns true explicitly.
function Moves.Dodge(actor, dirVec)
	if NL and NL.Dodge then
		local a = _actorForNL(actor)
		local ok, res = pcall(NL.Dodge, a, dirVec)
		if ok and res == true then
			return true
		end
	end
	_fallbackDodgeBurst(actor, dirVec, 0.22)
	return true
end

function Moves.DodgeAway(actorModel, fromPos)
	local hrp = actorModel and actorModel:FindFirstChild("HumanoidRootPart")
	if hrp and fromPos then
		local away = (hrp.Position - fromPos)
		if away.Magnitude > 0 then
			return Moves.Dodge(actorModel, away.Unit)
		end
	end
	return Moves.Dodge(actorModel)
end

-- === Controller =============================================================
local Controller = {}
Controller.__index = Controller

local function hrpOf(m) return m and m:FindFirstChild("HumanoidRootPart") end
local function humOf(m) return m and m:FindFirstChildOfClass("Humanoid") end
local function dist(a,b) return (a-b).Magnitude end
local function dir(from,to) local v=(to-from) local m=v.Magnitude return m>0 and (v/m) or v end
local function clamp01(x) return math.max(0, math.min(1, x)) end
local function lerp(a,b,t) return a + (b-a) * t end

-- DEF/OFF â†’ timings/weights
local function reactDelayByDEF(def) return lerp(0.35, 0.06, clamp01(def/100)) end
local function blockProbByDEF(def)  return lerp(0.25, 0.95, clamp01(def/100)) end
local function dodgeProbByDEF(def)  return lerp(0.20, 0.90, clamp01(def/100)) end
local function tempoGapByOFF(off)   return lerp(0.60, 0.15, clamp01(off/100)) end
local function comboLenByOFF(off)   return math.floor(lerp(2, 5, clamp01(off/100)) + 0.5) end

local DEBUG = false
local function log(...) if DEBUG then print("[EnemyController]", ...) end end

-- === NodeSense â†’ flags =======================================================
local function setIncoming(self, what, ttl) self.board:set(what, true, ttl or 0.6) end
local function clearIncoming(self)
	self.board:set("incomingHeavy",        false, 0.2)
	self.board:set("incomingUnblockable",  false, 0.2)
	self.board:set("incomingBlockable",    false, 0.2)
	self.board:set("incomingParryable",    false, 0.2)
	self.board:set("rangedThreat",         false, 0.2)
end

-- Treat any â€œbreaks blockâ€ as an unblockable-level danger for dodge logic.
local function interpretIntent(self, node, tags, closeEnough)
	if not closeEnough then return end
	local lower = (node or "Unknown"):lower()
	if tags and next(tags) then
		if tags.Unblockable then setIncoming(self, "incomingUnblockable", 0.8) end
		if tags.Heavy       then setIncoming(self, "incomingHeavy", 0.8) end
		if tags.Ranged or tags.Projectile then setIncoming(self, "rangedThreat", 0.8) end
		if tags.BreaksBlock or tags.GuardBreak or tags.ShieldBreak then
			setIncoming(self, "incomingUnblockable", 0.8)
		end
		if tags.Blockable or tags.Melee or tags.M1 then
			setIncoming(self, "incomingBlockable", 0.6)
			if tags.Parryable then setIncoming(self, "incomingParryable", 0.6) end
		end
		return
	end
	if lower:find("heavy") then
		setIncoming(self, "incomingHeavy", 0.8)
	elseif (lower:find("guard") and lower:find("break")) or lower:find("shieldbreak") then
		setIncoming(self, "incomingUnblockable", 0.8)
	elseif lower:find("revolver") or lower:find("shot") or lower:find("bullet") then
		setIncoming(self, "rangedThreat", 0.8)
	elseif lower:find("punch") or lower:find("m1") then
		setIncoming(self, "incomingBlockable", 0.6)
		setIncoming(self, "incomingParryable", 0.6)
	end
end

local function interpretSense(self, payload)
	if not payload or payload.actorModel == self.rig then return end
	local myHRP = hrpOf(self.rig); if not myHRP then return end

	local aHRP = payload.actorModel and hrpOf(payload.actorModel)
	local closeEnough = (aHRP and dist(aHRP.Position, myHRP.Position) <= 18)

	local outcome = payload.context and payload.context.outcome
	local node    = tostring(payload.nodeName or "Unknown")
	local tags    = payload.tags

	-- Outcomes targeted at me
	local myPlr = Players:GetPlayerFromCharacter(self.rig)
	local myId  = myPlr and myPlr.UserId or self.rig:GetAttribute("UID")
	if payload.context and payload.context.targetId and myId and payload.context.targetId ~= myId then
		-- ignore
	else
		if outcome == "Hit" then
			self.attention:Hit(payload.actorModel or payload.actorUserId, payload.context.damage or 1)
			self.board:set("recentlyHitAt", os.clock(), 1.0)
		elseif outcome == "Blocked" then
			self.attention:BlockedBy(payload.actorModel or payload.actorUserId, payload.context.guardDamage or 5)
			self.board:set("recentlyBlockedAt", os.clock(), 1.0)
		elseif outcome == "Parried" then
			self.attention:ParriedBy(payload.actorModel or payload.actorUserId)
			self.board:set("parryWindow", true, 0.35)
		elseif outcome == "GuardBroken" then
			self.board:set("blocking", false, 1.0)
			self.board:set("guardBroken", true, 1.0)
		elseif outcome == "Miss" and payload.context and payload.context.reason == "IFrame" then
			self.board:set("baitRoll", true, 0.8)
		end
	end

	-- Intent (treat nil outcome and "AttackStart" as intent)
	if (not outcome and closeEnough) or outcome == "AttackStart" then
		interpretIntent(self, node, tags, closeEnough)
	end
	-- Clear intent on AttackEnd
	if outcome == "AttackEnd" then
		clearIncoming(self)
	end

	-- Defensive state echoes
	if outcome == "BlockStart" then
		self.board:set("blocking", true, 0.9)
	elseif outcome == "BlockEnd" then
		self.board:set("blocking", false, 0.2)
	elseif outcome == "ParryWindowStart" then
		self.board:set("parryWindow", true, 0.35)
	elseif outcome == "ParryWindowEnd" then
		self.board:set("parryWindow", false, 0.05)
	end
end

-- === lifecycle ==============================================================
function Controller.Start(rig: Model, spec: table)
	local self = setmetatable({
		rig = rig,
		spec = spec or {},
		DEF = rig:GetAttribute("DEF") or (spec and spec.DEF) or 25,
		OFF = rig:GetAttribute("OFF") or (spec and spec.OFF) or 30,
		attention = Attention.new({ halfLife = 1.7 }),
		board = Blackboard.new(),
		lastJump = 0,
		lastActionAt = 0,
		lastDodgeAt = -1,          -- local dodge cooldown
		isBlocking = false,
		connections = {},
		-- preferred distance band (donâ€™t stand on top)
		rangeInner = 4.4,
		rangeKeep  = 4.5,
		rangeOuter = 4.6,
	}, Controller)

	self.leashObj  = rig:FindFirstChild("LeashPoint")
	self.leashPart = self.leashObj and self.leashObj.Value
	self.homeCF    = self.leashPart and self.leashPart.CFrame or rig:GetPivot()
	self.leashR    = rig:GetAttribute("LeashRadius") or 30
	self.aggroR    = rig:GetAttribute("AggroRadius") or 70

	local hum = humOf(rig); if hum then hum.AutoRotate = true end

	-- Subscribe to NodeSense server bus
	if NodeSense and NodeSense.ServerEvent and NodeSense.ServerEvent.Event then
		local conn = NodeSense.ServerEvent.Event:Connect(function(payload)
			interpretSense(self, payload)
		end)
		table.insert(self.connections, conn)
	end

	-- main loop
	local hb
	hb = RunService.Heartbeat:Connect(function(dt)
		if not self.rig.Parent then hb:Disconnect() return end
		Controller._tick(self, dt)
	end)
	table.insert(self.connections, hb)

	-- cleanup on death
	if hum then
		table.insert(self.connections, hum.Died:Connect(function()
			Controller.Stop(self)
		end))
	end

	return self
end

function Controller.Stop(self)
	for _, c in ipairs(self.connections or {}) do
		pcall(function() c:Disconnect() end)
	end
	self.connections = {}
end

-- === target & movement helpers =============================================
function Controller:_acquireTarget()
	local uid = self.attention:primary(0.3)
	if uid then
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.UserId == uid and plr.Character and humOf(plr.Character) and humOf(plr.Character).Health > 0 then
				return plr.Character
			end
		end
	end
	local myHRP = hrpOf(self.rig); if not myHRP then return nil end
	local best, bd = nil, self.aggroR
	for _, plr in ipairs(Players:GetPlayers()) do
		local ch = plr.Character; local hrp = ch and hrpOf(ch)
		local hum = ch and humOf(ch)
		if hum and hum.Health > 0 and hrp then
			local d = dist(myHRP.Position, hrp.Position)
			if d < bd then best, bd = ch, d end
		end
	end
	return best
end

function Controller:_withinLeash()
	local p = hrpOf(self.rig); if not p then return true end
	local center = self.leashPart and self.leashPart.Position or self.homeCF.Position
	return dist(p.Position, center) <= (self.leashR + 5)
end

function Controller:_moveTo(pos) local h = humOf(self.rig); if h then h:MoveTo(pos) end end

-- keep a ring around the target; never stand on top
function Controller:_approachInBand(thrp)
	local myHRP = hrpOf(self.rig); if not (myHRP and thrp) then return end
	local myPos, tPos = myHRP.Position, thrp.Position
	local d  = dist(myPos, tPos)
	local dv = dir(tPos, myPos) -- vector from target â†’ me

	if d > self.rangeOuter then
		-- approach, but stop at keep distance (do not MoveTo target directly)
		local dest = tPos + (-dir(tPos, myPos)) * self.rangeKeep
		self:_moveTo(dest)
	elseif d < self.rangeInner then
		-- too close â†’ step back a little (spacing only; no dodge)
		local retreat = myPos + dv * (self.rangeInner - d + 1.0)
		self:_moveTo(retreat)
	end
	-- if inside the band, no MoveTo â†’ we can attack/strafe
end

-- local dodge cooldown (used only for danger-dodge)
function Controller:_tryDodgeAway(thrpPos)
	local now = os.clock()
	if (now - (self.lastDodgeAt or -1)) < 1.25 then return false end
	self.lastDodgeAt = now
	Moves.DodgeAway(self.rig, thrpPos)
	return true
end

-- === decision loop ==========================================================
function Controller._tick(self, dt)
	local rig  = self.rig
	local myHRP = hrpOf(rig); local hum = humOf(rig)
	if not myHRP or not hum or hum.Health <= 0 then return end

	-- leash
	if not self:_withinLeash() then
		local homePos = (self.leashPart and self.leashPart.Position) or self.homeCF.Position
		self:_moveTo(homePos)
		return
	end

	local target = self:_acquireTarget()
	if not target then
		self:_moveTo(((self.leashPart and self.leashPart.Position) or self.homeCF.Position))
		return
	end
	local thrp = hrpOf(target); if not thrp then return end

	local d = dist(myHRP.Position, thrp.Position)
	local now = os.clock()

	-- soft hop only when far (prevents â€œjump on headâ€ near)
	if d > 10 and now - self.lastJump > lerp(1.5, 3.5, 1 - clamp01(self.OFF/100)) then
		hum.Jump = true
		self.lastJump = now
	end

	-- read board
	local blocking        = self.board:get("blocking") == true
	local parryWindow     = self.board:get("parryWindow") == true
	local incomingHeavy   = self.board:get("incomingHeavy") == true
	local incomingUnblk   = self.board:get("incomingUnblockable") == true
	local incomingBlock   = self.board:get("incomingBlockable") == true
	local rangedThreat    = self.board:get("rangedThreat") == true
	local recentlyBlocked = (self.board:get("recentlyBlockedAt") ~= nil)

	-- === DODGE POLICY: ONLY on dangerous threats (Unblockable or Heavy) ===
	if incomingUnblk or incomingHeavy then
		if math.random() < dodgeProbByDEF(self.DEF) then
			task.delay(reactDelayByDEF(self.DEF), function()
				self:_tryDodgeAway(thrp.Position)
			end)
			return
		end
	end

	-- Block normal melee if appropriate
	if incomingBlock and d < 6 then
		if math.random() < blockProbByDEF(self.DEF) then
			task.delay(reactDelayByDEF(self.DEF), function()
				Moves.BlockStart(rig); self.isBlocking = true
				task.delay(lerp(0.3, 1.2, clamp01(self.DEF/100)), function()
					Moves.BlockEnd(rig); self.isBlocking = false
				end)
			end)
			return
		end
	end

	-- maintain distance band while waiting for tempo
	local gap = tempoGapByOFF(self.OFF)
	if now - self.lastActionAt < gap then
		self:_approachInBand(thrp)
		return
	end

	-- ranged pressure when far / during enemy parry
	if parryWindow or d > 14 or rangedThreat then
		Moves.Revolver(rig, dir(myHRP.Position, thrp.Position))
		self.lastActionAt = now
		return
	end

	-- punish blockers
	if (blocking or recentlyBlocked) and d <= 7 then
		if math.random() < lerp(0.2, 0.8, clamp01(self.OFF/100)) then
			Moves.Heavy(rig)
			self.lastActionAt = now
			return
		end
	end

	-- keep band, then attack
	self:_approachInBand(thrp)

	-- if outside inner band, we can choose to close one step before M1
	if d > self.rangeOuter then
		-- approach already handled above; wait a frame
		return
	end

	-- M1 burst (no automatic dodge-out anymore)
	local len = math.max(2, math.min(5, comboLenByOFF(self.OFF)))
	for i=1,len do
		if parryWindow then break end
		Moves.M1(rig)
		task.wait(lerp(0.16, 0.10, clamp01(self.OFF/100)))
	end
	self.lastActionAt = os.clock()
end

return Controller


===== FILE: src/shared/Horses/Default.lua =====


===== FILE: src/shared/NodeModules/BlockEnd.lua =====
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))

local NL = require(game.ServerScriptService:FindFirstChild("NodeLibrary")
	or RS:FindFirstChild("NodeLibrary"))

local BlockEnd = NodeFactory.Create{
	Name        = "BlockEnd",
	Keybind     = Enum.KeyCode.Unknown,
	Cooldown    = 0,
	Radius      = 0.1,
	Damage      = 0,
	GuardDamage = 0,
	Stun        = 0,
}

if NL and NL.BlockEnd then
	BlockEnd.OnStart = function(player, ...)
		-- No NodeSense intent here: GuardService.EndBlock will emit "BlockEnd".
		return NL.BlockEnd(player, ...)
	end
end

return BlockEnd


===== FILE: src/shared/NodeModules/BlockStart.lua =====
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))

local NL = require(game.ServerScriptService:FindFirstChild("NodeLibrary")
	or RS:FindFirstChild("NodeLibrary"))

local BlockStart = NodeFactory.Create{
	Name        = "BlockStart",
	Keybind     = Enum.KeyCode.Unknown,
	Cooldown    = 0,
	Radius      = 0.1,
	Damage      = 0,
	GuardDamage = 0,
	Stun        = 0,
}

if NL and NL.BlockStart then
	BlockStart.OnStart = function(player, ...)
		-- Intent ping so AI sets targetBlocking immediately.
		local tags = NodeSense.CollectTags(BlockStart, {
			Defensive = true,
			Block     = true,
		})
		NodeSense.Emit(player, "Block", tags, {
			nodeName = "Block",
		})

		return NL.BlockStart(player, ...)
	end
end

return BlockStart


===== FILE: src/shared/NodeModules/Dodge.lua =====
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(game.ReplicatedStorage.NodeFactory)
local NodeSense   = require(RS:WaitForChild("NodeSense"))

local NL = require(game.ServerScriptService:FindFirstChild("NodeLibrary")
	or RS:FindFirstChild("NodeLibrary"))

local Dodge = NodeFactory.Create{
	Name        = "Dodge",
	Keybind     = Enum.KeyCode.Unknown,
	Cooldown    = 0,
	Radius      = 0.1,
	Damage      = 0,
	GuardDamage = 0,
	Stun        = 0,
}

if NL and NL.Dodge then
	Dodge.OnStart = function(player, ...)
		-- Intent ping so AI recognizes an incoming evade/i-frame action.
		local tags = NodeSense.CollectTags(Dodge, {
			Defensive = true,
			Dodge     = true,
			IFrame    = true,
			Evade     = true,
		})

		NodeSense.Emit(player, "Dodge", tags, {
			nodeName = "Dodge",
			-- duration can be inferred later from IFrameStore if needed
		})

		return NL.Dodge(player, ...)
	end
end

return Dodge


===== FILE: src/shared/NodeModules/Gallop.lua =====
-- ReplicatedStorage/NodeModules/Gallop.lua
-- Hidden passive unlock used as a durable flag via PlayerDataService.
-- Not clickable, not on hotbar; just marks that the player owns Gallop.
local M = {
	Name = "Gallop",
	Passive = true,
	Hidden = true,          -- NodeManager should ignore it in UI
	AllowWhileMounted = true,
}
function M.OnStart(player)
	-- No direct activation; server HorseMountServer handles it.
	return false
end
return M


===== FILE: src/shared/NodeModules/Heavy.lua =====
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))
local Facts       = require(RS:WaitForChild("CardinalFacts"))

local NL
do
	local s = (game.ServerScriptService:FindFirstChild("NodeLibrary") or RS:FindFirstChild("NodeLibrary"))
	if s then NL = require(s) end
end

local Heavy = NodeFactory.Create{
	Name   = "Heavy",
	Radius = 0.1,          -- satisfy NodeFactory assert; not used for telemetry
}

if NL and NL.Heavy then
	Heavy.OnStart = function(actor, ...)
		local f = Facts.Heavy
		NodeSense.EmitWithDef(actor, f, { Attack = true }, {
			nodeName    = "Heavy",
			damage      = f.Damage,
			guardDamage = f.GuardDamage,
			stun        = f.Stun,
			kbForce     = f.KnockbackForce,
		})
		return NL.Heavy(actor, ...)
	end
end

return Heavy


===== FILE: src/shared/NodeModules/Punch.lua =====
local RS          = game:GetService("ReplicatedStorage")
local NodeFactory = require(RS:WaitForChild("NodeFactory"))
local NodeSense   = require(RS:WaitForChild("NodeSense"))
local Facts       = require(RS:WaitForChild("CardinalFacts"))

local NL
do
	local s = (game.ServerScriptService:FindFirstChild("NodeLibrary") or RS:FindFirstChild("NodeLibrary"))
	if s then NL = require(s) end
end

local Punch = NodeFactory.Create{
	Name   = "Punch",
	Radius = 0.1,          -- satisfy NodeFactory assert; not used for telemetry
}

if NL and NL.Punch then
	Punch.OnStart = function(actor, ...)
		local f = Facts.Punch
		NodeSense.EmitWithDef(actor, f, { Attack = true }, {
			nodeName    = "Punch",
			damage      = f.Damage,
			guardDamage = f.GuardDamage,
			stun        = f.Stun,
		})
		return NL.Punch(actor, ...)
	end
end

return Punch


===== FILE: src/shared/NodeModules/Revolver.lua =====
--------------------------------------------------------------------
-- NodeModules/Revolver.lua (lock + interrupt aware, with prop fallback)
-- NodeFactory-driven revolver
-- Obeys CombatState.IsLocked and AttackStateService interruption.
--------------------------------------------------------------------
local RS      = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris  = game:GetService("Debris")

local NodeFactory        = require(RS:WaitForChild("NodeFactory"))
local CooldownService    = require(RS:WaitForChild("CooldownService"))
local CombatState        = require(RS:WaitForChild("CombatState"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local NodeSense          = require(RS:WaitForChild("NodeSense"))

local RemoteEvents   = RS:WaitForChild("RemoteEvents")
local CooldownNotice = RemoteEvents:WaitForChild("CooldownNotice")

--------------------------------------------------------------------
-- CONFIG
--------------------------------------------------------------------
local SHOT_COUNT        = 4
local SHOT_INTERVAL     = 0.2
local FIRST_SHOT_DELAY  = 0.2

local BULLET_SPEED      = 150
local BULLET_LIFETIME   = 15
local VIS_SIZE          = 0.2
local HIT_RADIUS        = 1

local COOLDOWN_TIME     = 15
local ANIM_ID           = "rbxassetid://95110526176115"

-- side offset (studs) so it appears from right hand side
local SIDE_OFFSET       = 1

-- Optional: name/path for gun prop template
local GUN_PROP_NAME     = "GunProp"

--------------------------------------------------------------------
-- Helpers: lock/interrupt gates
--------------------------------------------------------------------
local function isInterrupted(player: Player?, char: Model?): boolean
	-- 1) Global move lock (horse/combat lock, etc.)
	if player and CombatState and CombatState.IsLocked and CombatState.IsLocked(player) then
		return true
	end

	-- 2) AttackStateService interruption
	if AttackStateService and type(AttackStateService.IsInterrupted) == "function" then
		local ok, res = pcall(AttackStateService.IsInterrupted, player) -- use player, not char
		if ok and res then return true end
	end

	-- 3) Lightweight fallbacks
	if char then
		if char:GetAttribute("Interrupted") or char:GetAttribute("Stunned") then
			return true
		end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Health <= 0 then return true end
			local st = hum:GetState()
			if st == Enum.HumanoidStateType.Dead
				or st == Enum.HumanoidStateType.Ragdoll
				or st == Enum.HumanoidStateType.FallingDown then
				return true
			end
		end
	end

	return false
end

--------------------------------------------------------------------
-- Node definition
--------------------------------------------------------------------
local RevolverNode = NodeFactory.Create({
	Name             = "Revolver",

	UseMovingHitbox  = true,
	Radius           = HIT_RADIUS,
	Lifetime         = 10,   -- hitbox lifetime per bullet (not the visual)
	OneShot          = true,
	DestroyOnHit     = true,

	GetCFrame        = function(bullet) return bullet.CFrame end,
	LinkedParts      = function(bullet) return { bullet } end,

	Damage           = 5,
	GuardDamage      = 10,
	Parryable        = true,

	Stun             = 0.1,
	KnockbackForce   = 20,

	Cooldown         = 0    -- module handles its own cooldown gating
})

local module = {}

--------------------------------------------------------------------
-- Gun prop resolution + attach/detach
--------------------------------------------------------------------
local function resolveGunPropTemplate(): Instance?
	-- 1) Direct child
	local m = RS:FindFirstChild(GUN_PROP_NAME)
	if m and m:IsA("Model") then return m end

	-- 2) Common folders
	for _, folderName in ipairs({ "Props", "Assets", "Models" }) do
		local f = RS:FindFirstChild(folderName)
		if f then
			local c = f:FindFirstChild(GUN_PROP_NAME)
			if c and c:IsA("Model") then return c end
		end
	end

	-- 3) Deep search (one-time, cheap enough)
	for _, d in ipairs(RS:GetDescendants()) do
		if d:IsA("Model") and d.Name == GUN_PROP_NAME then
			return d
		end
	end

	warn("[REVOLVER] GunProp template not found in ReplicatedStorage")
	return nil
end

local function getRightHandSocket(char: Model): BasePart?
	return char:FindFirstChild("RightHand")
		or char:FindFirstChild("Right Arm")
		or char:FindFirstChild("RightArm")
end

local function attachGunProp(char: Model, template: Instance?): (Instance?, Instance?)
	if not (char and template and template:IsA("Model")) then return nil end

	local socket = getRightHandSocket(char)
	if not (socket and socket:IsA("BasePart")) then return nil end

	local prop = template:Clone()
	prop.Name = GUN_PROP_NAME
	prop.Parent = char

	local handle = prop:FindFirstChild("Handle")
	if not (handle and handle:IsA("BasePart")) then
		warn("[REVOLVER] GunProp has no BasePart 'Handle'")
		prop:Destroy()
		return nil
	end

	for _, d in ipairs(prop:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = false
			d.CanCollide = false
			d.Massless = true
			if d ~= handle then
				local wc = Instance.new("WeldConstraint")
				wc.Part0 = handle
				wc.Part1 = d
				wc.Parent = handle
			end
		end
	end

	-- Clean old grip
	local oldGrip = socket:FindFirstChild("GunGrip")
	if oldGrip then oldGrip:Destroy() end

	-- Attach
	local grip = Instance.new("Motor6D")
	grip.Name  = "GunGrip"
	grip.Part0 = socket
	grip.Part1 = handle
	grip.C0    = CFrame.new()
	grip.C1    = CFrame.new(0, -0.05, -0.12) * CFrame.Angles(0, 45, math.rad(180))
	grip.Parent = socket

	return prop, grip
end

local function detachGunProp(char: Model)
	local rh = getRightHandSocket(char)
	if rh then
		local grip = rh:FindFirstChild("GunGrip")
		if grip then grip:Destroy() end
	end
	local prop = char and char:FindFirstChild(GUN_PROP_NAME)
	if prop then prop:Destroy() end
end

--------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------
function module.OnStart(player, dirVec)
	-- Resolve character/root
	local char = player and player.Character
	if not char then return end
	local hrp  = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- ðŸ”’ Abort immediately if locked or interrupted
	if isInterrupted(player, char) then return end

	-- Local cooldown for the whole volley
	if not CooldownService.CanUse(player, "Revolver") then return end
	CooldownService.Apply(player, "Revolver", COOLDOWN_TIME)
	CooldownNotice:FireClient(player, {
		name = "Revolver",
		duration = COOLDOWN_TIME,
		started = os.clock(),
	})

	-- ðŸ”” Intent ping (before volley)
	local tags = NodeSense.CollectTags(RevolverNode, {
		Ranged           = true,
		Projectile       = true,
		UsesMovingHitbox = true,
		Blockable        = true,
		Parryable        = RevolverNode.Parryable,
	})
	NodeSense.Emit(player, "Revolver", tags, {
		nodeName    = "Revolver",
		damage      = RevolverNode.Damage,
		guardDamage = RevolverNode.GuardDamage,
		stun        = RevolverNode.Stun,
		kbForce     = RevolverNode.KnockbackForce,
		shotIndex   = 0, -- intent marker (pre-volley)
	})

	-- Resolve prop template once (before any waits)
	local propTemplate = resolveGunPropTemplate()

	-- Play animation once
	local hum = char:FindFirstChildOfClass("Humanoid")
	local track
	local propAttached = false

	if hum then
		local anim = Instance.new("Animation")
		anim.AnimationId = ANIM_ID
		track = hum:LoadAnimation(anim)
		track:Play()

		-- Register with CombatState so global interrupts/locks can stop it
		pcall(function() CombatState.RegisterTrack(player, track) end)

		-- If the anim has markers, use them
		track:GetMarkerReachedSignal("draw"):Connect(function()
			if not propAttached and not isInterrupted(player, char) then
				local prop = attachGunProp(char, propTemplate)
				if prop then propAttached = true end
			end
		end)
		track:GetMarkerReachedSignal("holster"):Connect(function()
			detachGunProp(char)
			propAttached = false
		end)
		track.Stopped:Connect(function()
			detachGunProp(char)
			propAttached = false
		end)
	end

	-- Normalize direction (fallback HRP forward)
	local dir = (typeof(dirVec)=="Vector3" and dirVec.Magnitude>0) and dirVec.Unit or hrp.CFrame.LookVector

	-- First-shot delay (cancel if interrupted/locked meanwhile)
	local t0 = os.clock()
	while os.clock() - t0 < FIRST_SHOT_DELAY do
		if isInterrupted(player, char) then
			detachGunProp(char)
			pcall(function() if track then track:Stop() end end)
			return
		end
		task.wait()
	end

	-- Fallback: if no marker has attached the prop yet, attach now
	if not propAttached and propTemplate and not isInterrupted(player, char) then
		local prop = attachGunProp(char, propTemplate)
		if prop then propAttached = true end
	end

	-- Fire volley
	for i = 1, SHOT_COUNT do
		-- ðŸ”’ Check before each shot
		if isInterrupted(player, char) then
			detachGunProp(char)
			pcall(function() if track then track:Stop() end end)
			return
		end

		-- Origin from hand if possible
		local hand = getRightHandSocket(char)
		local originPos = hand and hand.Position or hrp.Position
		local aimCF = CFrame.lookAt(originPos, originPos + dir, Vector3.yAxis)
		local spawnPos = originPos + (dir * 2) + (aimCF.RightVector * SIDE_OFFSET)

		-- Visual bullet
		local bullet = Instance.new("Part")
		bullet.Name       = "RevolverBullet"
		bullet.Shape      = Enum.PartType.Ball
		bullet.Size       = Vector3.new(VIS_SIZE, VIS_SIZE, VIS_SIZE)
		bullet.CFrame     = CFrame.lookAt(spawnPos, spawnPos + dir)
		bullet.Color      = Color3.new(0,0,0)
		bullet.Material   = Enum.Material.Metal
		bullet.CanCollide = false
		bullet.Anchored   = false
		bullet.Parent     = workspace

		local bv = Instance.new("BodyVelocity")
		bv.MaxForce = Vector3.new(1e5,1e5,1e5)
		bv.Velocity = dir * BULLET_SPEED
		bv.Parent   = bullet

		Debris:AddItem(bullet, BULLET_LIFETIME)
		Debris:AddItem(bv,     BULLET_LIFETIME)

		-- Execute node (NodeFactory will also run its own guards)
		RevolverNode:Execute(hrp, bullet)

		-- Interval (cancel during wait)
		if i < SHOT_COUNT then
			local t = os.clock()
			while os.clock() - t < SHOT_INTERVAL do
				if isInterrupted(player, char) then
					detachGunProp(char)
					pcall(function() if track then track:Stop() end end)
					return
				end
				task.wait()
			end
		end
	end

	-- Ensure cleanup even if the anim keeps playing
	detachGunProp(char)
end

return module


===== FILE: src/shared/NodeModules/SummonHorse.lua =====
-- ReplicatedStorage/NodeModules/SummonHorse.lua
-- Toggle summon/dismiss, unlock + cooldown gated.

local RS  = game:GetService("ReplicatedStorage")
local SSS = game:GetService("ServerScriptService")

local CooldownService = require(RS:WaitForChild("CooldownService"))
local HS  = require(SSS:WaitForChild("HorseService"))

local Remotes        = RS:WaitForChild("RemoteEvents")
local ConfirmSuccess = Remotes:FindFirstChild("ConfirmSuccess")
local CooldownNotice = Remotes:FindFirstChild("CooldownNotice")

local NODE_NAME   = "SummonHorse"
local COOLDOWN_S  = 10
local LEFT_OFFSET = 5
local UNLOCK_ATTR = "HasHorse" -- only blocks if explicitly false

local function toast(p, msg)
	if ConfirmSuccess then ConfirmSuccess:FireClient(p, { ok = true, msg = msg }) end
end

local function pushCD(p)
	if CooldownNotice then
		CooldownNotice:FireClient(p, { name = NODE_NAME, duration = COOLDOWN_S, started = os.clock() })
	end
end

local M = { Name = NODE_NAME }

function M.OnStart(player, dirVec)
	-- unlock gate: if attr missing -> allow; if false -> block
	if player:GetAttribute(UNLOCK_ATTR) == false then
		toast(player, "You haven't unlocked your horse yet.")
		return false
	end

	-- cooldown gate
	if not CooldownService.CanUse(player, NODE_NAME) then return false end
	CooldownService.Apply(player, NODE_NAME, COOLDOWN_S)
	pushCD(player)

	local char = player.Character
	local hrp  = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end

	local active = HS.GetActive and HS.GetActive(player)
	if active then
		HS.Despawn(player)
		toast(player, "Dismissed your horse.")
		return true
	else
		local cf = hrp.CFrame * CFrame.new(-LEFT_OFFSET, 0, 0)
		local horse = HS.SummonTo(player, cf)
		if horse then toast(player, "Summoned your horse.") end
		return horse ~= nil
	end
end

return M


===== FILE: src/shared/Stories/Horse_Keeper.lua =====


===== FILE: src/shared/Stories/Hotpants_Start.lua =====


===== FILE: src/shared/Stories/Johnny_Joestar_Start.lua =====


===== FILE: src/shared/Unlockables/Gallop.meta.json =====
{ "$className": "StringValue", "Value": "" }


===== FILE: src/shared/Unlockables/Revolver.meta.json =====
{ "$className": "StringValue", "Value": "" }


===== FILE: src/shared/Unlockables/SummonHorse.meta.json =====
{ "$className": "StringValue", "Value": "" }


===== FILE: src/shared/Unlockables/Unlockables.lua =====
-- Unlockables.lua (ServerScriptService)
-- Master list of all unlockable nodes beyond the defaults.
-- Also mirrors them into ReplicatedStorage/Unlockables as StringValues.

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Unlockables = {
	"Revolver",
	"SummonHorse",
	"Gallop", 
	-- add future unlockable moves here...
}

-- Mirror to RS/Unlockables for clients/NodeManager/PlayerDataService
local folder = ReplicatedStorage:FindFirstChild("Unlockables")
if not folder then
	folder = Instance.new("Folder")
	folder.Name = "Unlockables"
	folder.Parent = ReplicatedStorage
end
for _, child in ipairs(folder:GetChildren()) do child:Destroy() end
for _, name in ipairs(Unlockables) do
	local sv = Instance.new("StringValue")
	sv.Name = name
	sv.Value = name
	sv.Parent = folder
end

return Unlockables

===== FILE: src/shared/AttackStateService.lua =====
-- AttackStateService  (ReplicatedStorage)
--
-- Tracks per-player attack phases so delayed hit logic can be cancelled
-- if the attacker is interrupted. Also supports:
--   â€¢ Hyper-Armor  â€“ ignore interrupts (stun / hit-stagger).
--   â€¢ Move I-frames â€“ grant temporary invulnerability at startup.
--
-- Emits NodeSense outcomes (server-side safe):
--   AttackStart            { duration? }
--   AttackEnd              { result = "Completed" | "Canceled" | "Interrupted" }
--   Interrupted            { reason = "Interrupt" }
--   HyperArmorStart/End    { reason? }
--
-- Usage inside a Node (e.g., Heavy):
--   AttackStateService.Start(player, {
--     duration   = 0.55,
--     hyperArmor = true,
--     iFrames    = 0.4,
--     nodeName   = "Heavy"    -- optional, for nicer telemetry labels
--   })
--   task.delay(0.55, function()
--     -- âœ… gate on IsActive so any cancel before impact stops the hit
--     if AttackStateService.IsActive and not AttackStateService.IsActive(player) then return end
--     -- deal damage here
--     AttackStateService.Clear(player)
--   end)
---------------------------------------------------------------------

local AttackStateService = {}

------------------------------ SERVICES
local Players           = game:GetService("Players")
local RS                = game:GetService("ReplicatedStorage")
local IFrameStore       = require(RS:WaitForChild("IFrameStore"))
local NodeSense         = require(RS:WaitForChild("NodeSense"))

------------------------------ STATE
-- [player] = {
--   interrupted = false,
--   hyperArmor  = false,
--   endTask     = task handle or nil,
--   nodeName    = "Attack",
--   startedAt   = os.clock(),
-- }
local attackState = {}

------------------------------ INTERNAL
local function emit(player, nodeName, outcome, ctx)
	-- Safe on client: NodeSense no-ops there; server will broadcast.
	pcall(function()
		NodeSense.EmitOutcome(player, nodeName or "Attack", outcome, ctx or {})
	end)
end

local function endAttackInternal(player, result, reason)
	local st = attackState[player]
	if not st then return end
	-- cancel timer
	if st.endTask then
		pcall(task.cancel, st.endTask)
	end

	-- Hyper armor ends when the attack ends
	if st.hyperArmor then
		emit(player, st.nodeName, "HyperArmorEnd", { reason = reason or result })
	end

	-- Finalize with AttackEnd
	emit(player, st.nodeName, "AttackEnd", { result = result or "Canceled" })

	attackState[player] = nil
end

------------------------------ PUBLIC API

-- params:
--   â€¢ duration    (number) â€“ seconds until attack naturally ends
--   â€¢ hyperArmor  (bool)   â€“ immune to interruption
--   â€¢ iFrames     (number) â€“ grant i-frames at start
--   â€¢ nodeName    (string) â€“ optional label for telemetry
function AttackStateService.Start(player, params)
	if not player then return end

	-- Clear any previous attack (treat as canceled)
	if attackState[player] then
		endAttackInternal(player, "Canceled", "Restart")
	end

	local cfg = params or {}
	local nodeName = tostring(cfg.nodeName or cfg.name or "Attack")

	attackState[player] = {
		interrupted = false,
		hyperArmor  = cfg.hyperArmor == true,
		endTask     = nil,
		nodeName    = nodeName,
		startedAt   = os.clock(),
	}

	-- Optional move-based i-frames (authoritative in IFrameStore)
	if cfg.iFrames and cfg.iFrames > 0 then
		IFrameStore.Grant(player, cfg.iFrames, "Move")
	end

	-- Hyper armor telemetry (if enabled)
	if attackState[player].hyperArmor then
		emit(player, nodeName, "HyperArmorStart", { reason = "Start" })
	end

	-- Attack lifecycle start
	emit(player, nodeName, "AttackStart", {
		duration = cfg.duration,
	})

	-- Auto-clear after duration, if provided
	if cfg.duration and cfg.duration > 0 then
		local t
		t = task.delay(cfg.duration, function()
			-- only complete if still active and timer matches
			if attackState[player] and attackState[player].endTask == t then
				endAttackInternal(player, "Completed", "Duration")
			end
		end)
		attackState[player].endTask = t
	end
end

-- Attempts to interrupt the playerâ€™s current attack.
-- Returns true if an interruption occurred.
function AttackStateService.Interrupt(player, reason)
	local st = attackState[player]
	if not st then return false end
	if st.hyperArmor then return false end  -- cannot interrupt

	st.interrupted = true
	emit(player, st.nodeName, "Interrupted", { reason = reason or "Interrupt" })
	endAttackInternal(player, "Interrupted", reason or "Interrupt")
	return true
end

function AttackStateService.HasHyperArmor(player)
	local st = attackState[player]
	return st and st.hyperArmor == true
end

function AttackStateService.IsInterrupted(player)
	local st = attackState[player]
	return st and st.interrupted == true
end

-- âœ… NEW: returns true while an attack is currently active/alive
function AttackStateService.IsActive(player)
	return attackState[player] ~= nil
end

function AttackStateService.Clear(player, reason)
	if not attackState[player] then return end
	endAttackInternal(player, "Canceled", reason or "Clear")
end

------------------------------ LIFECYCLE CLEANUP
Players.PlayerRemoving:Connect(function(plr)
	if attackState[plr] then
		endAttackInternal(plr, "Canceled", "PlayerRemoving")
	end
end)

return AttackStateService


===== FILE: src/shared/CardinalFacts.lua =====
-- Canonical telemetry facts for the cardinal moves.
-- Used by NodeFactory stubs (intent) and can also be used by NodeLibrary.
local Facts = {}

Facts.Punch = {
	Name         = "Punch",
	-- Balance: your current M1s
	Damage       = 3.3,
	GuardDamage  = 0,
	Chip         = 0,
	Stun         = 0.20,    -- micro stagger on clean hit (AI weight only)
	Blockable    = true,
	Parryable    = false,
	Melee        = true,
	M1           = true,
	Radius       = 5,
}

Facts.Heavy = {
	Name         = "Heavy",
	Damage       = 7.0,
	GuardDamage  = 30,
	Chip         = 2.0,
	Stun         = 0.40,    -- mild stagger on hit (AI weight only)
	Blockable    = false,
	Parryable    = true,
	Melee        = true,
	Heavy        = true,
	Radius       = 7,
	KnockbackForce = 90,
	KnockbackDur   = 0.35,
}

Facts.Block = { Name = "Block" }
Facts.Dodge = { Name = "Dodge" }

return Facts


===== FILE: src/shared/CombatState.lua =====
-- CombatState (ref-counted, key-normalized)
-- Drop-in replacement to prevent permanent locks from mixed Player/Model usage.

local CombatState = {}

local Players = game:GetService("Players")

-- ========== internal state ==========
local lockCount     = setmetatable({}, { __mode = "k" }) -- [key] = int
local activeTracks  = setmetatable({}, { __mode = "k" }) -- [key] = AnimationTrack
local unlockBuffer  = setmetatable({}, { __mode = "k" }) -- [key] = tick()
local lastEvent     = setmetatable({}, { __mode = "k" }) -- [key] = { kind, reason, when, caller }

-- ---------- key normalization ----------
local function asModel(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model") then return ent end
	return ent:FindFirstAncestorOfClass("Model")
end

local function normKey(entity)
	if typeof(entity) ~= "Instance" then return entity end
	if entity:IsA("Player") then return entity end
	if entity:IsA("Model") then
		return Players:GetPlayerFromCharacter(entity) or entity
	end
	local mdl = asModel(entity)
	return (mdl and (Players:GetPlayerFromCharacter(mdl) or mdl)) or entity
end

local function mark(key, kind, reason)
	lastEvent[key] = {
		kind   = kind,                            -- "lock" | "unlock" | "unlock(force)"
		reason = reason or "unspecified",
		when   = os.clock(),
		caller = debug.info(3, "s") or "unknown",
		count  = lockCount[key] or 0,
	}
end

-- ========== public API ==========

function CombatState.Lock(entity, reason)
	local key = normKey(entity); if not key then return end
	lockCount[key] = (lockCount[key] or 0) + 1
	mark(key, "lock", reason)
end

function CombatState.Unlock(entity, reason)
	local key = normKey(entity); if not key then return end
	local n = (lockCount[key] or 0) - 1
	if n <= 0 then
		lockCount[key] = nil
	else
		lockCount[key] = n
	end
	mark(key, "unlock", reason)
end

function CombatState.ForceUnlock(entity, reason)
	local key = normKey(entity); if not key then return end
	lockCount[key] = nil
	mark(key, "unlock(force)", reason or "manual")
end

function CombatState.IsLocked(entity)
	local key = normKey(entity); if not key then return false end
	return (lockCount[key] or 0) > 0
end

-- Optional: short grace period after unlock (unchanged semantics)
function CombatState.SetUnlockBuffer(entity, duration)
	local key = normKey(entity); if not key then return end
	unlockBuffer[key] = tick() + (duration or 0)
end

function CombatState.RecentlyUnlocked(entity)
	local key = normKey(entity); if not key then return false end
	return (unlockBuffer[key] or 0) > tick()
end

-- Animation helpers (key-normalized)
function CombatState.RegisterTrack(entity, track)
	local key = normKey(entity); if not key then return end
	if activeTracks[key] then
		pcall(function() activeTracks[key]:Stop() end)
	end
	activeTracks[key] = track
end

function CombatState.StopCurrentTrack(entity)
	local key = normKey(entity); if not key then return end
	if activeTracks[key] then
		pcall(function() activeTracks[key]:Stop() end)
		activeTracks[key] = nil
	end
end

-- Cleanup for a given entity/key
function CombatState.Cleanup(entity)
	local key = normKey(entity); if not key then return end
	lockCount[key]    = nil
	activeTracks[key] = nil
	unlockBuffer[key] = nil
	lastEvent[key]    = nil
end

-- Debug helpers
function CombatState.GetLockInfo(entity)
	local key = normKey(entity); if not key then return nil end
	return {
		count  = lockCount[key] or 0,
		last   = lastEvent[key],
		hasTrack = activeTracks[key] ~= nil,
	}
end

function CombatState.DebugPrint(entity, label)
	local info = CombatState.GetLockInfo(entity)
	print(("[CombatState] %s  count=%s  hasTrack=%s  last=%s/%s @%.2f from %s")
		:format(
			label or tostring(entity),
			info and info.count or 0,
			info and tostring(info.hasTrack) or "false",
			info and info.last and info.last.kind or "nil",
			info and info.last and tostring(info.last.reason) or "nil",
			info and info.last and info.last.when or 0,
			info and info.last and tostring(info.last.caller) or "?"
		)
	)
end

return CombatState


===== FILE: src/shared/ComboService.lua =====
local ComboService = {}

---------------------------------------------------------------------
-- ComboService
-- Tracks consecutive light-attack hits and triggers a finisher.
-- Works for both Players and NPC Models.
---------------------------------------------------------------------

------------------------------ SERVICES
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DamageService     = require(ReplicatedStorage:WaitForChild("DamageService"))
local KnockbackService  = require(ReplicatedStorage:WaitForChild("KnockbackService"))
local StunService       = require(ReplicatedStorage:WaitForChild("StunService"))
local CooldownService   = require(ReplicatedStorage:WaitForChild("CooldownService"))

------------------------------ REMOTES (optional FX / UI hooks)
local RemoteEvents      = ReplicatedStorage:WaitForChild("RemoteEvents")
local ComboBurst        = RemoteEvents:FindFirstChild("ComboBurst") -- may be nil

------------------------------ TUNING
local COMBO_RESET        = 3.0   -- seconds before combo times out
local HIT_MAX            = 5     -- # of M1 hits before finisher
local FINISHER_RADIUS    = 7     -- damage radius
local KB_RADIUS          = 6     -- knockback/stagger radius

-- New: brief recovery after a finisher (locks common actions)
local FINISHER_RECOVERY_SEC = 1.0
local FINISHER_LOCK_MOVES   = { "Punch", "Heavy", "Dodge", "BlockStart" }

-- Legacy: specific punch cooldown (kept; harmless if duplicated with recovery)
local FINISHER_PUNCH_CD  = 3.0

local FINISHER_DMG       = { guard = 0, hp = 6.6, chip = 0, nodeName = "ComboFinisher" }
local KB_FORCE           = 90
local KB_DUR             = 0.25
local FINISHER_STUN      = 0.3   -- mild stagger after burst

------------------------------ STATE
local comboCount  = {}    -- [attacker(Player|Model)] = hits
local lastHitTime = {}    -- [attacker] = tick()

------------------------------ HELPERS
local function asModel(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model") then return ent end
	return nil
end

local function rootOf(ent)
	local mdl = asModel(ent)
	return mdl and mdl:FindFirstChild("HumanoidRootPart") or nil
end

local function isPlayer(ent)
	return typeof(ent) == "Instance" and ent:IsA("Player")
end

local function iterTargetsAround(origin, radius)
	local oModel = asModel(origin)
	local oRoot  = rootOf(origin)
	if not oModel or not oRoot then return {} end

	local found = {}
	local seen  = {}  -- dedupe by model instance

	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("Humanoid") then
			local mdl = inst.Parent
			if mdl and mdl:IsA("Model") and mdl ~= oModel then
				local hrp = mdl:FindFirstChild("HumanoidRootPart")
				if hrp and (hrp.Position - oRoot.Position).Magnitude <= radius then
					if not seen[mdl] then
						seen[mdl] = true
						local plr = Players:GetPlayerFromCharacter(mdl)
						table.insert(found, plr or mdl)
					end
				end
			end
		end
	end

	return found
end

------------------------------ API
function ComboService.RegisterHit(attacker)
	local now = tick()

	if (lastHitTime[attacker] or 0) + COMBO_RESET < now then
		comboCount[attacker] = 0
	end

	comboCount[attacker] = (comboCount[attacker] or 0) + 1
	lastHitTime[attacker] = now

	if comboCount[attacker] >= HIT_MAX then
		ComboService.Finish(attacker)
	end
end

function ComboService.Finish(attacker)
	comboCount[attacker]  = 0
	lastHitTime[attacker] = tick()

	local oModel = asModel(attacker)
	local oRoot  = rootOf(attacker)
	if not oModel or not oRoot then return end

	-- Brief recovery: lock common actions for 1s (players & NPCs)
	for _, key in ipairs(FINISHER_LOCK_MOVES) do
		pcall(CooldownService.Apply, attacker, key, FINISHER_RECOVERY_SEC)
	end

	-- Keep specific punch cooldown (no harm if redundant)
	if isPlayer(attacker) then
		CooldownService.Apply(attacker, "Punch", FINISHER_PUNCH_CD)
	end

	-- Finisher damage (respects Guard/Parry/I-frames/Hyper-Armor)
	for _, tgt in ipairs(iterTargetsAround(attacker, FINISHER_RADIUS)) do
		DamageService.DealDamage(tgt, FINISHER_DMG, attacker)
	end

	-- Knockback + brief stagger
	for _, tgt in ipairs(iterTargetsAround(attacker, KB_RADIUS)) do
		local tRoot = rootOf(tgt)
		if tRoot then
			local dir = (tRoot.Position - oRoot.Position)
			KnockbackService.Apply(tgt, dir, KB_FORCE, KB_DUR)
			StunService.Apply(tgt, FINISHER_STUN)
		end
	end

	-- Optional FX
	if ComboBurst then
		local plr = isPlayer(attacker) and attacker or nil
		if plr then
			ComboBurst:FireAllClients(plr)
		else
			ComboBurst:FireAllClients()
		end
	end
end

function ComboService.GetCount(attacker)
	return comboCount[attacker] or 0
end

function ComboService.Reset(attacker)
	comboCount[attacker]  = 0
	lastHitTime[attacker] = nil
end

return ComboService


===== FILE: src/shared/CooldownService.lua =====
local CooldownService = {}

local cooldowns = {}

-- Checks if the player can use a specific action
function CooldownService.CanUse(player, action)
	if not player then return false end
	local playerCooldowns = cooldowns[player]
	if not playerCooldowns then return true end

	local timestamp = playerCooldowns[action]
	return not timestamp or tick() >= timestamp
end

-- Sets a cooldown for a specific action
function CooldownService.Apply(player, action, duration)
	if not player then return end
	cooldowns[player] = cooldowns[player] or {}
	cooldowns[player][action] = tick() + duration
end

-- Optionally reset cooldowns for a player (e.g., on death or reset)
function CooldownService.Clear(player)
	cooldowns[player] = nil
end

-- Optional debug readout
function CooldownService.GetRemaining(player, action)
	local ts = cooldowns[player] and cooldowns[player][action]
	if ts then
		return math.max(0, ts - tick())
	end
	return 0
end

return CooldownService


===== FILE: src/shared/DamageService.lua =====
-- DamageService.lua  (robust, block-aware, interrupt-aware, NodeSense telemetry)
-- Honors blocking for any blockable move (even when guard=0), parry,
-- I-frames, hyper-armor, and will INTERRUPT the defender's current attack
-- on successful HP damage (unless they have hyper-armor).
-- Optional: dmg.stun / dmg.hitstun / dmg.stagger (seconds) to apply StunService.

local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")

local CombatState        = require(RS:WaitForChild("CombatState"))
local GuardService       = require(RS:WaitForChild("GuardService"))
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local ParryService       = require(RS:WaitForChild("ParryService"))
local NodeSense          = require(RS:WaitForChild("NodeSense"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local StunService        = require(RS:WaitForChild("StunService"))

local DamageService = {}

---------------------------------------------------------------------
-- DEBUG
---------------------------------------------------------------------
local DEBUG = false
local function dprint(...) if DEBUG then print("[DamageService]", ...) end end
local function dwarn(...)  if DEBUG then warn("[DamageService]", ...) end end

---------------------------------------------------------------------
-- UTIL
---------------------------------------------------------------------
local function asCharacter(entity)
	if not entity then return nil end
	if typeof(entity) == "Instance" then
		if entity:IsA("Player") then return entity.Character end
		if entity:IsA("Model") and entity:FindFirstChildOfClass("Humanoid") then return entity end
	elseif typeof(entity) == "table" and typeof(entity.Character) == "Instance" then
		return entity.Character
	end
	return nil
end

local function getHumanoid(target)
	if not target then return nil end
	if target:IsA("Player") then
		return target.Character and target.Character:FindFirstChildOfClass("Humanoid")
	elseif target:IsA("Model") then
		return target:FindFirstChildOfClass("Humanoid")
	end
end

local function getRoot(target)
	if not target then return nil end
	if target:IsA("Player") then
		return target.Character and target.Character:FindFirstChild("HumanoidRootPart")
	elseif target:IsA("Model") then
		return target:FindFirstChild("HumanoidRootPart")
	end
end

local function getUserId(entity)
	if not entity or typeof(entity) ~= "Instance" then return nil end
	if entity:IsA("Player") then return entity.UserId end
	if entity:IsA("Model") then
		local plr = Players:GetPlayerFromCharacter(entity)
		return plr and plr.UserId or nil
	end
	return nil
end

-- Accept a number or any table shape and normalize keys.
local function coerceDamageTable(dmg)
	if dmg == nil then return nil end
	-- number â†’ hp
	if typeof(dmg) == "number" then
		return { hp = dmg, guard = 0, chip = 0, parryable = true, blockable = true, nodeName = "Unknown" }
	end
	if typeof(dmg) ~= "table" then
		dwarn("Bad dmg type:", typeof(dmg))
		return nil
	end

	-- accept many synonyms
	local hp    = dmg.hp or dmg.HP or dmg.health or dmg.Health or dmg.damage or dmg.Damage
	local guard = dmg.guard or dmg.Guard or dmg.guardDamage or dmg.GuardDamage
	local chip  = dmg.chip or dmg.Chip or dmg.chipDamage or dmg.ChipDamage
	local stun  = dmg.stun or dmg.hitstun or dmg.stagger or dmg.Stun or dmg.Hitstun or dmg.Stagger

	-- defaults
	hp    = tonumber(hp)    or 0
	guard = tonumber(guard) or 0
	chip  = tonumber(chip)  or 0
	stun  = tonumber(stun)  or 0

	-- parryable defaults to true unless explicitly false anywhere
	local p1 = dmg.parryable; local p2 = dmg.Parryable; local p3 = dmg.isParryable
	local parryable = not (p1 == false or p2 == false or p3 == false)

	-- blockable defaults to true unless explicitly false or "unblockable" is set
	local blockable = true
	if dmg.blockable == false or dmg.Blockable == false or dmg.unblockable == true or dmg.Unblockable == true then
		blockable = false
	end

	-- optional node name for telemetry
	local nodeName = dmg.nodeName or dmg.NodeName or dmg.name or dmg.Name or "Unknown"

	return {
		hp = hp, guard = guard, chip = chip, stun = stun,
		parryable = parryable,
		blockable = blockable,
		nodeName  = tostring(nodeName),
	}
end

---------------------------------------------------------------------
-- CORE
---------------------------------------------------------------------
local function dealDamageCore(defender, dmg, attacker)
	if not defender or not dmg then return end

	local nodeName   = dmg.nodeName or "Unknown"
	local defUserId  = getUserId(defender)

	-- hard blocks (emit Miss for telemetry/AI debug)
	if defender:GetAttribute("Invincible") then
		dprint("Ignored: Invincible:", defender.Name)
		NodeSense.EmitOutcome(attacker, nodeName, "Miss", { targetId = defUserId, reason = "Invincible" })
		return
	end
	if defender:IsA("Player") and IFrameStore.IsActive(defender) then
		dprint("Ignored: I-Frames active:", defender.Name)
		NodeSense.EmitOutcome(attacker, nodeName, "Miss", { targetId = defUserId, reason = "IFrame" })
		return
	end

	-- Parry check (only if parryable)
	if dmg.parryable and ParryService and type(ParryService.Try) == "function" then
		local ok, parried = pcall(ParryService.Try, attacker, defender)
		if ok and parried then
			dprint("Parried by", defender.Name, "against", nodeName)
			-- Interrupt the attacker if they don't have hyper-armor
			AttackStateService.Interrupt(attacker, "Parried")
			NodeSense.EmitOutcome(attacker, nodeName, "Parried", { targetId = defUserId })
			return
		end
	end

	-- Guard interaction (block cancels HP for blockable moves, even if guard=0)
	if dmg.blockable ~= false and GuardService.IsBlocking(defender) then
		local gd = tonumber(dmg.guard) or 0
		local state = GuardService.ApplyGuardDamage(attacker, defender, gd, nodeName)
		if state == "blocked" then
			-- fully blocked: no HP; note that *chip* is only applied on guard break below
			dprint("Blocked (no HP):", defender.Name)
			return
		elseif state == "break" then
			-- guard broke: fold chip into HP
			if dmg.chip and dmg.chip > 0 then
				dprint("Guard break â†’ add chip:", dmg.chip, "â†’ HP", (dmg.hp or 0) + dmg.chip)
				dmg.hp = (dmg.hp or 0) + dmg.chip
			end
			-- GuardService already emitted "GuardBroken"
		end
	end

	-- HP application â†’ Hit outcome
	if dmg.hp and dmg.hp > 0 then
		local hum = getHumanoid(defender)
		if hum then
			hum:TakeDamage(dmg.hp)
			dprint(("HP -%s â†’ %s"):format(tostring(dmg.hp), hum.Parent and hum.Parent.Name or "Humanoid"))
			NodeSense.EmitOutcome(attacker, nodeName, "Hit", {
				targetId = defUserId,
				damage   = dmg.hp,
			})

			-- Interrupt defender's attack on hit (unless hyper-armor)
			AttackStateService.Interrupt(defender, "Hit")

			-- Optional hit-stun from the damage table (nodes may also call StunService directly)
			if dmg.stun and dmg.stun > 0 then
				StunService.Apply(defender, dmg.stun)
			end
		else
			dwarn("No Humanoid on target", defender.Name)
		end
	end
end

-- Public entry â€” canonical path
function DamageService.DealDamage(target, dmgIn, source)
	local norm = coerceDamageTable(dmgIn)
	dprint("â–¶ DealDamage", tostring(target and target.Name), norm and ("hp="..norm.hp.." guard="..norm.guard) or "<nil>")
	if not norm then return end
	dealDamageCore(target, norm, source)
end

-- Back-compat entry that some nodes may still call
function DamageService.Apply(target, dmgIn, source)
	local norm = coerceDamageTable(dmgIn)
	dprint("â–¶ Apply", tostring(target and target.Name), norm and ("hp="..norm.hp.." guard="..norm.guard) or "<nil>")
	if not norm then return end
	dealDamageCore(target, norm, source)
end

---------------------------------------------------------------------
-- BLOCK WRAPPERS
---------------------------------------------------------------------
function DamageService.StartBlock(p) GuardService.StartBlock(p) end
function DamageService.EndBlock(p)   GuardService.EndBlock(p)   end
function DamageService.BreakBlock(p) GuardService.Break(p)      end

---------------------------------------------------------------------
-- I-FRAMES
---------------------------------------------------------------------
function DamageService.IsIFraming(player) return IFrameStore.IsActive(player) end
function DamageService.GrantIFrames(player, duration) IFrameStore.Grant(player, duration) end

---------------------------------------------------------------------
-- AoE HELPERS
---------------------------------------------------------------------
function DamageService.AreaHit(origin, radius, damage, source)
	local oChar = asCharacter(origin); if not oChar then return {} end
	local oRoot = getRoot(oChar); if not oRoot then return {} end
	local hits = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		if typeof(origin) == "Instance" and origin:IsA("Player") and plr == origin then continue end
		local tChar = plr.Character
		local tRoot = getRoot(tChar)
		if tChar and tRoot and (tRoot.Position - oRoot.Position).Magnitude <= radius then
			DamageService.DealDamage(plr, damage, source or origin)
			table.insert(hits, plr)
		end
	end
	return hits
end

function DamageService.AreaHitCharacter(originChar, radius, damage, source)
	if not originChar then return {} end
	local oRoot = getRoot(originChar); if not oRoot then return {} end
	local hits = {}
	for _, mdl in ipairs(workspace:GetDescendants()) do
		if mdl:IsA("Model") and mdl ~= originChar and getHumanoid(mdl) then
			local tRoot = getRoot(mdl)
			if tRoot and (tRoot.Position - oRoot.Position).Magnitude <= radius then
				local asPlayer = Players:GetPlayerFromCharacter(mdl)
				DamageService.DealDamage(asPlayer or mdl, damage, source or originChar)
				table.insert(hits, asPlayer or mdl)
			end
		end
	end
	return hits
end

---------------------------------------------------------------------
-- TOUCH = HIT helper (one-shot)
---------------------------------------------------------------------
function DamageService.TouchHit(part, damageTable, source)
	if not part or not part:IsA("BasePart") then return end
	local fired = false
	part.Touched:Connect(function(other)
		if fired then return end
		local targetChar = other:FindFirstAncestorWhichIsA("Model")
		if not targetChar then return end
		local targetPlr  = Players:GetPlayerFromCharacter(targetChar)
		if source and targetPlr and targetPlr == source then return end -- don't self-hit
		fired = true
		DamageService.DealDamage(targetPlr or targetChar, damageTable, source)
		part:Destroy()
	end)
end

---------------------------------------------------------------------
-- Simple ray helper (optional)
---------------------------------------------------------------------
function DamageService.RayHit(attackerChar, lookVec, length, dmgTable, source)
	local root = attackerChar and attackerChar:FindFirstChild("HumanoidRootPart")
	if not root then return {} end
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = { attackerChar }
	rayParams.FilterType = Enum.RaycastFilterType.Exclude
	rayParams.RespectCanCollide = true

	local result = workspace:Raycast(root.Position, lookVec.Unit * length, rayParams)
	local hits = {}
	if result and result.Instance then
		local hitChar = result.Instance:FindFirstAncestorOfClass("Model")
		if hitChar and hitChar ~= attackerChar then
			table.insert(hits, hitChar)
			DamageService.DealDamage(hitChar, dmgTable, source or attackerChar)
		end
	end
	return hits
end

return DamageService


===== FILE: src/shared/DodgeChargeService.lua =====
-- ReplicatedStorage/DodgeChargeService.lua
local DodgeChargeService = {}

local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")
local DodgeEvt= RS:WaitForChild("RemoteEvents"):WaitForChild("DodgeCharges")

local MAX_CHARGES       = 3
local RECHARGE_INTERVAL = 7.5

local charges   = {}
local regenTask = {}

local function push(player)
	-- send (current, max) to that player
	DodgeEvt:FireClient(player, charges[player] or 0, MAX_CHARGES)
end

local function stopTask(player)
	if regenTask[player] then
		pcall(task.cancel, regenTask[player])
		regenTask[player] = nil
	end
end

local function startRegenLoop(player)
	if regenTask[player] then return end
	regenTask[player] = task.spawn(function()
		while player.Parent do
			if (charges[player] or 0) >= MAX_CHARGES then
				stopTask(player)
				break
			end
			task.wait(RECHARGE_INTERVAL)
			if (charges[player] or 0) < MAX_CHARGES then
				charges[player] = charges[player] + 1
				push(player) -- ðŸ”µ notify client on +1
			end
		end
	end)
end

function DodgeChargeService.Get(player)
	return charges[player] or MAX_CHARGES
end

function DodgeChargeService.CanDodge(player)
	return (charges[player] or 0) > 0
end

function DodgeChargeService.Consume(player)
	if DodgeChargeService.CanDodge(player) then
		charges[player] = charges[player] - 1
		push(player)          -- ðŸ”µ notify client on spend
		startRegenLoop(player)
		return true
	end
	return false
end

function DodgeChargeService.Reset(player)
	stopTask(player)
	charges[player] = MAX_CHARGES
	push(player)              -- ðŸ”µ notify client on reset / spawn
end

Players.PlayerAdded:Connect(function(plr)
	DodgeChargeService.Reset(plr)  -- fires initial push
	-- If you also want full on death, uncomment:
	-- plr.CharacterAdded:Connect(function() DodgeChargeService.Reset(plr) end)
end)

Players.PlayerRemoving:Connect(function(plr)
	stopTask(plr)
	charges[plr]   = nil
	regenTask[plr] = nil
end)

return DodgeChargeService


===== FILE: src/shared/EnemyLooks.lua =====
-- ReplicatedStorage/EnemyLooks.lua
return {
	Hotpants_Start = {
		{
			assets = {
				shirt = 6075850504,
				pants = 6806968785,
				hair  = {13397220399},
				hats  = {85721183097737},
			}
		}
	},


	Horse_Keeper = {
		{
			assets = {
				shirt = 8168521914,
				pants = 17468619384,
				hats  = { 87049072653005 }, -- HatAccessory IDs go in a list
			}
		}
	},
	Johnny_Joestar_Start = {
		{
			assets = {
				shirt = 107753108912057,   -- Shirt ID
				pants = 5212296507,       -- Pants ID
				hats  = { 79620692802856 } -- HatAccessory IDs list
			}
		}
	},


}



===== FILE: src/shared/EnemySpecs.lua =====
-- ReplicatedStorage/EnemySpecs.lua
-- enemyId â†’ spec: which brain, look, defaults, difficulty (DEF/OFF), etc.
return {
	-- Worst-tier tutorial enemy (dopey)
	Rounder_Tutorial = {
		enemyType   = "Rounder",
		
		leashRadius = 30,
		aiProfile   = "RounderV1",
		stats       = { WalkSpeed = 14, JumpPower = 40 },
		DEF         = 100,   -- near-worst defense/reactivity
		OFF         = 1,   -- near-worst aggression/pressure
	},

}


===== FILE: src/shared/GuardService.lua =====
-- GuardService  (ReplicatedStorage)
-- Guard meter with block/regen/break + NodeSense outcome emits.
-- Compatible with DamageService.Apply/DealDamage and AttackStateService.
-- Extras: sets debug attributes "Blocking" (bool) and "Guard" (0..MAX)

-------------------------------------------------- CONFIG
local MAX_GUARD      = 50
local REGEN_PER_SEC  = 5
local BREAK_STUN     = 2.5

-------------------------------------------------- SERVICES
local Players        = game:GetService("Players")
local RS             = game:GetService("ReplicatedStorage")

local CombatState    = require(RS:WaitForChild("CombatState"))
local StunService    = require(RS:WaitForChild("StunService"))
local SpeedController= require(RS:WaitForChild("SpeedController"))
local NodeSense      = require(RS:WaitForChild("NodeSense"))

-------------------------------------------------- STATE
local GuardService   = {}
local guardHP        = {}   -- [entity(Player|Model)] = current guard
local isBlocking     = {}   -- [entity] = true while holding block

-------------------------------------------------- HELPERS
local function getHumanoid(entity)
	if typeof(entity) ~= "Instance" then return nil end
	if entity:IsA("Player") then
		local c = entity.Character
		return c and c:FindFirstChildOfClass("Humanoid")
	elseif entity:IsA("Model") then
		return entity:FindFirstChildOfClass("Humanoid")
	end
end

local function getPlayerFromEntity(entity)
	if typeof(entity) ~= "Instance" then return nil end
	if entity:IsA("Player") then return entity end
	if entity:IsA("Model") then
		return Players:GetPlayerFromCharacter(entity)
	end
	return nil
end

local function getUserId(entity)
	local plr = getPlayerFromEntity(entity)
	return plr and plr.UserId or nil
end

local function ensureInit(ent)
	if guardHP[ent] == nil then guardHP[ent] = MAX_GUARD end
end

local function setAttrs(ent)
	-- purely debug/UX; harmless if unused
	local hp = guardHP[ent]
	if typeof(ent) == "Instance" and ent.Parent then
		pcall(function()
			ent:SetAttribute("Blocking", isBlocking[ent] == true)
			if hp ~= nil then
				ent:SetAttribute("Guard", math.clamp(hp, 0, MAX_GUARD))
			end
		end)
	end
end

-------------------------------------------------- API
function GuardService.StartBlock(entity)
	if not entity then return end
	ensureInit(entity)
	isBlocking[entity] = true
	setAttrs(entity)

	-- Optional: broadcast block state for AI blackboards
	NodeSense.EmitOutcome(entity, "Block", "BlockStart", {
		targetId = getUserId(entity),
	})
end

function GuardService.EndBlock(entity)
	if not entity then return end
	isBlocking[entity] = nil
	setAttrs(entity)

	NodeSense.EmitOutcome(entity, "Block", "BlockEnd", {
		targetId = getUserId(entity),
	})
end

function GuardService.GetPercent(entity)
	return (guardHP[entity] or MAX_GUARD) / MAX_GUARD
end

-- Preferred signature:
--   ApplyGuardDamage(attacker, defender, rawDamage, nodeName)
-- Legacy signature (still supported):
--   ApplyGuardDamage(defender, rawDamage [, nodeName])
-- Returns: nil | "blocked" | "break"
function GuardService.ApplyGuardDamage(a, b, c, d)
	local attacker, defender, rawDamage, nodeName

	-- Detect signature based on argument types
	if typeof(a) == "Instance" and typeof(b) == "Instance" and type(c) == "number" then
		-- New signature
		attacker  = a
		defender  = b
		rawDamage = c
		nodeName  = (type(d) == "string") and d or nil
	else
		-- Legacy
		attacker  = nil
		defender  = a
		rawDamage = b
		nodeName  = (type(c) == "string") and c or nil
	end

	if not defender or type(rawDamage) ~= "number" then return nil end
	if not isBlocking[defender] then return nil end

	ensureInit(defender)

	-- Drain guard (rawDamage may be 0; that's fine â€” still "Blocked")
	guardHP[defender] = (guardHP[defender] or MAX_GUARD) - rawDamage
	setAttrs(defender)

	local defUserId = getUserId(defender)
	local nn = nodeName or "Unknown"

	if guardHP[defender] > 0 then
		-- Blocked but not broken
		NodeSense.EmitOutcome(attacker, nn, "Blocked", {
			targetId    = defUserId,
			guardDamage = rawDamage,
		})
		return "blocked"
	else
		-- Broke guard
		GuardService.Break(defender)

		NodeSense.EmitOutcome(attacker, nn, "GuardBroken", {
			targetId    = defUserId,
			guardDamage = rawDamage,
		})
		return "break"
	end
end

function GuardService.Break(entity)
	if not entity then return end
	ensureInit(entity)

	isBlocking[entity] = nil
	guardHP[entity]    = 0
	setAttrs(entity)

	-- Reset any movement modifiers
	if entity:IsA("Player") then
		SpeedController.Reset(entity)
	end

	-- Stop looping block animation
	if entity:IsA("Player") then
		CombatState.StopCurrentTrack(entity)   -- drops hold pose
	else
		local hum = getHumanoid(entity)
		if hum then
			for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
				local anim = track.Animation
				if anim and anim.AnimationId == "rbxassetid://72122053405063" then -- HOLD anim ID
					track:Stop()
				end
			end
		end
	end

	-- Apply stun on break
	StunService.Apply(entity, BREAK_STUN)
end

-- Optional helpers for NPCs
function GuardService.RegisterEntity(model)
	if typeof(model) == "Instance" then
		guardHP[model] = MAX_GUARD
		isBlocking[model] = nil
		setAttrs(model)
	end
end

function GuardService.UnregisterEntity(model)
	guardHP[model]   = nil
	isBlocking[model]= nil
	if typeof(model) == "Instance" then
		pcall(function()
			model:SetAttribute("Blocking", nil)
			model:SetAttribute("Guard", nil)
		end)
	end
end

-------------------------------------------------- REGEN LOOP
task.spawn(function()
	while true do
		task.wait(1)
		for ent, hp in pairs(guardHP) do
			if typeof(ent) == "Instance" and ent.Parent == nil then
				-- Clean up dead references
				guardHP[ent]    = nil
				isBlocking[ent] = nil
			elseif not isBlocking[ent] and hp < MAX_GUARD then
				guardHP[ent] = math.min(MAX_GUARD, hp + REGEN_PER_SEC)
				setAttrs(ent)
			end
		end
	end
end)

-------------------------------------------------- LIFECYCLE
local function resetGuard(ent)
	guardHP[ent]    = MAX_GUARD
	isBlocking[ent] = nil
	setAttrs(ent)
end

Players.PlayerAdded:Connect(function(plr)
	resetGuard(plr)
	plr.CharacterAdded:Connect(function() resetGuard(plr) end)
end)

Players.PlayerRemoving:Connect(function(plr)
	guardHP[plr]    = nil
	isBlocking[plr]  = nil
end)

-------------------------------------------------- QUERIES
function GuardService.IsBlocking(entity)
	return isBlocking[entity] == true
end

function GuardService.IsGuardBroken(entity)
	return (guardHP[entity] or MAX_GUARD) <= 0
end

return GuardService


===== FILE: src/shared/GunProp.lua =====
this is a model, not a module

===== FILE: src/shared/HitboxService.lua =====
--------------------------------------------------------------------
-- HitboxService (v1.7) â€” contact-only, outcome via DamageService
-- - Legacy path: you can still pass a `callback(mdl)` â†’ unchanged
-- - New path: pass opts.damage / opts.attacker and it will call
--             DamageService.DealDamage(defender, opts.damage, opts.attacker)
-- - Optional: opts.intent=true â†’ one-time NodeSense "intent" emit at spawn
--------------------------------------------------------------------
local HitboxService = {}

local Debris   = game:GetService("Debris")
local Players  = game:GetService("Players")
local RS       = game:GetService("ReplicatedStorage")

local DamageService = require(RS:WaitForChild("DamageService"))
local NodeSense     = require(RS:WaitForChild("NodeSense"))

-- Utility: return Model with living Humanoid
local function getLivingCharacter(inst)
	local mdl = inst:FindFirstAncestorOfClass("Model")
	if not mdl then return nil end
	local hum = mdl:FindFirstChildOfClass("Humanoid")
	if hum and hum.Health > 0 then
		return mdl
	end
end

-- Defender entity: prefer Player if one owns the model
local function toDefenderEntity(mdl)
	local plr = Players:GetPlayerFromCharacter(mdl)
	return plr or mdl
end

-- Spawn invisible anchored sphere
local function makeSphere(radius, cf)
	local p = Instance.new("Part")
	p.Shape        = Enum.PartType.Ball
	p.Size         = Vector3.new(1,1,1) * (radius*2)
	p.Transparency = 1
	p.CanCollide   = false
	p.Anchored     = true
	p.CFrame       = cf
	p.Name         = "HitboxSphere"
	p.Parent       = workspace
	return p
end

-- Internal create function
local function _create(getCF, radius, lifetime, ignoreList, oneShot, callback, opts)
	lifetime   = lifetime   or 0.2
	oneShot    = (oneShot    ~= false)
	ignoreList = ignoreList or {}
	opts       = opts       or {}

	-- ignore any descendants of these instances
	local function isIgnored(inst)
		for _,ign in ipairs(ignoreList) do
			if inst == ign or inst:IsDescendantOf(ign) then
				return true
			end
		end
		return false
	end

	local destroyOnHit = opts.destroyOnHit
	if destroyOnHit == nil then destroyOnHit = oneShot end

	local linkedParts  = opts.linkedParts or {}

	-- Optional: one-time "intent" telemetry on arm
	if opts.intent == true then
		local nodeName = opts.nodeName
			or (typeof(opts.damage)=="table" and (opts.damage.nodeName or opts.damage.NodeName))
			or "Hitbox"
		local tags = nil
		if typeof(NodeSense) == "table" and typeof(NodeSense.CollectTags) == "function" then
			local dmgTbl = (typeof(opts.damage)=="table") and opts.damage or {}
			tags = NodeSense.CollectTags(dmgTbl, opts.tagsOverride)
		end
		pcall(function()
			NodeSense.Emit(opts.attacker, nodeName, tags, { armed = true })
		end)
	end

	local sphere = makeSphere(radius, getCF())
	print("[HitboxService] ðŸ”µ spawned at", sphere.CFrame.Position)

	-- Optional per-target throttle for moving hitboxes
	local perTargetCooldown = tonumber(opts.hitCooldown)
	local recentHits = {} -- [Model] = expireTick

	local running = true
	local conn
	conn = sphere.Touched:Connect(function(other)
		if not running then return end

		if isIgnored(other) then
			print("[HitboxService]   âšª ignored collision with", other:GetFullName())
			return
		end

		local mdl = getLivingCharacter(other)
		if not mdl then
			print("[HitboxService]   âšª non-target hit with", other:GetFullName())
			return
		end

		-- Per-target throttle (optional)
		if perTargetCooldown and perTargetCooldown > 0 then
			local now = tick()
			if (recentHits[mdl] or 0) > now then
				-- still cooling down for this target
				return
			end
			recentHits[mdl] = now + perTargetCooldown
		end

		print("[HitboxService]   ðŸ”´ hit target:", mdl.Name)

		-- Legacy path: explicit callback takes priority
		if typeof(callback) == "function" then
			pcall(callback, mdl)
		else
			-- New sugar path: auto route to DamageService if damage is provided
			local dmg = opts.damage
			if dmg ~= nil then
				-- ensure nodeName present if provided separately
				if typeof(dmg) == "table" then
					if dmg.nodeName == nil and dmg.NodeName == nil and opts.nodeName then
						-- shallow clone to avoid mutating caller table
						local clone = {}
						for k,v in pairs(dmg) do clone[k]=v end
						clone.nodeName = opts.nodeName
						dmg = clone
					end
				end

				local defender = toDefenderEntity(mdl)
				pcall(function()
					DamageService.DealDamage(defender, dmg, opts.attacker)
				end)
			end
		end

		if destroyOnHit then
			running = false
			print("[HitboxService]   ðŸ—‘ destroyOnHit cleanup")
			conn:Disconnect()
			if sphere.Parent then sphere:Destroy() end
			for _,p in ipairs(linkedParts) do
				if p and p.Destroy then
					print("[HitboxService]     ðŸ—‘ linkedPart destroyed:", p.Name or p.ClassName)
					p:Destroy()
				end
			end
		end
	end)

	if opts.moving then
		task.spawn(function()
			local t0 = tick()
			while running and tick() - t0 < lifetime do
				sphere.CFrame = getCF()
				task.wait()
			end
			if running then
				running = false
				print("[HitboxService] â³ lifetime expired, cleanup")
				conn:Disconnect()
				if sphere.Parent then sphere:Destroy() end
			end
		end)
	else
		Debris:AddItem(sphere, lifetime)
	end
end

-- Stationary hitbox
function HitboxService.Create(originCF, radius, lifetime, ignoreList, oneShot, callback, opts)
	opts = opts or {}
	opts.moving = false
	_create(function() return originCF end,
		radius, lifetime, ignoreList, oneShot, callback, opts)
end

-- Moving hitbox
function HitboxService.CreateMoving(getCFrame, radius, lifetime, ignoreList, oneShot, callback, opts)
	opts = opts or {}
	opts.moving = true
	_create(getCFrame, radius, lifetime, ignoreList, oneShot, callback, opts)
end

return HitboxService


===== FILE: src/shared/IFrameStore.lua =====
---------------------------------------------------------------------
-- IFrameStore â€¢ authoritative registry for active i-frames
-- Emits NodeSense outcomes:
--   DodgeStart   (when i-frames begin)
--   DodgeRefresh (when an active window is extended/refreshed)
--   DodgeEnd     (when i-frames end naturally or via Clear)
---------------------------------------------------------------------
local IFrameStore = {}

local RS        = game:GetService("ReplicatedStorage")
local NodeSense = require(RS:WaitForChild("NodeSense"))

-- [player] = expiry tick()
local registry = {}

-- Optional: last start tick, helps with debugging/telemetry
local lastStart = {}  -- [player] = tick()

-- Internal: emit helper
local function emit(player, outcome, ctx)
	-- Player = actor; nodeName = "Dodge"
	-- NodeSense dedup protects against bursty repeats
	pcall(function()
		NodeSense.EmitOutcome(player, "Dodge", outcome, ctx or {})
	end)
end

-- Give player i-frames for `duration` seconds
-- If already active, this refreshes/extends the window and emits DodgeRefresh
function IFrameStore.Grant(player, duration, reason)
	if not player or type(duration) ~= "number" or duration <= 0 then return end

	local now      = tick()
	local prevExp  = registry[player] or 0
	local wasActive= prevExp > now

	local newExp   = now + duration
	registry[player] = newExp
	if not wasActive then
		lastStart[player] = now
		emit(player, "DodgeStart", { duration = duration, expiresAt = newExp, reason = reason or "Dodge" })
	else
		-- Active window extended/refreshed
		emit(player, "DodgeRefresh", {
			added     = duration,
			expiresAt = newExp,
			remaining = newExp - now,
			reason    = reason or "Dodge"
		})
	end

	-- Only the latest grant should end the window
	local thisExp = newExp
	task.delay(duration, function()
		-- If no newer grant occurred and time has passed, end it
		if registry[player] == thisExp and thisExp <= tick() then
			registry[player] = nil
			lastStart[player] = nil
			emit(player, "DodgeEnd", { reason = reason or "Dodge" })
		end
	end)
end

-- Query: is the player currently invulnerable?
function IFrameStore.IsActive(player)
	return (registry[player] or 0) > tick()
end

-- Optional: remaining seconds (0 if none)
function IFrameStore.GetRemaining(player)
	local rem = (registry[player] or 0) - tick()
	return rem > 0 and rem or 0
end

-- Optional: force-clear i-frames early (emits DodgeEnd once)
function IFrameStore.Clear(player, reason)
	local wasActive = IFrameStore.IsActive(player)
	registry[player] = nil
	lastStart[player] = nil
	if wasActive then
		emit(player, "DodgeEnd", { reason = reason or "Clear" })
		return true
	end
	return false
end

return IFrameStore


===== FILE: src/shared/KnockbackService.lua =====
-- KnockbackService  (ReplicatedStorage)
-- Applies physics impulses while respecting Guard, I-frames, and Hyper-Armor.

local KnockbackService = {}

------------------------------ DEPENDENCIES
local Players            = game:GetService("Players")
local RS                 = game:GetService("ReplicatedStorage")
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local GuardService       = require(RS:WaitForChild("GuardService"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))

------------------------------ TUNING
local POWER = 5          -- base multiplier (tune to taste)
local DEBUG = false
local function d(...) if DEBUG then print("[Knockback]", ...) end end

------------------------------ HELPERS
local function rootOf(ent)
	if typeof(ent) ~= "Instance" then return nil end
	if ent:IsA("Player") then
		local c = ent.Character
		return c and c:FindFirstChild("HumanoidRootPart")
	elseif ent:IsA("Model") then
		return ent:FindFirstChild("HumanoidRootPart")
	end
end

local function asEntity(x)
	if typeof(x) ~= "Instance" then return nil end
	if x:IsA("Player") or x:IsA("Model") then return x end
	return nil
end

------------------------------ CORE
-- @param target  Player | Model
-- @param dir     Vector3  â€” direction FROM attacker TO target
-- @param force   number   â€” base force (scaled by POWER & mass)
-- @param dur     number   â€” seconds before we zero linear velocity (default 0.3)
function KnockbackService.Apply(target, dir, force, dur)
	target = asEntity(target)
	if not target then return end
	if typeof(dir) ~= "Vector3" or dir.Magnitude == 0 then return end

	------------------------------------------------------------------
	--  Immunity Checks
	------------------------------------------------------------------
	-- Hard invincibility attribute (works for Players & Models)
	if target.GetAttribute and target:GetAttribute("Invincible") then
		return
	end

	-- Blocking negates knockback. (Guard-broken NO LONGER cancels knockback.)
	if GuardService and GuardService.IsBlocking and GuardService.IsBlocking(target) then
		d("IMMUNE: Blocking", target)
		return
	end

	-- I-frames (players only)
	if target:IsA("Player") and IFrameStore.IsActive(target) then
		return
	end

	-- Hyper-Armor (if your AttackStateService tracks it)
	if AttackStateService.HasHyperArmor and AttackStateService.HasHyperArmor(target) then
		d("IMMUNE: HyperArmor", target)
		return
	end

	------------------------------------------------------------------
	--  Physics Impulse
	------------------------------------------------------------------
	local root = rootOf(target)
	if not root then return end

	-- Ensure server controls physics for deterministic result
	local prevOwner = root:GetNetworkOwner()
	if prevOwner then root:SetNetworkOwner(nil) end
	if root.Anchored then root.Anchored = false end

	local impulse = dir.Unit * (force or 1) * POWER * root:GetMass()
	d("Impulse", impulse)
	root:ApplyImpulse(impulse)

	-- Optional slide stop + restore previous network owner
	local stopAfter = dur or 0.3
	if stopAfter > 0 then
		task.delay(stopAfter, function()
			if root and root.Parent then
				root.AssemblyLinearVelocity = Vector3.zero
				if prevOwner and prevOwner.Parent then
					pcall(function() root:SetNetworkOwner(prevOwner) end)
				end
			end
		end)
	end
end

return KnockbackService


===== FILE: src/shared/NodeFactory.lua =====
--------------------------------------------------------------------
-- NodeFactory â€¢ v8.3 (mount-safe)
-- + Execute(rootPart, extra) signature
-- + GetCFrame(extra) & LinkedParts(extra)
-- + Blocks node execution while player is Mounted (Humanoid attribute)
--   (per-node override: cfg.AllowWhileMounted = true)
--------------------------------------------------------------------
local RS       = game:GetService("ReplicatedStorage")
local Players  = game:GetService("Players")

-- dependencies
local HitboxService      = require(RS:WaitForChild("HitboxService"))
local CooldownService    = require(RS:WaitForChild("CooldownService"))
local SpeedController    = require(RS:WaitForChild("SpeedController"))
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local DamageService      = require(RS:WaitForChild("DamageService"))
local GuardService       = require(RS:WaitForChild("GuardService"))
local StunService        = require(RS:WaitForChild("StunService"))
local KnockbackService   = require(RS:WaitForChild("KnockbackService"))

local NodeFactory = {}

--------------------------------------------------------------------
-- Mount helpers (future-proof)
--------------------------------------------------------------------
local MOUNT_DEBUG = false

local function isMountedPlayer(player: Player?): boolean
	if not player then return false end
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

local function playerFromRoot(rootPart: BasePart?)
	if not rootPart then return nil, nil end
	local char = rootPart.Parent
	if not char then return nil, nil end
	return Players:GetPlayerFromCharacter(char), char
end

--------------------------------------------------------------------
-- Factory
--------------------------------------------------------------------
function NodeFactory.Create(cfg)
	assert(cfg and type(cfg) == "table", "NodeFactory: cfg table required")
	assert(cfg.Name, "NodeFactory: Name required")
	assert(cfg.Radius or cfg.UseMovingHitbox, "NodeFactory: Radius required")

	local node = {}
	for k, v in pairs(cfg) do node[k] = v end

	-- Optional per-node escape hatch:
	-- cfg.AllowWhileMounted = true  -- e.g., emotes you want to permit

	function node:Execute(rootPart, extra)
		if not rootPart or typeof(rootPart) ~= "Instance" then return end

		-- Resolve caller
		local player, char = playerFromRoot(rootPart)
		-- ðŸš§ Hard gate while mounted (unless explicitly allowed on this node)
		if player and (not self.AllowWhileMounted) and isMountedPlayer(player) then
			if MOUNT_DEBUG then
				print(("[NodeFactory] BLOCKED while mounted â–¶ %s  node=%s")
					:format(player.Name, tostring(self.Name or "?")))
			end
			return
		end

		-- Cooldown (only if configured; Revolver handles its own)
		if player and self.Cooldown and self.Cooldown > 0 then
			if not CooldownService.CanUse(player, self.Name) then return end
			CooldownService.Apply(player, self.Name, self.Cooldown)
		end

		-- Self-effects / attack state
		if player and self.Speed then
			SpeedController.Apply(player, self.Speed, self.SpeedDuration or 0.5)
		end
		AttackStateService.Start(char, {
			duration   = self.Lifetime or 0.2,
			hyperArmor = self.HyperArmor,
			iFrames    = self.IFrames
		})

		-- Animation (only if set in cfg)
		if self.AnimationId then
			local hum = char and char:FindFirstChildOfClass("Humanoid")
			if hum then
				local anim = Instance.new("Animation")
				anim.AnimationId = self.AnimationId
				hum:LoadAnimation(anim):Play()
			end
		end

		-- Hitbox params
		local lifetime     = self.Lifetime or 0.2
		local oneShot      = (self.OneShot ~= false)
		local destroyOnHit = (self.DestroyOnHit or oneShot)

		local linkedParts = {}
		if type(self.LinkedParts) == "function" then
			linkedParts = self.LinkedParts(extra)
		elseif type(self.LinkedParts) == "table" then
			linkedParts = self.LinkedParts
		end

		local ignoreList = {}
		if char then table.insert(ignoreList, char) end
		if typeof(extra) == "Instance" then
			table.insert(ignoreList, extra) -- ignore the projectile itself
		end
		if self.IgnoreList then
			for _, inst in ipairs(self.IgnoreList) do table.insert(ignoreList, inst) end
		end

		-- On-hit, we re-check â€œmountedâ€ (covers long-running hitboxes if rider mounts mid-flight)
		local function onHit(targetChar: Model)
			if player and (not node.AllowWhileMounted) and isMountedPlayer(player) then
				if MOUNT_DEBUG then
					print(("[NodeFactory] onHit blocked (now mounted) â–¶ %s  node=%s")
						:format(player.Name, tostring(node.Name or "?")))
				end
				return
			end

			local dmg =
				(typeof(node.Damage) == "number" and { hp = node.Damage, guard = node.GuardDamage or 0, parryable = (node.Parryable ~= false) })
				or (typeof(node.Damage) == "table" and node.Damage)
				or { guard = node.GuardDamage or 0, parryable = (node.Parryable ~= false) }

			DamageService.DealDamage(targetChar, dmg, char)

			if node.Stun and node.Stun > 0 then
				StunService.Apply(targetChar, node.Stun)
			end

			if node.KnockbackForce and node.KnockbackForce > 0 then
				local tr = targetChar:FindFirstChild("HumanoidRootPart")
				if tr and rootPart then
					local dir = (tr.Position - rootPart.Position)
					KnockbackService.Apply(targetChar, dir, node.KnockbackForce, node.KnockbackDur)
				end
			end
		end

		-- Spawn hitbox
		if self.UseMovingHitbox then
			assert(type(self.GetCFrame) == "function", "NodeFactory: GetCFrame(extra) required for moving hitbox")
			HitboxService.CreateMoving(
				function() return self.GetCFrame(extra) end,
				self.Radius, lifetime, ignoreList, oneShot, onHit,
				{ destroyOnHit = destroyOnHit, linkedParts = linkedParts, moving = true }
			)
		else
			HitboxService.Create(
				rootPart.CFrame, self.Radius, lifetime, ignoreList, oneShot, onHit,
				{ destroyOnHit = destroyOnHit, linkedParts = linkedParts }
			)
		end
	end

	return node
end

return NodeFactory


===== FILE: src/shared/NodeManager.lua =====
-- NodeManager.lua (ReplicatedStorage)
-- Maps player -> { nodeName -> nodeModule } and loads only allowed + unlocked nodes
-- Public API: LoadUnlocked, RefreshFromProfile, GetNode, GetAll, AddUnlock, RemoveUnlock, Unload
-- NOW: Mount-safe. Any function on a node is blocked while the caller is Mounted.

local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local Players             = game:GetService("Players")
local NodeModulesFolder   = ReplicatedStorage:WaitForChild("NodeModules")

local NodeManager = {}
local active = {} -- [player] = { [nodeName] = wrappedNodeTable }
NodeManager._playerNodes = active -- for debugging/inspection only

-- ========== Mounted gate wrappers (hard mode: wrap ANY function on the node) ==========
-- weak caches to avoid re-wrapping
local __wrapCache = setmetatable({}, { __mode = "k" })  -- original node tbl -> proxy
local __fnCache   = setmetatable({}, { __mode = "k" })  -- per node: key -> wrapped fn

local function resolvePlayerFromArgs(...)
	-- Supports both call shapes you use:
	--   node.OnStart(player, dir)
	--   node.Execute(player, dir)
	--   node:Execute(rootPart, dir)  -- method form; self in slot 1, BasePart in slot 2
	local a1, a2 = ...
	if typeof(a1) == "Instance" and a1:IsA("Player") then
		return a1
	end
	if typeof(a2) == "Instance" and a2:IsA("BasePart") then
		local char = a2:FindFirstAncestorOfClass("Model")
		if char then return Players:GetPlayerFromCharacter(char) end
	end
	return nil
end

local function isMountedPlayer(player)
	if not player then return false end
	local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
	return hum and hum:GetAttribute("Mounted") == true
end

local function guardFunc(nodeTbl, key, fn)
	-- cache wrapper per (node, key)
	local nodeCache = __fnCache[nodeTbl]
	if not nodeCache then nodeCache = {}; __fnCache[nodeTbl] = nodeCache end
	local cached = nodeCache[key]
	if cached then return cached end

	local wrapped = function(...)
		local plr = resolvePlayerFromArgs(...)
		if isMountedPlayer(plr) then
			-- Uncomment if you want logs:
			-- warn(("[NodeManager] BLOCKED while mounted  node=%s fn=%s"):format(tostring(nodeTbl.Name or key or "?"), tostring(key)))
			return
		end
		return fn(...)
	end
	nodeCache[key] = wrapped
	return wrapped
end

-- Proxy that guards ANY callable; preserves table semantics
local function wrapNodeForMounted(nodeTbl)
	if type(nodeTbl) ~= "table" then return nodeTbl end
	local existing = __wrapCache[nodeTbl]
	if existing then return existing end

	local proxy = setmetatable({}, {
		__index = function(_, k)
			local v = nodeTbl[k]
			if type(v) == "function" then
				return guardFunc(nodeTbl, k, v)
			elseif type(v) == "table" then
				-- If subtable contains callables, theyâ€™ll be guarded on access too (via __index again)
				return v
			else
				return v
			end
		end,
		__newindex = function(_, k, v)
			nodeTbl[k] = v  -- allow nodes to mutate themselves
		end,
		__pairs  = function() return pairs(nodeTbl) end,
		__ipairs = function() return ipairs(nodeTbl) end,
	})

	__wrapCache[nodeTbl] = proxy
	return proxy
end
-- ===============================================================================

-- ---------- ALLOWLIST (cached from RS/Unlockables + defaults mirror) ----------
local DEFAULTS = { "Punch", "Heavy", "Dodge", "BlockStart", "BlockEnd" }
local ALLOWED

local function refreshAllowed()
	local t = {}
	local folder = ReplicatedStorage:FindFirstChild("Unlockables")
	if folder then
		for _, sv in ipairs(folder:GetChildren()) do
			if sv:IsA("StringValue") and sv.Value ~= "" then
				t[sv.Value] = true
			end
		end
	end
	for _, def in ipairs(DEFAULTS) do t[def] = true end
	ALLOWED = t
end

local function getAllowed()
	if not ALLOWED then refreshAllowed() end
	return ALLOWED
end

local unlockFolder = ReplicatedStorage:FindFirstChild("Unlockables")
if unlockFolder then
	unlockFolder.ChildAdded:Connect(refreshAllowed)
	unlockFolder.ChildRemoved:Connect(refreshAllowed)
end

-- ---------- utils ----------
local function toSet(list)
	local s = {}
	if type(list) ~= "table" then return s end
	for _, name in ipairs(list) do
		if type(name) == "string" then s[name] = true end
	end
	return s
end

local function isValidExport(modTable)
	return type(modTable) == "table"
end

local function requireNode(mod)
	local ok, node = pcall(require, mod)
	if not ok then
		warn("[NodeManager] require failed:", mod.Name, node)
		return nil
	end
	if not isValidExport(node) then
		warn("[NodeManager] invalid export:", mod.Name)
		return nil
	end
	-- Store the WRAPPED proxy so even direct access via _playerNodes is mount-safe
	return wrapNodeForMounted(node)
end

-- ---------- API ----------
function NodeManager.LoadUnlocked(player, profileOrList)
	if not player then return end
	local unlockList
	if type(profileOrList) == "table" and profileOrList.Data then
		unlockList = profileOrList.Data.Unlocks or {}
	else
		unlockList = profileOrList or {}
	end

	local allowed  = getAllowed()
	local unlocked = toSet(unlockList)
	local map = {}

	for name in pairs(unlocked) do
		if not allowed[name] then
			warn(('[NodeManager] skipping disallowed node %q'):format(name))
			continue
		end
		local mod = NodeModulesFolder:FindFirstChild(name)
		if not (mod and mod:IsA("ModuleScript")) then
			warn(('[NodeManager] missing module %q'):format(name))
			continue
		end
		local node = requireNode(mod)
		if node then
			map[name] = node -- already wrapped proxy
		end
	end

	active[player] = map

	-- pretty print
	local names = {}
	for k in pairs(map) do table.insert(names, k) end
	table.sort(names)
	print(('[NodeManager] loaded for %s: %s'):format(player.Name, (#names > 0 and table.concat(names, ', ') or '<none>')))
end

function NodeManager.RefreshFromProfile(player, profile)
	if not player or not profile then return end
	NodeManager.LoadUnlocked(player, profile)
end

-- Base GetNode (raw lookup from active). Already returns wrapped nodes.
function NodeManager.GetNode(player, name)
	local set = active[player]
	return set and set[name] or nil
end

-- (Optional extra armor) If someone swaps this later, keep a wrapper layer:
do
	local _origGetNode = NodeManager.GetNode
	function NodeManager.GetNode(player, nodeName)
		local raw = _origGetNode(player, nodeName)
		if raw then
			-- raw is likely already a proxy, but this makes it idempotent
			return wrapNodeForMounted(raw)
		end
		return nil
	end
end

function NodeManager.GetAll(player)
	local set = active[player]
	if not set then return nil end
	local clone = {}
	for k, v in pairs(set) do clone[k] = v end
	return clone
end

function NodeManager.AddUnlock(player, nodeName)
	if not player or type(nodeName) ~= "string" or nodeName == "" then return false end
	local allowed = getAllowed()
	if not allowed[nodeName] then
		warn("[NodeManager] AddUnlock rejected (not allowed):", nodeName)
		return false
	end
	local mod = NodeModulesFolder:FindFirstChild(nodeName)
	if not (mod and mod:IsA("ModuleScript")) then
		warn("[NodeManager] AddUnlock failed: no module", nodeName)
		return false
	end
	local node = requireNode(mod); if not node then return false end
	active[player] = active[player] or {}
	active[player][nodeName] = node -- wrapped proxy
	print(('[NodeManager] hot-loaded %s for %s'):format(nodeName, player.Name))
	return true
end

function NodeManager.RemoveUnlock(player, nodeName)
	if not player or type(nodeName) ~= "string" then return end
	if active[player] then active[player][nodeName] = nil end
end

function NodeManager.Unload(player)
	active[player] = nil
end

return NodeManager

===== FILE: src/shared/NodeSense.lua =====
-- NodeSense.lua
-- Central telemetry bus for node intent/outcomes.
-- Server fires a BindableEvent for AI; optional RemoteEvent for tester HUDs.
-- Tags are simple booleans (not CollectionService tags).

local RunService = game:GetService("RunService")
local Players    = game:GetService("Players")
local RS         = game:GetService("ReplicatedStorage")

local NodeSense = {}

---------------------------------------------------------------------
-- Debug toggles
---------------------------------------------------------------------
NodeSense._debug = true           -- ðŸ”Š default ON per your request
NodeSense._debugDedup = true      -- also log when a message is skipped by dedupe

function NodeSense.SetDebug(on)
	NodeSense._debug = (on == nil) and true or (on and true or false)
end

function NodeSense.SetDebugDedup(on)
	NodeSense._debugDedup = (on == nil) and true or (on and true or false)
end

local function fmtTags(t)
	if typeof(t) ~= "table" then return "" end
	local list = {}
	for k, v in pairs(t) do if v then table.insert(list, tostring(k)) end end
	table.sort(list)
	return table.concat(list, ",")
end

local function pick(ctx, keys)
	if typeof(ctx) ~= "table" then return "" end
	local parts = {}
	for _, k in ipairs(keys) do
		local v = rawget(ctx, k)
		if v ~= nil then table.insert(parts, (k .. "=" .. tostring(v))) end
	end
	return table.concat(parts, " ")
end

---------------------------------------------------------------------
-- Internals
---------------------------------------------------------------------
local function shallowClone(t)
	local c = {}
	if typeof(t) == "table" then
		for k, v in pairs(t) do c[k] = v end
	end
	return c
end

local function tryFreeze(t)
	pcall(function() table.freeze(t) end)
	return t
end

-- Dedup to avoid spam (same actor+node+shot/outcome burst)
NodeSense._dedupeWindowSec   = 0.05
NodeSense._recentKeys        = {}   -- key -> expiry os.clock()
NodeSense._recentMaxEntries  = 256
NodeSense._nextPruneAt       = 0

-- Server-side handles
NodeSense._serverEvent   = nil      -- BindableEvent
NodeSense.ServerEvent    = nil      -- alias for consumers
NodeSense._remoteEvent   = nil      -- RemoteEvent (optional debug)
NodeSense._clientBroadcastEnabled = false
NodeSense._clientFilter  = nil      -- function(player, payload) -> bool

-- Ensure the global RemoteEvent exists (server only, created on demand)
local function ensureRemoteEvent()
	if not RunService:IsServer() then return nil end
	local folder = RS:FindFirstChild("RemoteEvents")
	if not folder then
		folder = Instance.new("Folder")
		folder.Name = "RemoteEvents"
		folder.Parent = RS
	end
	local re = folder:FindFirstChild("NodeSense")
	if not re then
		re = Instance.new("RemoteEvent")
		re.Name = "NodeSense"
		re.Parent = folder
	end
	return re
end

-- Normalize actor (Player or Character or any descendant)
local function normalizeActor(actor)
	local player, model

	if typeof(actor) == "Instance" then
		if actor:IsA("Player") then
			player = actor
			model = player.Character
		elseif actor:IsA("Model") then
			model = actor
			player = Players:GetPlayerFromCharacter(model)
		else
			model = actor:FindFirstAncestorOfClass("Model")
			if model then player = Players:GetPlayerFromCharacter(model) end
		end
	end

	return player, model
end

local function buildKey(actorUserId, actorName, nodeName, shotIndex, outcome)
	local who = actorUserId and ("U" .. tostring(actorUserId)) or ("N" .. tostring(actorName or "?"))
	return table.concat({
		who,
		tostring(nodeName or "?"),
		tostring(shotIndex or "-"),
		tostring(outcome or "start")
	}, "|")
end

local function dedupPass(key, node, actorName)
	local now = os.clock()
	-- Fast path: reject if not expired
	local exp = NodeSense._recentKeys[key]
	if exp and exp > now then
		if NodeSense._debug and NodeSense._debugDedup then
			print(("[NodeSense] DEDUP  node=%s actor=%s key=%s"):format(tostring(node), tostring(actorName), key))
		end
		return true
	end

	-- Record expiry for this key
	NodeSense._recentKeys[key] = now + NodeSense._dedupeWindowSec

	-- Periodic prune
	if now >= (NodeSense._nextPruneAt or 0) then
		NodeSense._nextPruneAt = now + 0.5
		local alive = 0
		for k, v in pairs(NodeSense._recentKeys) do
			if v <= now then
				NodeSense._recentKeys[k] = nil
			else
				alive += 1
			end
		end
		if alive > NodeSense._recentMaxEntries then
			-- Coarse prune: drop half by advancing a cutoff
			local cutoff = now + NodeSense._dedupeWindowSec
			local dropped = 0
			for k, v in pairs(NodeSense._recentKeys) do
				if v <= cutoff then
					NodeSense._recentKeys[k] = nil
					dropped += 1
					if dropped >= math.floor(alive / 2) then break end
				end
			end
		end
	end

	return false
end

---------------------------------------------------------------------
-- Public: CollectTags
-- Infer boolean tags from a node config + optional overrides.
---------------------------------------------------------------------
function NodeSense.CollectTags(nodeConfig, overrides)
	local cfg  = typeof(nodeConfig) == "table" and nodeConfig or {}
	local tags = {}

	local function set(k, v)
		if v then tags[k] = true else tags[k] = nil end
	end

	-- Base inferences
	set("Attack",       (cfg.Damage or 0) > 0)
	set("GuardDamage",  (cfg.GuardDamage or 0) > 0)
	set("Parryable",    cfg.Parryable == true)
	set("StunInflict",  (cfg.Stun or 0) > 0)
	set("KnockbackInflict", (cfg.KnockbackForce or 0) > 0 or (cfg.Knockback or 0) > 0)

	-- Heuristics: range/melee + heavy/m1 based on fields/name
	local name = tostring(cfg.Name or "")
	if cfg.UseMovingHitbox or name:lower():find("revolver") or name:lower():find("shot") then
		set("Ranged", true)
	end
	if cfg.Melee == true then set("Melee", true) end
	if cfg.Heavy == true or name:lower():find("heavy") then set("Heavy", true) end
	if cfg.M1    == true or name:lower():find("m1")    then set("M1", true)    end

	-- Blockable default: any Attack that isn't explicitly Unblockable
	if tags.Attack and cfg.Unblockable ~= true then
		set("Blockable", true)
	end

	-- Merge explicit per-node overrides (cfg.Tags) and call-site overrides
	for _, src in ipairs({ cfg.Tags, overrides }) do
		if typeof(src) == "table" then
			for k, v in pairs(src) do set(k, v) end
		end
	end

	return tags
end

---------------------------------------------------------------------
-- Public: SetClientBroadcast
-- Toggle optional client telemetry; filter is (player, payload) -> bool.
---------------------------------------------------------------------
function NodeSense.SetClientBroadcast(enabled, filterFn)
	if not RunService:IsServer() then return end
	NodeSense._clientBroadcastEnabled = enabled and true or false
	NodeSense._clientFilter = filterFn
	if enabled and not NodeSense._remoteEvent then
		NodeSense._remoteEvent = ensureRemoteEvent()
	end
end

---------------------------------------------------------------------
-- Public: SetDedupeWindow(seconds)
---------------------------------------------------------------------
function NodeSense.SetDedupeWindow(seconds)
	if typeof(seconds) == "number" and seconds >= 0 then
		NodeSense._dedupeWindowSec = seconds
	end
end

---------------------------------------------------------------------
-- Public: Subscribe(fn)
-- Server consumers (like EnemyController) can hook the bus easily.
---------------------------------------------------------------------
function NodeSense.Subscribe(fn)
	if not RunService:IsServer() then return nil end
	if not NodeSense._serverEvent then
		local be = Instance.new("BindableEvent")
		be.Name = "NodeSenseServerEvent"
		NodeSense._serverEvent = be
		NodeSense.ServerEvent  = be
	end
	return NodeSense._serverEvent.Event:Connect(fn)
end

---------------------------------------------------------------------
-- Public: Emit
-- actor: Player or Character/descendant
-- nodeName: string (fallbacks to context.nodeName or "Unknown")
-- tags: table of booleans (may be nil)
-- context: shallow table (numbers/strings only for client mirror)
---------------------------------------------------------------------
function NodeSense.Emit(actor, nodeName, tags, context)
	if not RunService:IsServer() then return end
	if not NodeSense._serverEvent then return end

	local player, model = normalizeActor(actor)
	local actorUserId   = player and player.UserId or nil
	local actorName     = (player and player.Name) or (model and model.Name) or tostring(actor)
	local node          = nodeName or (typeof(context)=="table" and context.nodeName) or "Unknown"

	local ctx = shallowClone(context)
	local tgs = shallowClone(tags)

	-- Dedup key based on actor+node+shotIndex+outcome
	local key = buildKey(actorUserId, actorName, node, ctx and ctx.shotIndex, ctx and ctx.outcome)
	if dedupPass(key, node, actorName) then
		return
	end

	local now = os.clock()
	local payload = {
		actorPlayer = player,       -- (server only) Instance
		actorModel  = model,        -- (server only) Instance
		actorUserId = actorUserId,  -- number or nil
		actorName   = actorName,    -- string
		nodeName    = node,         -- string
		tags        = tgs,          -- table<boolean>
		context     = ctx,          -- table
		serverClock = now,          -- number
	}

	-- ðŸ”Š Debug print (server)
	if NodeSense._debug then
		print(("[NodeSense] EMIT  node=%s  actor=%s(%s)  tags=[%s]  ctx{%s}")
			:format(
				tostring(node),
				tostring(actorName),
				tostring(actorUserId or "NPC"),
				fmtTags(tgs),
				pick(ctx, {
					"outcome","damage","guardDamage","stun","kbForce","targetId","shotIndex"
				})
			)
		)
	end

	-- Fire server-side bus for AI/analytics
	NodeSense._serverEvent:Fire(payload)

	-- Optional client mirror (never sends Instances)
	if NodeSense._clientBroadcastEnabled then
		if not NodeSense._remoteEvent then
			NodeSense._remoteEvent = ensureRemoteEvent()
		end

		local clientCtx = {
			nodeName    = node,
			actorId     = actorUserId,
			actorName   = actorName,
			shotIndex   = ctx and ctx.shotIndex,
			outcome     = ctx and ctx.outcome,
			damage      = ctx and ctx.damage,
			guardDamage = ctx and ctx.guardDamage,
			stun        = ctx and ctx.stun,
			kbForce     = ctx and ctx.kbForce,
			ts          = now,
		}
		local clientPayload = {
			nodeName = node,
			tags     = tgs,
			context  = clientCtx,
		}
		tryFreeze(clientPayload)

		local sent = 0
		if NodeSense._clientFilter then
			for _, plr in ipairs(Players:GetPlayers()) do
				local ok, allowed = pcall(NodeSense._clientFilter, plr, payload)
				if ok and allowed then
					NodeSense._remoteEvent:FireClient(plr, clientPayload)
					sent += 1
				end
			end
		else
			NodeSense._remoteEvent:FireAllClients(clientPayload)
			sent = #Players:GetPlayers()
		end

		if NodeSense._debug then
			print(("[NodeSense] â–¶ client broadcast  node=%s  recipients=%d"):format(node, sent))
		end
	end
end

---------------------------------------------------------------------
-- Public convenience: EmitWithDef (infer tags from node config)
---------------------------------------------------------------------
function NodeSense.EmitWithDef(actor, nodeDef, overrides, context)
	local nodeName = (typeof(nodeDef)=="table" and nodeDef.Name) or (typeof(context)=="table" and context.nodeName) or "Unknown"
	local tags = NodeSense.CollectTags(nodeDef, overrides)
	NodeSense.Emit(actor, nodeName, tags, context)
end

---------------------------------------------------------------------
-- Public convenience: EmitOutcome (standardize outcome strings)
-- outcomes: "Hit" | "Blocked" | "Parried" | "GuardBroken" | "Miss"
---------------------------------------------------------------------
function NodeSense.EmitOutcome(actor, nodeName, outcome, context)
	local ctx = shallowClone(context)
	ctx = ctx or {}
	ctx.outcome = outcome
	NodeSense.Emit(actor, nodeName, nil, ctx)
end

---------------------------------------------------------------------
-- Init (server/client safe)
---------------------------------------------------------------------
if RunService:IsServer() then
	-- Create a single BindableEvent bus for the server
	local be = Instance.new("BindableEvent")
	be.Name = "NodeSenseServerEvent"
	NodeSense._serverEvent = be
	NodeSense.ServerEvent  = be

	-- RemoteEvent is created only if client broadcast enabled
	NodeSense._remoteEvent = RS:FindFirstChild("RemoteEvents")
		and RS.RemoteEvents:FindFirstChild("NodeSense") or nil
else
	-- Clients donâ€™t need the server bus reference
	NodeSense._serverEvent = nil
	NodeSense.ServerEvent  = nil
end

return NodeSense


===== FILE: src/shared/ParryService.lua =====
---------------------------------------------------------------------
-- ParryService  (ReplicatedStorage)
-- â€¢ Block input calls OpenWindow(player[, duration]) â†’ opens a parry window.
-- â€¢ If the defender is struck during the window, Try(attacker, defender)
--   returns true, stuns attacker, ends defenderâ€™s block, and grants brief
--   invulnerability via IFrameStore.
--
-- NodeSense emits (telemetry only; no "Parried" here):
--   ParryWindowStart   { duration }
--   ParryWindowRefresh { added, remaining }
--   ParryWindowEnd     { reason = "Consumed" | "Timeout" | "Clear" }
---------------------------------------------------------------------
local ParryService = {}

------------------------------ SERVICES
local RS               = game:GetService("ReplicatedStorage")
local Players          = game:GetService("Players")

local StunService      = require(RS:WaitForChild("StunService"))
local GuardService     = require(RS:WaitForChild("GuardService"))
local IFrameStore      = require(RS:WaitForChild("IFrameStore"))
local NodeSense        = require(RS:WaitForChild("NodeSense"))

------------------------------ CONFIG
local DEFAULT_WINDOW = 0.3   -- parry timing window (sec)
local PARRY_STUN     = 2.5   -- stun applied to attacker (sec)
local IMMUNITY_TIME  = 1.0   -- defender i-frames after parry (sec)

------------------------------ STATE
-- [defender] = expiry tick()
local windowExpires = {}
-- [defender] = expiry tick()
local immunity      = {}

------------------------------ HELPERS
local function asInstance(ent)
	if typeof(ent) == "Instance" then
		return ent
	elseif typeof(ent) == "table" and typeof(ent.Character) == "Instance" then
		return ent.Character
	end
	return nil
end

local function emit(actor, outcome, ctx)
	pcall(function()
		NodeSense.EmitOutcome(actor, "Parry", outcome, ctx or {})
	end)
end

------------------------------ API
function ParryService.OpenWindow(defender, duration)
	if not defender then return end
	local now = tick()
	local dur = tonumber(duration) or DEFAULT_WINDOW
	local prev = windowExpires[defender] or 0
	local wasActive = prev > now

	local newExp = now + dur
	windowExpires[defender] = newExp

	if wasActive then
		emit(defender, "ParryWindowRefresh", {
			added     = dur,
			remaining = newExp - now,
		})
	else
		emit(defender, "ParryWindowStart", { duration = dur })
	end

	-- schedule end (only ends if expiry wasn't extended)
	local thisExp = newExp
	task.delay(dur, function()
		if windowExpires[defender] == thisExp and thisExp <= tick() then
			windowExpires[defender] = nil
			emit(defender, "ParryWindowEnd", { reason = "Timeout" })
		end
	end)
end

function ParryService.IsActive(defender)
	return (windowExpires[defender] or 0) > tick()
end

function ParryService.HasImmunity(ent)
	return (immunity[ent] or 0) > tick()
end

-- Optional manual clear (e.g., player released block early)
function ParryService.ClearWindow(defender)
	if not defender then return false end
	if not ParryService.IsActive(defender) then return false end
	windowExpires[defender] = nil
	emit(defender, "ParryWindowEnd", { reason = "Clear" })
	return true
end

-- Returns true on successful parry; false otherwise.
function ParryService.Try(attacker, defender)
	if not ParryService.IsActive(defender) then return false end

	-- consume window
	windowExpires[defender] = nil
	emit(defender, "ParryWindowEnd", { reason = "Consumed" })

	-----------------------------------------------------------------
	-- punish attacker
	-----------------------------------------------------------------
	local inst = asInstance(attacker)
	if inst then
		StunService.Apply(inst, PARRY_STUN)
	end

	-----------------------------------------------------------------
	-- defender: end block + grant brief i-frames (invulnerability)
	-----------------------------------------------------------------
	GuardService.EndBlock(defender)
	IFrameStore.Grant(defender, IMMUNITY_TIME, "Parry")
	immunity[defender] = tick() + IMMUNITY_TIME

	return true
end

------------------------------ CLEANUP
Players.PlayerRemoving:Connect(function(plr)
	windowExpires[plr] = nil
	immunity[plr]      = nil
end)

---------------------------------------------------------------------
return ParryService


===== FILE: src/shared/RigMadLibs.lua =====
-- ReplicatedStorage/RigMadLibs.lua
local Players       = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local Debris        = game:GetService("Debris")

local M = {}

local function getHumanoid(rig)
	return rig and rig:FindFirstChildOfClass("Humanoid")
end

local function ensureEnemiesFolder()
	local f = ServerStorage:FindFirstChild("Enemies")
	assert(f, "Put your enemy prefabs in ServerStorage/Enemies")
	return f
end

local function asCSV(list)
	if not list or #list == 0 then return "" end
	local out = {}
	for _, id in ipairs(list) do table.insert(out, tostring(id)) end
	return table.concat(out, ",")
end

-- === SKINNING HELPERS ===
function M.applyUserLook(rig: Model, userId: number)
	local hum = getHumanoid(rig); if not hum then return false end
	local ok, desc = pcall(Players.GetHumanoidDescriptionFromUserId, Players, userId)
	if ok and desc then hum:ApplyDescription(desc); return true end
	return false
end

function M.applyOutfit(rig: Model, outfitId: number)
	local hum = getHumanoid(rig); if not hum then return false end
	local ok, desc = pcall(Players.GetHumanoidDescriptionFromOutfitId, Players, outfitId)
	if ok and desc then hum:ApplyDescription(desc); return true end
	return false
end

-- assets = { shirt=, pants=, face=, hats={}, hair={}, back={}, faceAcc={}, neck={}, front={}, shoulder={}, waist={} }
function M.applyAssets(rig: Model, assets: table)
	local hum = getHumanoid(rig); if not hum then return false end
	local desc = Instance.new("HumanoidDescription")

	-- Classic clothing / face (optional)
	if assets.shirt then desc.Shirt = assets.shirt end
	if assets.pants then desc.Pants = assets.pants end
	if assets.face  then desc.Face  = assets.face end

	-- Accessories (comma-separated strings of asset IDs)
	if assets.hats     then desc.HatAccessory       = asCSV(assets.hats) end
	if assets.hair     then desc.HairAccessory      = asCSV(assets.hair) end
	if assets.back     then desc.BackAccessory      = asCSV(assets.back) end
	if assets.faceAcc  then desc.FaceAccessory      = asCSV(assets.faceAcc) end
	if assets.neck     then desc.NeckAccessory      = asCSV(assets.neck) end
	if assets.front    then desc.FrontAccessory     = asCSV(assets.front) end
	if assets.shoulder then desc.ShoulderAccessory  = asCSV(assets.shoulder) end
	if assets.waist    then desc.WaistAccessory     = asCSV(assets.waist) end

	hum:ApplyDescription(desc)
	return true
end

-- === SPAWN/PREVIEW ===
-- look = { userId = n } OR { outfitId = n } OR { assets = {...} } OR nil
function M.spawn(prefabName: string, parent: Instance?, cf: CFrame?, look: table?)
	local enemies = ensureEnemiesFolder()
	local template = enemies:FindFirstChild(prefabName)
	assert(template, ("Prefab not found: %s in ServerStorage/Enemies"):format(prefabName))

	local rig = template:Clone()
	if cf then rig:PivotTo(cf) end
	rig.Parent = parent or workspace

	if look then
		if look.userId then M.applyUserLook(rig, look.userId)
		elseif look.outfitId then M.applyOutfit(rig, look.outfitId)
		elseif look.assets then M.applyAssets(rig, look.assets)
		end
	end
	return rig
end

-- opts = { anchor=true, autoclean=seconds, nameSuffix="Preview" }
function M.preview(prefabName: string, cf: CFrame?, look: table?, opts: table?)
	opts = opts or {}
	local rig = M.spawn(prefabName, workspace, cf or CFrame.new(0,5,0), look)
	rig.Name = (opts.nameSuffix or "Preview") .. "_" .. prefabName

	local hrp = rig:FindFirstChild("HumanoidRootPart")
	if hrp and (opts.anchor ~= false) then hrp.Anchored = true end

	if tonumber(opts.autoclean) then Debris:AddItem(rig, opts.autoclean) end
	return rig
end

function M.clearPreviews(prefix: string?)
	prefix = prefix or "Preview_"
	for _, m in ipairs(workspace:GetChildren()) do
		if m:IsA("Model") and m.Name:sub(1, #prefix) == prefix then
			m:Destroy()
		end
	end
end

return M


===== FILE: src/shared/SpeedController.lua =====
-- ReplicatedStorage/SpeedController.lua
local SpeedController = {}

-- Key by Humanoid (works for players & NPCs). Weak refs so old humanoids GC.
local activeTimers    = setmetatable({}, { __mode = "k" })
local originalSpeeds  = setmetatable({}, { __mode = "k" })

local function resolveHumanoid(actor)
	if not actor then return nil end
	if typeof(actor) == "Instance" then
		if actor:IsA("Player") then
			local char = actor.Character
			return char and char:FindFirstChildOfClass("Humanoid")
		elseif actor:IsA("Model") then
			return actor:FindFirstChildOfClass("Humanoid")
		elseif actor:IsA("Humanoid") then
			return actor
		end
	end
	return nil
end

function SpeedController.Apply(actor, newSpeed, duration)
	local hum = resolveHumanoid(actor)
	if not hum then return end

	-- store original once per humanoid
	if originalSpeeds[hum] == nil then
		originalSpeeds[hum] = hum.WalkSpeed
	end

	-- clear previous timer for this humanoid
	if activeTimers[hum] then
		task.cancel(activeTimers[hum])
		activeTimers[hum] = nil
	end

	-- apply new speed
	hum.WalkSpeed = newSpeed

	-- optional timed reset
	local dur = tonumber(duration) or 0
	if dur > 0 then
		activeTimers[hum] = task.delay(dur, function()
			if hum.Parent then
				hum.WalkSpeed = originalSpeeds[hum] or 16
			end
			activeTimers[hum]   = nil
			originalSpeeds[hum] = nil
		end)
	end
end

function SpeedController.Reset(actor)
	local hum = resolveHumanoid(actor)
	if not hum then return end

	if originalSpeeds[hum] ~= nil then
		hum.WalkSpeed = originalSpeeds[hum]
	end
	if activeTimers[hum] then
		task.cancel(activeTimers[hum])
		activeTimers[hum] = nil
	end
	originalSpeeds[hum] = nil
end

return SpeedController


===== FILE: src/shared/StunService.lua =====
-- ReplicatedStorage/StunService
-- Hard stun = lock + physics freeze + attack interrupt.
-- Soft stun = slow only (no lock), guaranteed restore for NPC Models.
-- No use of Instance:GetAttribute; invincibility is:
--   â€¢ players: IFrameStore.IsActive(player)
--   â€¢ models:  optional BoolValue child named "Invincible" set true

local StunService = {}

------------------------------ Deps
local RS        = game:GetService("ReplicatedStorage")
local Players   = game:GetService("Players")

local CombatState        = require(RS:WaitForChild("CombatState"))
local AttackStateService = require(RS:WaitForChild("AttackStateService"))
local IFrameStore        = require(RS:WaitForChild("IFrameStore"))
local SpeedController    = require(RS:WaitForChild("SpeedController"))

-- Optional client FX
local RemoteEvents = RS:FindFirstChild("RemoteEvents")
local StunToggle   = RemoteEvents and RemoteEvents:FindFirstChild("StunToggle")

------------------------------ State
local hardEndAt       = {}   -- [entity] = os.clock() deadline
local softEndAt       = {}   -- [entity] = os.clock() deadline
local lockedByStun    = {}   -- [entity] = true if we locked
local activeTracks    = {}   -- [entity] = AnimationTrack
local savedPhys       = {}   -- [entity] = { JumpPower, AutoRotate, PlatformStand }
-- Model baselines for soft-stun restore (weak keys)
local modelBaselineWS = setmetatable({}, { __mode = "k" }) -- [Model] = base WalkSpeed


-- NPC-only slow management (players use SpeedController)
local modelOrigSpeed  = setmetatable({}, { __mode = "k" }) -- [Model] = number
local modelSlowTimer  = setmetatable({}, { __mode = "k" }) -- [Model] = thread
local slowedByStun    = setmetatable({}, { __mode = "k" }) -- [Player] = true

------------------------------ Helpers
local function isInstance(x) return typeof(x) == "Instance" end

local function asModel(ent)
	if not isInstance(ent) then return nil end
	if ent:IsA("Player") then return ent.Character end
	if ent:IsA("Model")  then return ent end
	return nil
end

local function getHumanoid(ent)
	local mdl = asModel(ent)
	return mdl and mdl:FindFirstChildOfClass("Humanoid") or nil
end

local function rootOf(ent)
	local mdl = asModel(ent)
	return mdl and mdl:FindFirstChild("HumanoidRootPart") or nil
end

local function clamp(x, a, b) return math.max(a, math.min(b, x)) end
local function now() return os.clock() end

local function safeEmitToggle(ent, on)
	if StunToggle and ent and ent:IsA("Player") then
		pcall(function() StunToggle:FireClient(ent, on) end)
	end
end

-- No attributes: prefer IFrameStore for players; for NPCs allow a BoolValue named "Invincible"
local function isInvincible(ent)
	if not isInstance(ent) then return false end

	if ent:IsA("Player") then
		return IFrameStore.IsActive(ent) == true
	end

	local mdl = asModel(ent)
	if not mdl then return false end
	local flag = mdl:FindFirstChild("Invincible")
	return (flag and flag:IsA("BoolValue") and flag.Value) == true
end
local function modelOf(ent)
	if ent and ent:IsA("Player") then return ent.Character end
	return ent
end

local function ensureBaselineWS(mdl, hum)
	-- If we don't have a baseline, compute a safe one.
	if not modelBaselineWS[mdl] then
		local ws = hum.WalkSpeed
		if ws < 10 or ws > 30 then ws = 16 end
		modelBaselineWS[mdl] = ws
	end
	return modelBaselineWS[mdl]
end

------------------------------ Internal clears
local function clearHard(ent)
	hardEndAt[ent] = nil

	if lockedByStun[ent] then
		CombatState.Unlock(ent, "Stun:HardClear")
		lockedByStun[ent] = nil
	end

	local hum = getHumanoid(ent)
	local s   = savedPhys[ent]
	if hum and s then
		hum.JumpPower     = s.JumpPower
		hum.AutoRotate    = s.AutoRotate
		hum.PlatformStand = s.PlatformStand
	end
	savedPhys[ent] = nil

	local track = activeTracks[ent]
	if track then pcall(function() track:Stop() end) end
	activeTracks[ent] = nil

	safeEmitToggle(ent, false)
end

local function clearSoft(ent)
	softEndAt[ent] = nil

	if ent:IsA("Player") and slowedByStun[ent] then
		-- Let SpeedController restore naturally; hard-reset only if you want:
		-- SpeedController.Reset(ent)
		slowedByStun[ent] = nil
	end

	-- Models: restore baseline WalkSpeed
local mdl = asModel(ent)
local hum = getHumanoid(ent)
if mdl and hum then
	local base = ensureBaselineWS(mdl, hum)
	hum.WalkSpeed = base
end

-- cancel any pending model timer
local mdl2 = asModel(ent)
if mdl2 and modelSlowTimer[mdl2] then
	task.cancel(modelSlowTimer[mdl2])
	modelSlowTimer[mdl2] = nil
end


	safeEmitToggle(ent, false)
end

local function scheduleHardClear(ent, untilTime)
	task.delay(math.max(0, untilTime - now()), function()
		if hardEndAt[ent] and hardEndAt[ent] <= now() then
			clearHard(ent)
		end
	end)
end

local function scheduleSoftClear(ent, untilTime)
	task.delay(math.max(0, untilTime - now()), function()
		if softEndAt[ent] and softEndAt[ent] <= now() then
			clearSoft(ent)
		end
	end)
end

------------------------------ API
-- StunService.Apply(entity, duration, opts?)
-- opts:
--   hard       = true|false (default true). false = slow only
--   moveScale  = 0..1 (soft stun speed multiplier; default 0.20)
--   animId     = stun loop AnimationId (hard only)
function StunService.Apply(entity, duration, opts)
	if not isInstance(entity) or type(duration) ~= "number" or duration <= 0 then return end

	-- invulnerability checks (no attributes)
	if isInvincible(entity) then return end

	local hard    = true
	local scale   = 0.20
	local animId  = "rbxassetid://92836816904936"

	if type(opts) == "table" then
		if opts.hard == false         then hard  = false end
		if type(opts.moveScale)=="number" then scale = clamp(opts.moveScale, 0, 1) end
		if type(opts.animId)  == "string" and #opts.animId > 0 then animId = opts.animId end
	end

	local tEnd = now() + duration

	if hard then
		-- interrupt (skips if hyper-armor)
		pcall(AttackStateService.Interrupt, entity, "Stun")

		hardEndAt[entity] = math.max(hardEndAt[entity] or 0, tEnd)

		if not lockedByStun[entity] then
			lockedByStun[entity] = true
			CombatState.Lock(entity, "Stun:Hard")
		end

		local hum = getHumanoid(entity)
		if hum then
			if not savedPhys[entity] then
				savedPhys[entity] = {
					JumpPower     = hum.JumpPower,
					AutoRotate    = hum.AutoRotate,
					PlatformStand = hum.PlatformStand,
				}
			end
			hum.JumpPower     = 0
			hum.AutoRotate    = false
			hum.PlatformStand = true

			if not activeTracks[entity] then
				local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
				local a = Instance.new("Animation")
				a.AnimationId = animId
				local track = animator:LoadAnimation(a)
				track.Looped = true
				track:Play()
				activeTracks[entity] = track
			end
		end

		safeEmitToggle(entity, true)
		scheduleHardClear(entity, hardEndAt[entity])
	else
		softEndAt[entity] = math.max(softEndAt[entity] or 0, tEnd)

		local hum = getHumanoid(entity)
		if hum then
			if entity:IsA("Player") then
				local base   = hum.WalkSpeed
				local target = math.max(1, base * scale)
				slowedByStun[entity] = true
				SpeedController.Apply(entity, target, duration)
			else
				-- Models: baseline-safe slow so we never get â€œperma-slowâ€
				local mdl = asModel(entity)
				if mdl then
					if modelSlowTimer[mdl] then task.cancel(modelSlowTimer[mdl]) end

					local hum = getHumanoid(entity)
					if hum then
						local base = ensureBaselineWS(mdl, hum)
						hum.WalkSpeed = math.max(1, base * scale)

						modelSlowTimer[mdl] = task.delay(duration, function()
							-- if someone extended, honor it (existing logic)
							if softEndAt[entity] and softEndAt[entity] > now() then
								scheduleSoftClear(entity, softEndAt[entity])
							else
								-- restore to BASELINE (not to whatever was current)
								if hum and hum.Parent then
									hum.WalkSpeed = base
								end
								modelSlowTimer[mdl] = nil
								-- we keep the baseline for future uses; do not nil it
								softEndAt[entity] = nil
							end
						end)
					end
				end

			end
		end

		safeEmitToggle(entity, true)
		scheduleSoftClear(entity, softEndAt[entity])
	end
end

function StunService.Clear(entity)
	if not isInstance(entity) then return end
	if hardEndAt[entity] then clearHard(entity) end
	if softEndAt[entity] then clearSoft(entity) end
end

function StunService.IsStunned(entity)
	local t = hardEndAt[entity]
	return t ~= nil and t > now()
end

------------------------------ Cleanup
Players.PlayerRemoving:Connect(function(plr)
	StunService.Clear(plr)
end)

return StunService


===== FILE: default.project.json =====
{
  "name": "Steve-Lebron",
  "tree": {
    "$className": "DataModel",

    "ReplicatedStorage": {
      "$className": "ReplicatedStorage",
      "AI":          { "$path": "src/shared/AI" },
      "Horses":      { "$path": "src/shared/Horses" },
      "NodeModules": { "$path": "src/shared/NodeModules" },
      "Stories":     { "$path": "src/shared/Stories" },
      "Unlockables": { "$path": "src/shared/Unlockables" }
    },

    "ServerScriptService": {
      "$className": "ServerScriptService",
      "$path": "src/server"
    },

    "ServerStorage": {
      "$className": "ServerStorage",
      "Enemies":        { "$path": "src/serverstorage/Enemies" },
      "NPCs":           { "$path": "src/serverstorage/NPCs" },
      "RBX_ANIMSAVES":  { "$path": "src/serverstorage/RBX_ANIMSAVES" }
    },

    "StarterPlayer": {
      "$className": "StarterPlayer",
      "StarterPlayerScripts":     { "$path": "src/client/StarterPlayerScripts" },
      "StarterCharacterScripts":  { "$path": "src/client/StarterCharacterScripts" }
    },

    "StarterGui": {
      "$className": "StarterGui",
      "ScreenGui": { "$path": "src/client/StarterGui/ScreenGui" }
    }
  }
}


